<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker 笔记</title>
    <url>/2022/09/24/Docker-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[安装官方安装参考
步骤一 卸载旧版本
sudo yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-engine

步骤二 配置 yum 并安装 docker
sudo yum install -y yum-utilssudo yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.reposudo yum install docker-ce docker-ce-cli containerd.io

步骤三 启动
sudo systemctl start docker

阿里云镜像加速https://cr.console.aliyun.com/cn-hangzhou/instances/repositories
命令docker images如果只需要输出特定镜像信息，则使用 docker images &lt;REPOSITORY&gt; 即可
$ docker imagesREPOSITORY    TAG       IMAGE ID       CREATED         SIZEmysql         5.6       eb4e842271a4   4 days ago      303MB




字段
含义



REPOSITORY
镜像仓库源


TAG
镜像的标签


IMAGE ID
镜像 ID


CREATED
创建时间


SIZE
镜像大小



同一个仓库源可以有多个 TAG，代表仓库源的不同版本

如果不指定一个镜像的版本 TAG，默认使用 latest 镜像


docker search从 docker hub 上搜索
列出收藏数不小于 10 的镜像数
docker search -f stars=10 java# 旧版 docker 命令docker search -s 10 java

docker pull拉取镜像
docker pull &lt;repository&gt;:&lt;tag&gt;
如果不指定一个镜像的版本 TAG，默认使用 latest 镜像
docker rmi删除镜像，支持多个参数docker rmi &lt;repository&gt;:&lt;tag&gt; [&lt;repository&gt;:&lt;tag&gt; ...]
如果不指定一个镜像的版本 TAG，默认使用 latest 镜像。所以，想删除 mysql:5.6，使用 docker rmi mysql:5.6。
如果有容器正在运行，且需要删除，则使用 -f 参数
docker run创建容器并启动运行docker run [OPTIONS] IMAGE [COMMAND] [ARG...]



选项
含义



–name&#x3D;”容器名”
为容器指定一个名称，未指定会随机生成


-d
后台运行


-i
交互模式，通常和 -t 一起使用


-t
为容器分配一个伪输入终端


-P
随机端口映射


-p
指定端口映射


docker ps


选项
含义



-a
列出所有的的容器，包括正在运行的和已经退出的


-l
列出最近创建的容器


-n
显示最近创建的 n 个容器


-q
静默模式，只显示容器编号


–no-trunc
不截断输出


docker startdocker start &lt;CONTAINER ID | NAMES&gt;
退出exit 关闭离开
CTRL + P + Q 保持运行离开
docker restartdocker restart &lt;CONTAINER ID | NAMES&gt;
docker stopdocker stop &lt;CONTAINER ID | NAMES&gt;
docker killdocker kill &lt;CONTAINER ID | NAMES&gt;
docker rmdocker rm &lt;CONTAINER ID | NAMES&gt;
一次性删除多个容器
docker rm -f $(docker ps -a -q)docker ps -a -q | xargs docker rm

docker logs显示日志
docker logs -f -t –tail 



选项
含义



-t
显示时间


-f
追加


-tail n
显示倒数 n 行


docker top查看容器进程
docker top &lt;CONTAINER ID | NAMES&gt;
docker inspect审查容器
docker exec在容器中打开新的终端，并且可以启动新的进程
语法格式 docker exec -t &lt;CONTAINER ID | NAMES&gt;
docker cpdocker cp &lt;CONTAINER ID | NAMES&gt;:&lt;容器内路径&gt; &lt;目的主机路径&gt;
docker commit提交容器副本使之成为一个新的镜像
docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者名&quot; &lt;CONTAINER ID | NAMES&gt; &lt;NEW NAMES&gt;:[标签名]
docker exec进入容器
docker exec -it b7a9f5eb6b85 sh
]]></content>
  </entry>
  <entry>
    <title>Linux 磁盘笔记</title>
    <url>/2022/09/22/Linux-%E7%A3%81%E7%9B%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[df -h[root@linux30 ~]# df -h文件系统                 容量  已用  可用 已用% 挂载点devtmpfs                 1.9G     0  1.9G    0% /devtmpfs                    1.9G     0  1.9G    0% /dev/shmtmpfs                    1.9G   12M  1.9G    1% /runtmpfs                    1.9G     0  1.9G    0% /sys/fs/cgroupdev/mapper/centos-root   17G   17G  246M   99% //dev/sda1               1014M  195M  820M   20% /boottmpfs                    378M     0  378M    0% /run/user/0]]></content>
  </entry>
  <entry>
    <title>Kubernetes 笔记</title>
    <url>/2022/09/26/Kubernetes-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[POD 共享相同的 IP 地址和端口空间
同一 POD 中，容器运行的多个进程不能绑定到相同端口号，否则端口冲突。
一个 POD 中，所有容器也都具有相同的 loopback 网络接口，因此容器之间可以通过 localhost 与同一 POD 中的其他容器进行通信
]]></content>
  </entry>
  <entry>
    <title>MyBatis 版本变更</title>
    <url>/2022/11/08/MyBatis-%E7%89%88%E6%9C%AC%E5%8F%98%E6%9B%B4/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Nginx 官方学习笔记</title>
    <url>/2022/07/12/Nginx-%E5%AE%98%E6%96%B9%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[Nginx 官方学习笔记Module 参考ngx_http_core_module
语法：server_name name …;默认：server_name “”;上下文：server

设置虚拟主机名，例如：
server &#123;    server_name example.com www.example.com;&#125;

第一个名字成为主服务名。
服务名可以包含一个星号（”*”）替换名字的第一个部分或者最后一个部分：
server &#123;    server_name example.com *.example.com www.example.*;&#125;

这样的名称称为通配符名。
上面提到的前两个名称可以合并为一个：
server &#123;    server_name .example.com;&#125;

也可以在服务名称中使用正则表达式，并在名字前面使用波浪号（”~”）：
server &#123;    server_name www.example.com ~^www\d+\.example\.com$;&#125;

正则表达式中有名捕获会创建变量（0.8.25），之后可以在其他指令中使用：
server &#123;    server_name ~^(www\.)?(?&lt;domain&gt;.+)$;    location / &#123;        root /sites/$domain;    &#125;&#125;server &#123;    server_name _;    location / &#123;        root /sites/default;    &#125;&#125;

允许该服务在没有 “Host” 头部字段的情况下为给定的 address:port 对处理请求。

在 0.8.48 之前，默认使用机器的主机名。

ngx_http_log_modulengx_http_log_module 模块以指定格式写入请求日志
Example Configurationlog_format compression &#x27;$remote_addr - $remote_user [$time_local] &#x27;                       &#x27;&quot;$request&quot; $status $bytes_sent &#x27;                       &#x27;&quot;$http_referer&quot; &quot;$http_user_agent&quot; &quot;$gzip_ratio&quot;&#x27;;access_log /spool/logs/nginx-access.log compression buffer=32k;

Directivesaccess_log语法：
access_log [path [buffer=size] [gzip[=level]] [flush=time] [if=condition]];access_log off;
默认值:
access_log logs/access.log combined;
上下文：
http, server, location, if in location, limit_except

为缓冲日志写入设置 path，format，以及配置。可以在同一配置级别上指定几个日志。可以在第一个参数中指定 “syslog:“ 前缀来配置日志记录到 syslog。特殊值 off 取消当前级别上所有的 access_log 指令。如果没有指定 format，那么就会使用预定义的 “combined”。
如果使用 buffer 或者 gzip 参数，那么写入日志将会缓冲。
当开启缓冲时，以下几种时机将会把数据写入文件：

如果下一行日志放不下缓冲区；
如果缓冲数据比 flush 参数指定的还要旧；
当工作进程重新打开日志文件，或者工作进程关闭

如果使用 gzip 参数，则在写入文件之前压缩缓冲区的数据。压缩的级别可以设置在 1（最快，压缩率低）到 9 （最慢，压缩率高）之间。默认情况下，缓冲区大小为 64K 字节，压缩级别为 1。由于数据在原子块中压缩，日志文件可以通过 “zcat“ 解压缩或读取。
例如：
access_log /path/to/log.gz combined gzip flush=5m;

文件路径可以包含变量（0.7.6+），但是此类日志有一些约束：

由 worker process 使用的用户凭据应该有权限使用此类日志在文件夹创建文件
不可以使用缓冲写
为每个日志写入打开并关闭文件。但是，由于可以将频繁使用的文件描述符存储到缓存中，在由 open_log_file_cache 指令的 valid 参数指定的时间内，旧文件的写入可以继续。
在每个日志写入过程中，请检查请求的 root 目录是否存在，如果不存在，日志不会创建。因此，指定 root 和 access_log 以相同的配置级别是一个好主意：

server &#123;    root       /spool/vhost/data/$host;    access_log /spool/vhost/logs/$host;    ...&#125;

if 参数可以开启有条件的日志记录。如果 condition 等于 0 或者一个空字符串，则不会记录请求。在下面的示例中，请求码为 2xx 以及 3xx 不会被记录：
map $status $loggable &#123;    ~^[23]  0;    default 1;&#125;access_log /path/to/access.log combined if=$loggable;

log_format日志格式可以包含一些通用的变量，以及一些仅仅存在于日志写入时的变量：
$bytes_sent 客户端发送的字节数
$connection 连接序列号
$connection_requests 通过一个连接发起的请求的当前序号
$msec 日志写入的时间，以秒为单位，精确到毫秒
$pipe 如果请求是管道，则是 “p”，否则为 “.”
$request_length 请求长度（包含请求行，头部，以及请求体）
$request_time 请求处理时间，以秒为单位，精确到毫秒，从客户端读取第一个字节，并在最后一个字节发送给客户端之后写入日志所用时间
$status 响应状态码
$time_iso8601 以 ISO 8601 标准格式的本地时间。类似 2022-07-12T15:05:16+08:00
$time_local 以通用日志格式的本地时间。类似 12/Jul/2022:15:05:16 +0800
配置始终包含预定义的 “combined“ 格式：
log_format combined &#x27;$remote_addr - $remote_user [$time_local] &#x27;                    &#x27;&quot;$request&quot; $status $body_bytes_sent &#x27;                    &#x27;&quot;$http_referer&quot; &quot;$http_user_agent&quot;&#x27;;


open_log_file_cache定义一个缓冲，该缓冲存储了名称包含变量的频繁使用的日志文件描述符。该指令具有如下参数：
max
inactive
min_uses
valid
设置应该检查仍然存在相同名称的文件的时间，默认情况下，为 60 秒
off禁用缓存
]]></content>
  </entry>
  <entry>
    <title>SQL With 关键字用法</title>
    <url>/2022/10/27/SQL-With-%E5%85%B3%E9%94%AE%E5%AD%97%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[
递归树形

WITH RECURSIVE temp_dept ( &quot;depth&quot;, &quot;id&quot;, &quot;pid&quot;, &quot;name&quot;, &quot;full_path&quot; ) AS (    SELECT        1,        &quot;id&quot;,        pid,        &quot;name&quot;,        &quot;name&quot;     FROM        dept     WHERE        pid IS NULL UNION ALL    SELECT        parent.&quot;depth&quot; + 1,        child.&quot;id&quot;,        child.&quot;pid&quot;,        child.&quot;name&quot;,        CONCAT ( parent.full_path, &#x27;/&#x27;, child.&quot;name&quot;) :: varchar(100)    FROM        dept as child        INNER JOIN temp_dept AS parent ON child.pid = parent.&quot;id&quot;    ) SELECT * FROM temp_dept]]></content>
  </entry>
  <entry>
    <title>SSH 公私钥</title>
    <url>/2022/11/03/SSH-%E5%85%AC%E7%A7%81%E9%92%A5/</url>
    <content><![CDATA[sudo vim /etc/ssh/sshd_config# ----------------------------------------# 是否允许 root 远程登录PermitRootLogin yes# 密码登录是否打开PasswordAuthentication yes# 开启公钥认证RSAAuthentication yes # 这个参数可能没有 没关系PubkeyAuthentication yes# 存放登录用户公钥的文件位置# 位置就是登录用户名的家目录下的 .ssh# root 就是 /root/.ssh# foo 就是 /home/foo/.sshAuthorizedKeysFile .ssh/authorized_keys# ----------------------------------------


重启 
service sshd restart


客户端生成公私钥

ssh-keygen

客户端上传到服务器

ssh-copy-id -i user/.ssh/id_rsa.pub user@ip# 或使用scp上传]]></content>
  </entry>
  <entry>
    <title>VirtualBox 使用笔记</title>
    <url>/2022/09/22/VirtualBox-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[安装增强的问题
安装提示 modprobe vboxguest failed

参考 https://www.cnblogs.com/mychangee/p/12087954.html
yum install -y kernel-devel gcc //安装kernel-devel和gcc编译工具链yum -y upgrade kernel kernel-devel //更新kernel和kernel-devel到最新版本reboot //重启，重启时，选择最新版本的内核启动



共享粘贴板

Settings &gt; General &gt; Advanced &gt; 共享粘贴板

增强功能

鼠标自由切换；共享粘贴板
一些视图显示的问题一些操作系统，CentOS 本身支持分辨率的调整
View &gt; Adjust Window Size 自适应分辨率
参考https://blog.csdn.net/yuexiaxiaoxi27172319/article/details/121079338

使用 VBoxManage 修改

VBoxManage.exe modifyhd &quot;D:\ubuntu18.vdi&quot; --resize 60000



使用 gparted 调整分区

http://gparted.sourceforge.net/download.php
]]></content>
      <tags>
        <tag>VirtualBox</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/09/22/hello-world/</url>
    <content><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick StartCreate a new post$ hexo new &quot;My New Post&quot;

More info: Writing
Run server$ hexo server

More info: Server
Generate static files$ hexo generate

More info: Generating
Deploy to remote sites$ hexo deploy

More info: Deployment
]]></content>
  </entry>
  <entry>
    <title>各类场景请求参数</title>
    <url>/2022/05/24/%E5%9C%BA%E6%99%AF%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[
身份证号码

存在 X 这种非数字的符号，需要注意用户可能会小写
]]></content>
  </entry>
  <entry>
    <title>软件架构的杂项记录</title>
    <url>/2022/09/20/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E7%9A%84%E6%9D%82%E9%A1%B9%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[传统软件架构：客户层、表现层、控制层、业务逻辑层、数据库层
客户层: 一般指客户端和浏览器
表现层: 将客户端的请求提交到业务层, 将控制层的返回的数据渲染展示给客户
控制层: 等同于 MVC 中的控制层。接受表现层的请求寻找相应的业务处理
业务逻辑层：实现业务逻辑
数据库层：存放和管理用户所使用的数据
传统软件架构：客户层、表现层、控制层、业务逻辑层、数据库层
多租户数据存储方案
独立数据库

最便捷。物理上，每个租户都单独拥有自己的一整套数据，而且是单独存放。

具体来说，多个机器分别安装 MySQL 实例，每个企业使用单独一台机器。


共享数据库，隔离数据架构

所有租户共同使用一个数据库，但是各自有各自的一套不同的数据表结构。

具体来说，单台机器安装 MySQL，可以通过不同的 schema （库）区分，也可以通过表名区分，例如：a_user, b_user


共享数据库，共享数据架构

所有租户共享同一个数据表，同一个数据表结构，存储在同一模式中。

具体来说，将所有租户都记录在同一张表中，通过特定字段区分。例如，通过 TenantID 区别

]]></content>
  </entry>
  <entry>
    <title>Android 笔记</title>
    <url>/2022/07/18/Android/Android-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[清单文件ActivitiesFragments创建一个 fragment一个 fragment 表示某个 activity 中用户接口的一个模块化部分。一个 fragment 有它自己的生命周期，接受它自己的输入事件，并且你可以在activity 运行时添加或移除 fragment。
设置环境fragments 需要 AndroidX fragment 库的依赖。为此，你需要添加 Google Maven 仓库到你的项目 build.grade 文件。
buildscript &#123;    ...    repositories &#123;        google()        ...    &#125;&#125;allprojects &#123;    repositories &#123;        google()        ...    &#125;&#125;

为了将 AndroidX Fragment 库包含到你的项目，需要在你的 App 的 build.gradle 文件添加如下依赖：
dependencies &#123;    def fragment_version = &quot;1.3.5&quot;    // Java language implementation    implementation &quot;androidx.fragment:fragment:$fragment_version&quot;    // Kotlin    implementation &quot;androidx.fragment:fragment-ktx:$fragment_version&quot;&#125;

创建一个 fragment 类为了创建一个 fragment，需要继承 AndroidX 的 Fragment 类，并覆盖它的方法，类似你创建一个 Activity 类。为了创建一个定义了自己的布局的最小 fragment，需要为基本构造器提供 fragment 的布局资源。如下所示：
class ExampleFragment extends Fragment &#123;    public ExampleFragment() &#123;        super(R.layout.example_fragment);    &#125;&#125;

Fragment 库还提供了更多专业的 fragment 基类：

DialogFragment显示悬浮对话框，使用此类创建一个对话框是一个对于使用 Activity  dialog helper 方法的好的替代方案，因为 fragment 会自动处理对话框的创建和清理。详细信息参考 DialogFragment。

PreferenceFragmentCompat显示作为列表的 Preference 对象的层次结构。你可以使用PreferenceFragmentCompat 来为你的 App 创建一个设置屏幕。


添加一个 fragment 到 activity通常，你的 fragment 必须嵌入在 AndroidX FragmentActivity 中，用以贡献一部分 UI 到 activity 布局。FragmentActivity 是 AppCompatActivity 基类，因此如果你已经在你的 App 中为 AppCompatActivity 提供了向后兼容性，那么你不必改变你的 activity 基类。
你可以通过两种方式添加 fragment：

在 activity 的布局文件中定义片段
在 activity 布局文件定义 fragment 容器，后面通过程序添加到 activity。

在任何一种情况下，你都需要添加一个 FragmentContainerView，定义了 fragment 应该放在 activity 试图层次结构中的位置。
强烈建议：使用 Fragment 作为 fragment 的容器，因为 FragmentContainerView 包含了其他 View Group（如 FrameLayout）没有提供的修复程序。
通过 XML 添加 fragment为了声明将 fragment 添加到你的 activity 布局 XML，你需要添加一个 FragmentContainerView 元素：
&lt;!-- res/layout/example_activity.xml --&gt;&lt;androidx.fragment.app.FragmentContainerView    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:id=&quot;@+id/fragment_container_view&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:name=&quot;com.example.ExampleFragment&quot; /&gt;
Android:name 指定要实例化的 fragment 类名。当 activity 布局填充时，指定的 fragment 会实例化，当新实例化 fragment 时，onInflate() 会被调用，并且会创建一个 FragmentTransaction 去将 fragment 添加到 FragmentManager。
程序化添加 fragment为了程序化添加 fragment 到 activity，布局应该引入 FragmentContainerView 作为 fragment 容器，如下所示：
&lt;!-- res/layout/example_activity.xml --&gt;&lt;androidx.fragment.app.FragmentContainerView    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:id=&quot;@+id/fragment_container_view&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot; /&gt;
与 XML 方式不同，android:name 属性并未使用，因此不会自动实例化特定 fragment。相反，使用 FragmentTransaction 来实例化 fragment 并将其添加到 activity 的布局中。
当你的 activity 在运行时，你可以制造 fragment transaction 例如添加、删除或者替换 fragment。在 FragmentActivity 中，你可以获得 FragmentManager 的实例，你可以通过它创建 FragmentTransaction。 在 activity 的 onCreate() 方法中，你可以使用 FragmentTransaction.add() 实例化你的 fragment，传递参数 ViewGroup ID 和 fragment Class，然后提交事务，如下图所示：
public class ExampleActivity extends AppCompatActivity &#123;    public ExampleActivity() &#123;        super(R.layout.example_activity);    &#125;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        if (savedInstanceState == null) &#123;            getSupportFragmentManager().beginTransaction()                .setReorderingAllowed(true)                .add(R.id.fragment_container_view, ExampleFragment.class, null)                .commit();        &#125;    &#125;&#125;


注意：当执行一个 FragmentTransaction 时，你应该总是使用 setReorderingAllowed(true)。更多信息参考官网。

在前面的例子中，请注意，只有在 savedInstanceState 为 null 时，才会创建 fragment 事务。这是为了确保仅仅当 activity 第一次创建的时候，fragment 才会添加一次。发生配置更改或者 activity recreate，savedInstanceState 不再为 null，并且不需要再添加一次 fragment，因为 fragment 可以自动从 savedInstanceState 恢复。
如果你的 fragment 需要一些初始化数据，你可以通过在调用 FragmentTransaction.add() 时提供一个 Bundle，如下图所示：
public class ExampleActivity extends AppCompatActivity &#123;    public ExampleActivity() &#123;        super(R.layout.example_activity);    &#125;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        if (savedInstanceState == null) &#123;            Bundle bundle = new Bundle();            bundle.putInt(&quot;some_int&quot;, 0);            getSupportFragmentManager().beginTransaction()                .setReorderingAllowed(true)                .add(R.id.fragment_container_view, ExampleFragment.class, bundle)                .commit();        &#125;    &#125;&#125;
在 fragment 中，你可以通过调用 requireArguments() 来获取参数 Bundle，并且可以使用适合的 getter 方法来获取每个参数。
class ExampleFragment extends Fragment &#123;    public ExampleFragment() &#123;        super(R.layout.example_fragment);    &#125;    @Override    public void onViewCreated(@NonNull View view, Bundle savedInstanceState) &#123;        int someInt = requireArguments().getInt(&quot;some_int&quot;);        ...    &#125;&#125;


OkHttpimplementation &#x27;com.squareup.okhttp3:okhttp:4.9.0&#x27;

&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>向 Activity 添加 Fragment</title>
    <url>/2022/07/18/Android/%E5%90%91-Activity-%E6%B7%BB%E5%8A%A0-Fragment/</url>
    <content><![CDATA[向 Activity 添加 Fragment方式一在 Activity 的布局文件内声明片段
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;horizontal&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;fragment android:name=&quot;com.example.news.ArticleListFragment&quot;            android:id=&quot;@+id/list&quot;            android:layout_weight=&quot;1&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot; /&gt;    &lt;fragment android:name=&quot;com.example.news.ArticleReaderFragment&quot;            android:id=&quot;@+id/viewer&quot;            android:layout_weight=&quot;2&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt;


&lt;fragment&gt; 的 android:name 属性指定要在布局中进行实例化的 Fragment 类。
创建 activity 布局时，系统会将每个 fragment 实例化，并调用 OnCreateView() 方法，以检索每个片段的布局。系统会返回插入 fragment 后的 View。

注意：每个片段都需要唯一标识符，重启 Activity 时，系统可使用该标识符来恢复片段（您也可以使用该标识符来捕获片段，从而执行某些事务，如将其移除）。可以通过两种方式为片段提供 ID：

为 android:id 属性提供唯一 ID。为 android:tag 属性提供唯一字符串。
方式二在 activity 运行期间，可以随时将片段添加到 activity 布局中，只需指定 fragment 放入哪个 ViewGroup。
在 activity 中执行片段事务（如添加、移除或替换片段），必须使用 FragmentTransaction API。
可以从 FragmentActivity 获取一个FragmentTransaction实例：
FragmentManager fragmentManager = getSupportFragmentManager();FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();

然后，使用 add() 方法添加片段，指定要添加的片段以及插入哪个视图：
ExampleFragment fragment = new ExampleFragment();fragmentTransaction.add(R.id.fragment_container, fragment);fragmentTransaction.commit();

一旦通过 FragmentTransaction 做出了更改，就必须调用 commit() 以使更改生效。
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>GitLab CI/CD 笔记</title>
    <url>/2022/09/25/CICD/GitLab-CI-CD-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[参考https://docs.gitlab.com/ee/ci/yaml/#keywords
安装GitLab Runnerdocker run --rm -v /srv/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner register \    --non-interactive \    --executor &quot;docker&quot; \    --docker-image alpine:latest \    --url &quot;http://192.168.101.101&quot; \    --registration-token &quot;FNc7eS247zHfjLgugiw4&quot; \    --description &quot;gitlab-runner&quot; \    --tag-list &quot;docker-ci-cd&quot; \    --run-untagged=&quot;true&quot; \    --locked=&quot;true&quot; \    --access-level=&quot;not_protected&quot;



如果出现执行器 executor=docker 主机名无法解析的情况，编辑 /etc/gitlab-runner/config.toml，在 [runners.docker] 增加配置:
extra_hosts = [&quot;主机名:IP&quot;]



查询 Runner

gitlab-runner list



删除 Runner

如果在 GitLab 中删除了 Runner，还需要在 GitLab Runner 中继续删除:
# 删除所有的，跳过激活状态的gitlab-runner verify --delete# 删除指定 namegitlab-runner verify --delete --name xxx


Runner Token 类型
shared

Admin &gt; Overview &gt; Runners

Group

Groups &gt; Settins &gt; CI&#x2F;CD

project

项目 &gt; Settins &gt; CI&#x2F;CD
Keywords使用 job 关键字配置 job:



关键字
描述



retry
在失败的时候，job 何时重试，以及重试多少次


script
runner 执行的 shell 脚本


stage
定义任务的 stage


Global keywordsstages在 job 中使用 stage 可以将 job 配置在特定的阶段运行
如果 .gitlab-ci.yml 没有定义 stages，默认的 pipeline 阶段是:

如果你自定义了 stages，那么默认阶段配置不再生效


.pre
build
test
deploy
.post

stages 中项目的顺序定义了 job 的执行顺序:

jobs 在同一阶段并行运行
在前面的阶段一系列任务成功完成，下一个阶段的任务才会执行

如果管道只包含 .pre 或者 .post 阶段，并不会运行。
script除了触发器 job 之外，其他所有的 job 都需要一个 script 关键字
Job keywordsafter_script使用 after_script 定义在每个 job 之后运行的命令组，包括失败的 job。
支持 CI&#x2F;CD 变量。
after_script 实例:
job:  script:    - echo &quot;An example script section.&quot;  after_script:    - echo &quot;Execute this command after the `script` section completes.&quot;

更多细节:在 after_script 中指定的脚本在新的 shell 中执行，与任何 before_script 或者 script 命令分开。因此，它们:

将当前工作目录设置回默认值（根据定义 runner 如何处理 Git 请求的变量）

无法访问 before_script 或者 script 命令所做出的更改，包括:

在 script 脚本中导出的命令别名以及变量

工作树之外的更改（取决于 runner 执行器），比如由 before_script 或者 script 脚本安装的软件。



有一个单独的超时时间，硬编码为 5 分钟

不影响 job 的退出码。如果 script 成功，after_script 超时或者失败，那么 job 以 0 作为退出码（job 成功）。


如果作业超时或被取消，则不执行 after_script 命令。
allow_failure使用 allow_failure 确定作业失败时管道是否应该继续运行。

若要让管道继续运行后续作业，请使用 allow_failure: true。
若要停止管道运行后续作业，请使用 allow_failure: false。

before_script使用 before_script 定义一个命令组，这个命令组应该在每个 job 的 script 命令之前运行，但是在 artifacts 恢复之后。
支持 CI&#x2F;CD 变量。
before_script 的例子:
job:  before_script:    - echo &quot;Execute this command before any &#x27;script:&#x27; commands.&quot;  script:    - echo &quot;This command executes after the job&#x27;s &#x27;before_script&#x27; commands.&quot;

更多细节:

你在 before_script 中指定的脚本与你在主要的 script 中指定的任何脚本连接在一起。组合起来的脚本在一个 shell 中一起执行。

在顶层而非 default 域使用 before_script，这是不建议的


cache使用 cache 指定要在 job 之间缓存的文件和目录的列表。只能使用本地工作副本中的路径.
cache:pathsimage使用 image 指定 job 运行所在的 Docker 镜像
only/exceptretrytags使用 tags 可以从项目可用的所有 Runner 中选择特定的运行程序
当你注册运行 Runner 时，你可以指定 Runner 的 tags，例如 ruby，postgres，或者 development。要选择并运行一个 job，Runner 必须为作业中列出的每个标记分配一个 runner。
tags 的例子:
job:  tags:    - ruby    - postgres


when使用 when 配置作业运行时的条件。如果未在作业中定义，则默认值为 on_success。
可能的输入:

on_success（默认值）: 只有在早期阶段的所有作业都成功或者具有 allow_failure: true 时才运行。
manual: 只有在手动触发时才运行作业。
always: 不管作业在早期状态如何，都运行作业。也可以在 workflow:rules 中使用。
on_failure: 只有在早期阶段中至少有一个作业失败时才运行该作业。
delayed: 在指定的期限内延迟作业的执行。
never: 不运行此作业。只能在 rules 部分或者 workflow: rules 中使用。

]]></content>
      <tags>
        <tag>CI/CD</tag>
      </tags>
  </entry>
  <entry>
    <title>AES 加密算法</title>
    <url>/2022/07/18/Cryptography/AES-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[AES 加密算法密钥扩展算法

步骤说明：

将密钥 key 按左图的格式，从上到下，从左到右排列，每一列 4 个字节，其中 $k_n$ 表示 1 个字节。

AES 支持密钥长度为 16、24、32 字节，因此可能的列数是 4、6、8


将每一列的 4 字节从上到下拼接成 32 bit，记为 $W_t$



根据密钥长度不同，列数是 4、6、8，因此 $W$ 每一行的长度是 4、6、8


依次求解 $W_t$，$t$ 的范围是 $[4,43]$（因为已经得到 $[0,3]$ 的值），规则如下：若 $t%4&#x3D;0$，则：$$w[t]&#x3D;w[t-4]⊕g(w[t-1])$$否则：$$w[t]&#x3D;w[t-4]⊕w[t-1]；$$

g 函数的流程如下：

将 $W_t$ 循环左移 8 bit（即 1 字节）
对每个字节做 S 盒置换
将每个字节与 32 bit 常量$(RC[t&#x2F;4],0,0,0)$进行异或。


$RC$ 是一个一维数组，其所需长度随着 AES 算法密钥的长度变化，

参考https://www.cnblogs.com/luop/p/4334160.html
]]></content>
      <tags>
        <tag>Cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title>PKI 笔记</title>
    <url>/2022/10/02/Cryptography/PKI-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[参考引用https://www.ssh.com/academy/pki
PKI 在管理加密密钥中的应用对称加密和非对称加密都面临一个重大挑战: 你如何知道你收到的公钥实际上属于你认为它应该属于的人？
即使使用非对称加密，“中间人”的风险依然存在。例如，如果有人截获了 Bob 的公钥，制作了他自己的私钥，然后为 Alice 生成了一个新的公钥，该怎么办？在这种情况下，Alice 会为 Blob 加密i奥西，中间人可以解密消息，改变它们，然后重新加密，Alice 和 Blob 都不会知道。
PKI 通过颁发和管理拥有私钥和公钥的人、设备、应用程序的数字证书来解决这一问题。简而言之，PKI 为密钥分配身份，以便接收者能够准确地验证所有者。这种验证使用户有信心，如果他们发送一个加密的消息给那个人（或者设备），预期的接收者是一个实际会读取消息的人，而不是任何其他可能坐在“中间的人”。

PKI 只是负责帮用户实现安全的公钥交换。至于用户具体要做什么，他并不关心。

数字证书在 PKI 的作用PKI 通过颁发和管理数字证书来管理加密密钥。数字证书也被称为 X.509 证书和 PKI 证书。
不过，你可以参考这些，数字证书具备以下性质:

相当于驾驶执照或护照的电子产品
包含有关个人或实体的信息
由受信任的第三方发行
防篡改
包含可以证明其真实性的信息
可以追踪到发行人
具有过期日期
呈现给某人（某物）以供验证

引入证书颁发机构证书颁发机构（CA）负责创建数字证书，并拥有用于审查收件人和颁发证书的政策、实践和程序。
具体而言，CA 的拥有者及营办商须决定: 

证书接收者的审查方法
颁发的证书类型
证书中包含的参数
安全和操作程序



一旦 CA 做出这些决定，它们必须正式地记录它们的政策。从那里开始，由证书的使用者决定它们希望在来自给定 CA 的证书中放置多少信任。
证书的创建过程如何工作证书的创建过程非常依赖非对称加密，其工作原理如下:

创建私钥，并计算相应的公钥
CA 请求私钥所有者的任何标识属性，并审查该信息
公钥和标识属性被编码到证书签名请求（CSR）中
密钥所有者签署 CSR 以证明拥有该私钥
发出 CA 验证请求并使用 CA 自己的私钥签署证书

任何人都可以使用证书的公共部分，通过确认谁拥有用于签名证书的私钥，来验证证书实际上是由 CA 颁发的。并且，假设他们认为 CA 值得信任，他们可以验证他们发送给证书持有者的任何东西实际上都会发送给预期的接收者，并且使用该证书持有者的私钥签名的任何东西确实是有这个人&#x2F;设备签名的。
这个过程中需要注意的一个重要部分就是，CA 本身有自己的私钥和相应的公钥，这就产生了对 CA 层次结构的需要。
CA 层次结构和根 CA 如何创建信任层由于每个 CA 都有自己的证书，因此可以通过 CA 层次结构创建信任层 —— 在这种层次结构中，CA 为其他 CA 颁发证书。然而，这个过程不是循环的，因为最终会有一个根证书。通常，证书有一个发行者和一个主体作为两个独立方，但是对于根 CA，这两方是相同的，这意味着根 CA 是自签名的。因此，人们必须本能地信任根证书机构，相信任何可以最速到该机构的证书。
根 CA 安全性至关重要所有的一切都使得私钥的安全性对 CA 来说额外重要。私钥落入坏人手中在任何情况下都是不好的，但是对于 CA 来说尤其是毁灭性的，因为这样就会有人以欺诈的方式颁发证书。
确定 PKI CA 层次结构中的最佳层级至少两层层次结构是绝对必要的，因为根 CA 应该有 99.9% 的时间处于离线状态，这对于定期发布证书的下级 CA 来说是一个困难的标准，因为他们需要在线发布新的证书。
构建私有 CA
生成私钥

cd /etc/pki/CAumask 077openssl genrsa -out /etc/pki/CA/private/cakey.pem 4096



自签证书

openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -out /etc/pki/CA/cacert.pem -days 3650



为 CA 提供所需的目录及文件

mkdir  -pv  /etc/pki/CA/&#123;certs,crl,newcerts&#125;touch  /etc/pki/CA/&#123;serial,index.txt&#125;echo  01 &gt; /etc/pki/CA/serial]]></content>
      <tags>
        <tag>Cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title>加密解密笔记</title>
    <url>/2022/07/10/Cryptography/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[加密解密笔记密码技术
原文：或者叫明文，就是被隐藏的文字。
加密法：指隐藏原文的法则。
密文：或者叫伪文，指对原文按照加密法处理过后生成的可公开传递的文字。
密钥：在加密法中起决定性的因素，可能是数字、词汇，也可能是一些字母，或者这些东西的组合。

摘要算法…
]]></content>
      <tags>
        <tag>Cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title>对称加密算法笔记</title>
    <url>/2022/10/02/Cryptography/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[1. 对称加密算法对称加密是指加密和解密使用同一个密钥。对称加密只有一个密钥，作为私钥。具体的算法有：DES、3DES、TDEA、Blowfish、RC5、IDEA。常用的有：DES、AES
优点：计算量小、加密速度快缺点：

不太安全，需要保存好密钥。明文传输密钥，容易出现劫持、窃听。

随着参与者数量增加，密钥数量膨胀，数量为 $\frac {n(n-1)} 2$；同时，因为密钥数量过多，密钥的管理、存储也是一个问题。除非，你们所有人都使用同一个密钥？

不支持数字签名和不可否认性


1.1. ECB 和 CBC
ECB 模式

Electronic Codebook 电码本。将数据按照8个字节一段进行DES加密或解密得到一段段的8个字节的密文或者明文，最后一段不足8个字节（一般补0或者F），按照需求补足8个字节进行计算（并行计算），之后按照顺序将计算所得的数据连在一起即可，各段数据之间互不影响。

CBC 模式

Cipher Block Chaining 密文分组链接模式。
(1) 将数据按照 8 字节分组，得到D1, D2, … , Dn（若数据不是8的整数倍，用指定的PADDING数据补位）(2) 第一组数据 D1 与初始化向量 I 异或后的结果进行 DES 加密得到第一组密文 C1(3) 第二组数据 D2 与第一组的加密结果 C1 异或以后的结果进行 DES 加密，得到第二组密文 C2(4) 之后的数据以此类推，得到Cn(5) 按顺序连为C1C2C3…Cn即为加密结果。
1.2. DES分组密码，以 64 位为分组对数据加密，密钥长度是 56 位。穷举法进行搜索，运算次数为 $2^{56}$ 
代码
PHP

php 7.1 之前加密与解密参考这里
php 7.1 之后加密解密 —— openssl
加密与解密
pkcs7Padding 函数

可能在填充字节的过程中遇到。如果是 pkcs5Padding，固定传入 $size &#x3D; 8 即可
代码参考
&amp;nbsp;

php 7.1 之前加密与解密

如果与 Java 系统对接，建议传入 $key 固定为 8 位，保持与 Java 加解密库兼容。
代码参考
&amp;nbsp;

php 7.1 之后加密解密 —— openssl

代码参考
function openssl_encrypt(	string $data,	string $cipher_algo,	string $passphrase,	int $options = 0,	string $iv = &quot;&quot;, 	&amp;$tag, string $aad = &quot;&quot;, 	int $tag_length = 16): string|false

参数说明：



参数
说明



$data
数据


$options
OPENSSL_NO_PADDING：需要手动填充，否则不对齐返回 falseOPENSSL_RAW_DATA：自动以 pkcs5 填充


&amp;nbsp;

Java 加密解密

Java DESKeySpec 需要密码至少 8 字节，如果超过 8 字节，只取前 8 字节。
代码参考
1.2. AES介绍AES 是一个高级加密标准（Advanced Encryption Standard）。
AES 按加密方式分为：AES-128、AES-192、AES-256
按加密模式分为：ECB、CBC、CTR、CFB、OCF
对称分组密码体制，分组长度 128 位。这种加密算法是美国联邦政府采用的区块加密标准，AES 标准用来代替原先的 DES。
javax.crypto 包下。
加解密功能由 Cipher 组件提供，
在设置 Cipher 类的时候注意点：(1) Cipher 在使用时需以参数方式指定 transformation(2) transformation 格式为 algorithm&#x2F;mode&#x2F;padding，其中 algorithm 为必输项，(3) 缺省的 mode 为 ECB，缺省的 padding 为 PKCS5Padding(4) 在 block 算法与流加密模式组合时，需在 mode 后面指定每次处理的 bit 数，如 DES&#x2F;CFB8&#x2F;NoPadding，如未指定则使用缺省值，SunJCE 缺省值为 64 bits(5) Cipher 有 4 中操作模式：ENCRYPT_MODE(加密)、DECRYPT_MODE(解密)、WRAP_MODE(导出Key)、UNWRAP_MODE(导入Key)，初始化（init）时需要指定某种操作模式
代码参考
PHP 版本

&amp;nbsp;
1.3. Discuzphp 论坛框架 discuz 的加密算法，也兼容过期时间校验。
代码参考
]]></content>
      <tags>
        <tag>Cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title>散列函数笔记</title>
    <url>/2022/10/02/Cryptography/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[摘要算法通过对所有数据提取指纹信息以实现数据签名、数据完整性校验等功能。数据摘要算法也被称为哈希算法或散列算法。
具体摘要算法：
CRC8 CRC16 CRC 32
MD2 MD4 MD5 
SHA1 SHA256  SHA384  SHA512，SHA（Secure Hash Algorithm）是由美国专门制定密码算法的标准机构——美国国家标准技术研究院制定。
RIPEMD、PANAMA、TIGER、ADLER32 
bcrypt$2b$[cost]$[22 character salt][31 character hash]

$2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy\__/\/ \____________________/\_____________________________/ Alg Cost      Salt                        Hash
$2a$ hash算法的唯一标志
10 代价因子，这里是 2 的 10 次方，
N9qo8uLOickgx2ZMRZoMye  16 字节的 salt经过 base64 编码得到的 22 长度字符
IjZAgcfl7p92ldGxad68LJZdL17lhWy 是 24 个字节的 hash，经过 base64 编码的 31 长度字符
]]></content>
      <tags>
        <tag>Cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title>非对称加密算法笔记</title>
    <url>/2022/10/02/Cryptography/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[非对称加密算法加密和解密用的不是同一个密钥。每个用户拥有 2 把钥匙，公钥和私钥。顾名思义，公钥，是可以对外发布的，私钥是自己保存，只有自己知道的。
优点：

安全。经过历史考证。
公钥本身就是需要公开的，在交换的时候无需担心劫持问题。
需要托管的密钥数量与参与者数量相同。
交换公钥之前不需要预先简历某种信任关系。
支持数字签名和不可否认性。

缺点:

加密速度慢
密文长


通常速度上只能接受加密一些比较短的数据，比如小于 512 bit 的数据。

应用信息加密和解密 用 A 用户的公钥加密后只能用 A 用户的私钥解密。B 需要告诉 A：请来 X 区域找我。B 使用 A 的公钥进行加密，将密文发送给 A，其他人拿到密文没有 A 私钥是无法知道内容的，只有 A 拿到密文之后使用私钥解密才行。
加签和解签 公钥是用来解密信息的，确保别人知道这条消息是由我发布的，且是完整的。
A 用户通过私钥加密：我是 A，我收到了你的信息。此时，B 通过 A 的公钥解密，确认 A 已经收到了自己的消息。

公钥加密，私钥解密称为加密；私钥加密，公钥解密称为签名

密钥管理的问题在使用任何基于 RSA 服务之前，一个实体需要真实可靠的获取其他实体的公钥。

通过非信任的通道，公钥交换必须安全
在密钥交换的过程中，公钥必须不能被截获、修改
交换呈现 Full Mesh 的复杂度
由最终用户离开确认密钥有效性，非常不靠谱

生成 RSA 密钥对
openssl 命令
# 1024 密钥长度openssl genrsa -out key.pem 1024



参数
说明



-out
指定生成文件，包含公钥和私钥



Java 代码生成
int keySize = 1028;KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;);keyPairGenerator.initialize(keySize);KeyPair keyPair = keyPairGenerator.generateKeyPair();Cipher cipher = Cipher.getInstance(&quot;RSA&quot;);cipher.init(Cipher.ENCRYPT_MODE, keyPair.getPublic());

PHP 代码生成
$opensslConfigPath = &#x27;D:\wampserver\bin\apache\apache2.4.46\conf\openssl.cnf&#x27;;$config = array(    &#x27;digest_alg&#x27; =&gt; &#x27;sha512&#x27;,    &#x27;private_key_bits&#x27; =&gt; 1024,    &#x27;private_key_type&#x27; =&gt; OPENSSL_KEYTYPE_RSA,    &#x27;config&#x27;=&gt; $opensslConfigPath);$res = openssl_pkey_new($config); //创建密钥对openssl_pkey_export($res, $privkey, null, $config); //生成私钥$pubKey = openssl_pkey_get_details($res)[&#x27;key&#x27;]; //生成公钥print_r($privkey);print_r($pubKey);

RSA 加密与解密Java
Java 公钥加密
BigInteger modulus = new BigInteger(&quot;&quot;, 16);BigInteger pubExp = new BigInteger(&quot;&quot;, 16);KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);RSAPublicKeySpec pubKeySpec = new RSAPublicKeySpec(modulus, pubExp);RSAPublicKey key = (RSAPublicKey) keyFactory.generatePublic(pubKeySpec);Cipher cipher = Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;);cipher.init(Cipher.ENCRYPT_MODE, key);byte[] cipherData = cipher.doFinal(&quot;密文&quot;.getBytes());

Java 私钥解密
byte[] encrypted = &quot;&quot;; // 密文，需要 base64 解码PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(Base64.getDecoder().decode(&quot;非 PEM 格式私钥&quot;));KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);RSAPrivateKey privateKey = (RSAPrivateKey) keyFactory.generatePrivate(keySpec);Cipher cipher = Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;);cipher.init(Cipher.DECRYPT_MODE, privateKey);byte[] decrptyed = cipher.doFinal(encrypted);System.out.println(new String(decrptyed));

JavaScript
公钥加密

使用 JSEncrypt 库
import &#123; JSEncrypt &#125; from &#x27;jsencrypt/lib/JSEncrypt&#x27;
const publicKey = &#x27;&#x27; // PEM 格式公钥const origin = &#x27;&#x27; // 需要加密的数据const jsEncrypt = new JSEncrypt()jsEncrypt.setPublicKey(publicKey)const encrypted = jsEncrypt.encrypt(origin) // 返回的是 base64 编码的结果


私钥解密const privateKey = &#x27;&#x27; //const encrypted = &#x27;&#x27; // 传递 base64 编码的加密值const jsEncrypt = new JSEncrypt()jsEncrypt.setPrivateKey(privateKey)const decrypted = jsEncrypt.decrypt(msg)

PHP
解密$encrypted = &#x27;&#x27;; // 密文，如果有必要需要进行 base64 解码$decrypted = &#x27;&#x27;; // 解密之后存放的变量$private_key = &#x27;&#x27;; // PEM 格式私钥openssl_private_decrypt($password, $decrypted, $private_key);

]]></content>
      <tags>
        <tag>Cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title>Eclipse 常用快捷键汇总</title>
    <url>/2022/11/22/IDE/Eclipse-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[Alt + Shift + S展示资源快捷菜单
使用场景: 

生成 Getter Setter

其他:

该快捷键可能与企业微信的“显示主界面”冲突

跳转到 super 方法点击方法前面的箭头
]]></content>
  </entry>
  <entry>
    <title>IDEA 中 Eclipse Keymap 汇总</title>
    <url>/2022/10/20/IDE/IDEA-%E4%B8%AD-Eclipse-Keymap-%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[Code


快捷键
含义



Ctrl + Shift + F
Reformat Code 格式化代码


Ctrl + Shift + O
Optimize Imports 优化导入，可以去除没有使用的导入


索引


快捷键
含义



Ctrl + O
查看当前类的字段和方法。再按一次 o，显示父类


]]></content>
  </entry>
  <entry>
    <title>Spring Boot Developer Tools</title>
    <url>/2022/10/09/IDE/Spring-Boot-Developer-Tools/</url>
    <content><![CDATA[参考引用关于新版本 2021 compiler.automake.allow.when.app.running 自动构建选项消失，如何热部署 Spring Boot
https://youtrack.jetbrains.com/issue/IDEA-274903
https://blog.csdn.net/qq_19007335/article/details/124069635
Spring Boot dev tools 使用https://www.cnblogs.com/farajmujey/p/14344148.html
Developer Tools依赖&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;

默认属性参考 DevToolsPropertyDefaultsPostProcessor.java
如果你需要禁用 devtools 提供的默认属性，请设置 spring.devtools.add-properties=false
原理devtools 会监视 classpath 下面的资源，当 classpath 下的文件发生了变化，devtools 会重启服务。

由于 IDEA 保存并不会同步到运行时编译目录，因此需要手动构建。Eclipse 则不必。

devtools 具有独立类加载器。
IDEA 的使用由于 IDEA 在保存源码的时候并不会像 Eclipse 那样立即同步到编译输出目录，因此需要设置 On &#39;Update&#39; action 选项:



比如，选择 Update resources，那么你修改 resources 文件，IDEA 就会同步改动到 target；选择 Update classes and resources，那么你修改 java 文件和 resources 文件就会同步到 target。

不过，默认情况下，IDEA 并不会允许运行时重新构建编译输出目录，因此你需要手动开启:



上图使用的是 2022.2.2 UE 版本，旧版本可能有所区别，比如要从 Registry… 中开启。

]]></content>
  </entry>
  <entry>
    <title>JVM 垃圾回收笔记</title>
    <url>/2022/07/20/JVM/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[JVM 垃圾回收笔记参考文章JVM 规范
https://blogs.oracle.com/jonthecollector/our-collectors
关于 minor gc 和 full gc 的名词，从该文章可以获取
Java Hotspot 内存管理白皮书
GC 算法标记-清除算法(Mark Sweep)Mark-Sweep 算法，在 1960 年由 Lisp 之父 John McCarthy 所提出。分为 “标记” 和 “清除” 两个阶段：

标记：标记出所有需要回收的对象，或者标记存活的对象
清除：标记完成后统一回收需要回收的对象

不足之处主要有两点：

效率问题：执行效率不稳定，如果堆中包含大量对象，且其中大部分对象都需要被回收，这时必须进行大量标记和清除动作。
空间问题：内存碎片

标记-复制算法(Copying)常被简称为 “复制算法”。为了解决标记-清除算法面对大量可回收对象时执行效率低的问题。1969 年 Fenichel 提出一种称为 “半区复制”（Semispace Copying）垃圾回收算法，将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，再把已使用过的内存空间一次清理掉。

如果内存中的多数对象都是存活的，这种算法会产生大量的复制开销。但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是有序复制到另一块内存，分配内存时也就不用考虑空间碎片的情况。

经过研究，大部分新生代的对象是 “朝生夕死” 的，也就是只有极少的的对象会存活下来。在 1989 年，Andrew Appel 针对这个特点，提出了一种更优化的半区复制分代策略，现在称为 “Appel 式回收”。HotSpot VM 的 Serial、ParNew 等新生代回收器均采用了这种策略来设计新生代的内存布局。Appel 式回收的具体做法时把新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中一块 Servivor。发生 GC 时，将 Eden 和 Servivor 中仍然存活的对象一次性复制到另外一块 Servivor 空间上，然后清理掉 Eden 和已经使用过的那块 Survivor 空间。
HotSpot VM 将新生代划分为 Eden 和 2 个 Survivor Space，Eden 和 Survivor 的比例为 8:1，也就是新生代中可用内存为总容量的 90% （80% + 10%），只有 10% 会被浪费。

考虑到最极端的情况，90% 的对象都是存活的，显然 10% 的 Survivor Space 不够用，需要依赖其他内存（老年代）进行分配担保，多出来的对象直接通过分配担保机制进入老年代。

标记-压缩算法(Mark Compact)有些地方也叫标记-整理算法。
复制算法在对象存活率较高时，就要进行较多的复制，效率就会变低。所以，老年代一般不能直接选用这种算法。
根据老年代的特点，1974 年 Edward Lueders 提出了另外一种有针对性的 “标记-整理”（Mark-Compact）算法。标记过程与 “标记-清除” 算法一样，但后续不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
对象存活的判定引用计数法(Reference Count)对象持有一个引用计数器，每当有一个地方引用它时，值加1；引用失效时，值减 1。当计数器值为 0 时，对象就是不可能再被使用。
主流 JVM 都没有选用引用计数法，最主要原因是难以解决对象之间循环引用的问题。
可达性分析算法(Root Searching)基本思想：通过一系列称为 ”GC Roots“ 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用恋，当一个对象到 GC Roots 没有任何引用链相连，则此对象时不可用的。
在 Java 中，可以当做 GC roots 的对象有以下几种：

栈帧中的本地变量表中引用的对象
方法区中的静态属性引用的对象
方法区中的常量引用的对象
本地方法栈中 JNI（一般说的Native方法）引用的对象

finalize()即使在可达性分析算法中不可达的对象，也不是非死不可。认为一个对象死亡，至少要经历两次标记过程：如果在可达性分析后发现没有与 GC Roots 相连的引用链，那么会第一次标记并筛选，筛选的条件时此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为 “没有必要执行”。
如果对象被判定有必要执行 finalize() 方法，那么这个对象将会放置在一个叫 F-Queue 的队列之中，并在稍后由 Finalizer 线程去执行。但是这里，虚拟机只是会触发这个方法并不承诺会等待它运行结束，这样做的原因是，如果一个对象在 finalize() 方法中执行缓慢，或者发生死循环，可能导致 F-Queue 队列中其他对象永久等待。

任何一个对象的 finalize() 方法都只会被系统自动调用一次

建议：尽量避免使用 finalize()，因为它不是 C&#x2F;C++ 中的析构函数，而是 Java 刚诞生时为了使 C&#x2F;C++ 程序员更容易接受它所做出的妥协。有些教材中描述它适合做 “关闭外部资源” 之类的工作，完全是对该方法用途的自我安慰。finalize() 能做的所有工作，使用 try-finally 或者其他方式都可以做的更好、更及时。所以建议忘掉该方法的存在。
三色标记将遍历对象图的过程中，对象分为三种颜色：

白色：表示对象尚未被垃圾回收器访问过。显然，在可达性分析刚开始的时候，所有对象都是白色的，若在分析结束的阶段，对象仍然是白色，表示不可达（垃圾）。
灰色：表示对象已经被垃圾回收器访问过，但这个对象上至少存在一个引用还没有被扫描过。灰色可能直接引用着白色对象。
黑色：表示对象以及它的所有引用都已经扫描过。黑色的对象代表存活的。如果有其他对象引用了黑色对象，也无需重新扫描一遍。黑色对象不可能 “直接” 指向某个白色对象。

可达性分析的并发GC Roots 相比起整个 Java 堆中的全部对象还算极少数，且在各种优化技巧（如 OopMap）的加持下，它带来的停顿已经是非常短暂且相对固定。但是，从 GC Roots 再继续往下遍历对象图，这个过程的停顿时间必定与 Java 堆容量成正比例关系。如果能够削减这部分停顿时间，收益将会是系统性的。
如果用户线程和回收器并发工作，用户线程也在修改引用关系，可能出现两种后果：

把原本死亡的对象错误标记为存活。这不是好事，但可以容忍，不过是产生了浮动垃圾。
把原本存活的对象标记为死亡。这样后果非常致命，出现 “对象消失” 问题，程序肯定会出错。

对象消失：1994 年，Wilson 在理论上证明了，当且仅当下面两个条件同时满足，才会产生 “对象消失” 的问题：

用户线程插入了一条或多条从黑色对象到白色对象的新引用
用户线程删除了全部从灰色对象到该白色对象的直接或间接引用

为了避免对象消失的现象，只需要破坏这两个条件任意一个即可。由此产生了两种解决方案：增量更新（Incremental Update）和原始快照（Snapshot At The Beginning，STAB）。
增量更新是破坏第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象以跟，重新扫描一次。可以理解为，黑色对象一旦新插入了指向白色对象的引用关系之后，它就变成灰色对象了。
原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再以这些记录过的引用关系中的灰色对象为根，重新扫描一次。

虚拟机针对以上的记录操作都是通过写屏障实现的。在 HotSpot VM 中，CMS 时基于增量更新来做并发标记的，G1 是用原始快照来实现的。

垃圾收集器（G1）堆布局G1 将堆划分为一组大小相等的堆 Region（区域），每个区域都是连续的虚拟机内存范围，如下图所示。区域是内存分配和回收的单位。




用户可以随意设置 Region 的大小，但是内部会将用户的值向上调整为 2 的指数幂（$2^{n}$）；设置 G1 堆区域大小：-XX:G1HeapRegionSize=n，默认 n &#x3D; 2M，可选值 1M、2M、4M、8M、16M、32M
空闲区域是通过链表管理的


显然，在任何给定时间，每个区域可以是空的（灰色），或者年轻代，或者老年代。
年轻代区域可以再细分为两类：创建区域、存活区域。

创建区域：用来存放刚刚生成、一次也没有被转移过的对象。可以认为是 Eden。
存活区域：用来存放被转移过至少一次的对象。可以认为是 Survivor Space。

老年代区域可以再细分为两类：普通老年代、Humongous 区域

普通老年代：用来存放年轻达到阈值的对象
Humongous 区域：用来存放巨大对象

当内存请求到来时，内存管理器会拿出空闲区域，将它们分配给某个代。

未必就直接分配给年轻代（创建区域），如果对象过大，则直接分配给老年代（Humongous 区域）。

在年轻代没有达到最大空间前，G1 GC 会根据 Java 应用对象分配速率，从空闲空间里面挑选出区域加入年轻代。当 Eden 区间分配内存失败，一次年轻代 GC 就被触发，它的工作是释放一些内存，属于一次轻量级操作。
随着年轻代回收，大对象分配等操作方式，越来越多的对象从年轻代进入到了老年代，年轻区域和老年区域可以同时被垃圾回收。这称为 mixed collection（混合回收）。
垃圾回收是一种压缩回收，它将存活对象拷贝到选定的、最初为空的区域。

跟 CMS 回收器不同，G1 对老年代的回收是压缩回收。

根据幸存对象的年龄，可以将对象复制到幸存区域（标记为 “S”）或者老年区域（图上暂未具体显示）。标有 “H” 的区域包含大于半个区域并经过特殊处理的巨大对象。


与传统的连续堆内存不同，G1 的内存布局以 Region 进行划分。
“H” 区域存储那些大小 &gt;&#x3D; 0.5 倍 Region 的大型对象。


标记位图每个区域都带有两个标记位图：next 和 prev。”位” 即 bit。

next：本次标记的标记位图
prev：上次标记的标记位图，保存了上次标记的结果。




标记位图中每个 bit 都对应着关联区域内的对象的开头部分。


之所以是开头部分，是因为一个对象如果占用多个 bit 位置，那么只标记它的起始 bit。
黑色的地方表示比特值为 1（存活对象），白色的地方表示比特值是 0（带 “X” 的死亡对象）。


标记位图中 4 个指针的含义：

bottom：众多对象的末尾。
top：众多对象的开头。
nextTAMS：next Top At Marking Start，标记开始时的 top，每次并发标记开始时会移动到与 top 相同的位置，下面会细说。
prevTAMS：prev Top At Marking Start，上次标记开始时 top。


每 8 个字节对应标记位图中的 1 个比特。所以，上图中对象 C 虽然占用多个位置，但是 next 位图只记录了对象头所在的位置。

垃圾回收周期G1 回收器在两个阶段之间交替。在 young-only 阶段包含垃圾回收，即逐渐用老年代中的对象填充当前可用内存。在 space-reclamation 阶段，G1 除了处理年轻代之外，还逐步回收老年代的空间。然后，周期从 young-only 重新开始。

Young-only 阶段：这个阶段从一些 young-only 集合开始，将对象晋升到老年代。当老年代占用达到某个阈值（即初始堆占用阈值）时，将会从 young-only 阶段过渡到 space-reclamation 阶段。此时，G1 调度 initial mark（初始标记） young-only 集合，而不是一个常规的 young-only 收集了。

Initial Mark：除了执行一个常规的 young-only 回收之外，这种回收还开始标记过程。并发标记确定所有当前老年代区域可达的存活对象，以便保留给接下来的 space-reclamation 阶段。当标记还没完全结束的时候，可能发生常规的年轻回收。标记结束之后，随之而来的是两个 stop-the-world 阶段：Remark 和 Cleanup。
Remark：此暂停完成标记本身，并执行全局引用处理和类卸载。在 Remark 和 Cleanup 之间 G1 会并发地计算一个存活信息的摘要，该摘要确定之后会在 Cleanup 暂停中使用来更新内部数据结构。
Cleanup：此暂停还会回收完全空的区域，并确定是否 space-reclamation 阶段会真的到来。如果接下来是 space-reclamation 阶段，young-only 阶段以单个 young-only 回收完成。


Space-reclamation 阶段：这个阶段由多个 mixed collections 组成，除了年轻代区域外，还转移老年代区域的存活对象。当 G1 确定回收更多的老年代区域不会产生足够的可用空间时，space-reclamation 阶段结束。


在 space-reclamation 之后，回收周期从另一个 young-only 阶段重新开始。作为后备，如果应用程序在收集存活信息时内存不足，G1 会像其他回收器一样执行就地的 STW 全堆压缩（Full GC）。
G1 总体执行过程G1GC 主要有以下两个功能：

并发标记（concurrent marking）
转移（evacuation），也有人叫疏散

并发标记：基本能和 mutator 并发执行，会针对区域内所有存活的对象进行标记。
转移：选择区域，如果该区域有存活对象，则将它们复制到其他空闲区域中。对象复制完成之后，只剩下死亡对象的区域会被重置（回收）为空闲区域以便复用。

并发标记和转移在处理上是相互独立的。并发标记的结果信息对转移来说并不是必须的。因此，转移处理可能发生在并发标记开始之前，也可能发生在并发标记的过程中。

并发标记并发标记包括以下 5 个步骤：
① 初始标记阶段② 并发标记阶段③ 最终标记阶段④ 存活对象计数⑤ 收尾工作
步骤 ① 初始标记阶段该阶段有两个过程：

创建标记位图：与 mutator 并发执行
根扫描：标记可由根 “直接引用” 的对象。



在初始标记阶段，GC 线程首先会创建标记位图 next。指针 nextTAMS 指向标记开始时 top 所在的位置。在创建位图时，其大小也和 top 对齐，为 (top - bottom) &#x2F; 8 字节。

上述处理都是和 mutator 并发进行的。

等所有区域的标记位图都创建完成之后，就可以开始进行根扫描了。

根扫描，指可由根 “直接引用” 的对象进行标记的过程。

为了防止在根扫描的过程中根被修改，在这个过程中 mutator 是暂停执行的。

虽然 G1GC 采用的写屏障可以获知对象的修改，但是大多数根不是对象。而且，根需要频繁的修改，与其频繁地通过写屏障去获取修改，不如直接暂停 mutator 进行根扫描性能更好。

如果一个对象本身被标记了，但其子对象并没有被扫描，称它为未扫描对象（灰色）。上图中，对象 C 已经在根扫描中被标记，但由于根扫描不会扫描子对象，对象 C 又持有对象 A 和 E 的引用，所以对象 C 被认为是未扫描对象，表示为灰色。
完成根扫描后，mutator 会再次开启执行。
步骤 ② 并发标记阶段在并发标记阶段，GC 线程继续扫描在初始标记阶段被标记过的对象（根直接引用对象），完成堆大部分存活对象的标记。
下图表示并发标记阶段结束后的区域状态。对象 C 和子对象 A 和 E 都被标记了。



并发标记阶段地一个重要特点是 GC 线程和 mutator 是并发执行的。因此，mutator 在执行的过程中可会会改变对象之间的引用关系，所以，采用一般的标记方法，可能会发生 “标记遗漏”。因此，必须使用写屏障技术来记录对象间引用关系的变化。
SATBSATB（Snapshot At The Beginning，初始快照）是一种将并发标记阶段开始时对象间的引用关系，以逻辑快照的形式进行保存的手段。
在 SATB 中，标记过程中新生成的对象会被看作 “已完成扫描和标记”，因此其子对象不会被标记。


因为 SATB 记录的是并发标记阶段开始时的对象间引用关系，而标记过程中新生成的对象与其他对象间的引用关系在标记开始时并不存在，因此其子对象不会被标记。
如上图所示，nextTAMS 和 top 之间的对象 J 和 K 就是在标记过程中新生成的对象。因为它们的引用关系在标记开始时并不存在，所以它们都会被当成存活对象。
此外，标记位图也不会记录对象 J 和 K


如果在并发标记的过程中对象的域发生了写操作（被修改），就必须以某种方式记录下被改写之前的引用关系。


参数 field 表示被写入对象的域（类属性），参数 newobj 表示被写入域的值。
第 2 行的 GC_CONCURRENT_MARK 用来表示并发标记阶段的标志位（flag）。
第 4 行会检查当前处于并发标记且被写入之前 field 的域的值是不是 Null，因为如果为 Null，代表之前的引用关系并不存在，无需记录。
第 5 行将 oldobj 添加到 $current_thread.stab_local_queue 中。
第 7 行进行实际的写入操作。
在并发标记阶段，GC 线程会定期检查 SATB 队列集合大小。如果发生其中由队列，则会对队列中的全部对象进行标记和扫描。
SATB 本地队列在装满（默认大小为 1 KB）之后，会被添加到全局的 SATB 队列集合中。这些被添加的 SATB 本地队列，都是并发标记阶段的待标记对象。
步骤 ③ 最终标记阶段最终标记阶段的处理是暂停处理，需要暂停 mutator 的运行。

因为 SATB 本地队列中的数据会被 mutator 操作，所以不能和 mutator 并发执行。

因为未装满的 SATB 本地队列不会被添加到 SATB 队列集合中，所以在并发标记阶段结束后，各个线程 SATB 本地队列中可能仍然存在待扫描的对象。而最终标记阶段就会扫描这些 “残留的 SATB 本地队列”。
队列中保存了对象 G 和 H 的引用。因此在扫描 SATB 本地队列之后，对象 G 和 H，以及对象 H 的子对象都会被标记。本步骤结束后，所有的存活对象都已被标记。因此，此时所有不带标记的对象都可以判定为死亡对象。
步骤 ④ 存活对象计数计数处理和 mutator 是并发执行的。

不过，计数过程中操作的对象可能会被转移的记忆集合线程使用，因此需要先停掉记忆集合线程。

这个步骤会扫描各个区域的标记位图 next，统计区域内存活对象的字节数，然后将其存入 Region 内的 next_marked_bytes 中。


在计数过程中新创建了对象 L 和 M。由于 nextTAMS 和 top 之间的对象都会被当做存活对象来处理，所以不会特意计数。
prev_marked_bytes 存放了上次标记结束时存活对象的字节数。因为该 Region 在此之前未曾进行过标记，因此值为 0。


步骤 ⑤ 收尾工作收尾工作所操作的数据有些是和 mutator 共享的，因此需要暂停 mutator 的运行。
在此期间，GC 线程会逐个扫描每个区域，将标记位图 next 中的并发标记结果移动到标记位图 prev 中，再对并发标记中使用过的标记值进行重置，为下次并发标记做好准备。
此外，对没有存活对象的区域进行回收的工作。可以理解为以区域为单位的清除。
在扫描过程中还会计算每个区域的转移效率，并按照该效率对区域进行降序排序。
收尾工作结束后的几个状态变化：

next.next_marked_bytes 中的值被转移到 prev.prev_marked_bytes
prevTAMS 被移动到 nextTAMS 之前的位置
next.next_marked_bytes 被重置
nextTAMS 移动到 bottom 的位置，nextTAMS 会在下次并发标记开始时，移动到 top 的最新位置

收尾工作结束后，整个并发标记结束。并发标记线程一直处于等待状态，直到下次并发标记开始。
总结并发标记结束后，转移处理可以得到以下信息
① 并发标记完成时存活对象和死亡对象的区分（标记位图 prev）
② 存活对象的字节数（prev_marked_bytes）
这些信息在并发标记阶段不会被改变，因此，即使并发标记阶段开始了，进行转移处理也没有问题。
转移通过转移，所选区域内的所有存活对象都会被转移到空闲区域。这样一来，被转移区域就只剩下死亡对象。重置之后，该区域就会称为空闲区域，能够再次利用。
下图表示了转移开始前后的状态。转移结束后，可从 GC Root 到达的存活对象 a、b、c 会被转移到空闲区域 C，而死亡对象 d、e 不会被转移，整个区域 A、B 会被重置以再次利用。


转移专用记忆集合除了可以从根和并发标记的结果发现存活对象之外，转移功能还可以通过转移专用记忆集合来发现对象。转移专用记忆集合用来记录区域之间的引用关系。

对比：SATB 队列集合主要用来标记过程中对象之间引用关系的变化

为了简化表达，下面可能会使用 Remember Set（或者 RSet）表示转移专用记忆集合




每个区域都有自己的 RSet，RSet 中记录了来自其他区域的引用，无需扫描所有区域内的对象，就可以确定待转移对象所在区域内的对象被其他区域引用的对象，从而简化单个区域的转移处理。
G1GC 是通过卡表（Card Table）来实现转移专用记忆集合的。


卡表卡表是一个字节数组，如下图。卡表里的元素称为卡片。堆中一定大小的存储空间（卡页）会对应卡表中的一个元素（字节 &#x2F; 卡片）。
堆中的对象所对应的卡片在卡表中的索引值可以通过以下公式快速计算出：
（对象的地址 - 堆的头部地址）/ 512




一般来说，卡页的大小都是 2 的 N 次幂。HotSpot 的卡页大小为 2 的 9 次幂，即 512 字节。因此，如果堆大小为 1 GB 时，那么被分为 2 M 个卡页，卡表的数组长度为 2 M，大小为 2 MB。

转移专用记忆集合的构造


RSet 是通过散列表实现的，可以理解为 Java 的 Map，key 是区域的地址，值是卡片索引的数组。图中对象 b 引用了对象 a，因此对象 b 对应卡片的索引（2048）就被记录在区域 A 的转移专用记忆集合中。

转移专用写屏障当对象的域被修改时，被修改对象所对应的卡片会被转移专用写屏障记录到 RSet 中。
每个 mutator 线程都持有一个名为转移专用记忆集合日志的缓冲区，其中存放的是卡片索引的数组。当对象 b 的域被修改时，写屏障就会感知，并会将对象 b 所对应的卡片索引添加到转移专用记忆集合日志中。当转移专用记忆集合日志写满之后，它会被添加到转移专用集合日志的集合（可以认为是 Set&lt;转移专用集合日志&gt;）中。
转移总体步骤① 选择回收集合：参考并发标记提供的信息来选择被转移的区域。被选中的区域称为回收集合（Collection Set）。
② 根转移：将回收集合内由根直接引用的对象，以及被其他区域引用的对象转移到空闲区域。
③ 转移：以 ② 中转移的对象为起点，扫描其子孙对象，将所有存活对象一并转移。
当 ③ 结束之后，回收集合内的所有存活对象就转移完成了。
这 3 个步骤都是暂停处理的。在转移开始后，即使并发标记正在进行也会先中断，而有限进行转义处理。
另外，② 和 ③ 都是可以多线程并行执行的。
步骤 ① 选择回收集合选择回收集合的标准简单来说有 2 个：

转移效率高
转移的预测暂停时间在用户的容忍范围内

在选择回收集合时，堆中的区域按照转移效率降序排列。接下来，按照排好的顺序依次计算各个区域的预测暂停时间，并选择回收集合。当所有已选区域预测暂停时间的总和快要超过用户的容忍范围时，后续选择就会停止。
步骤 ② 根转移根转移的转移对象包含以下 3 类：

GC Root 直接引用对象
并发标记处理中的对象
由其他区域对象直接引用的回收集合内的对象

根转移伪代码：



代码清单第 2 ~ 4 行先是把被根引用的位于回收集合内的对象转移到其他的空闲区域。

被根引用却不在回收集合内的对象会被直接忽略。$roots 中还包含 SATB 本地队列和 SATB 队列集合中的引用

第 4 行的 evacuate_obj() 是用于转移对象的函数，它的返回值是转移后对象的地址。
第 6 行中的 force_update_rs() 的作用是将未被转移专用记忆集合维护线程扫描的脏卡片更新到转移专用记忆集合中。
对象转移

① 将对象 a 转移到空闲区域② 将对象 a 在空闲区域中的新地址写入到转移前所在区域中的旧地址。③ 将对象 a 引用的所有位于回收集合内的对象都添加到转移队列中。转移队列是用来临时保存待转移对象的引用放。图中 a’.field1 引用了对象 b，而且 b 所在的区域在回收集合中。因为 a’ 是存活对象，所以 a’ 引用的对象 b 也是存活对象。④ 针对对象 a 引用的位于回收集合外的对象，更新转移专用记忆集合。图中 a’.field2 引用了对象 c，而 c 所在的区域不在回收集合中。c 所在的转移专用记忆集合中虽然记录了 a.field2 对应的卡片，但是 a 被转移到了 a’，所以有必要更新转移专用记忆集合。⑤ 针对对象 a 的引用放，更新转移专用记忆集合。对象转移时只有 1 个引用放能够以参数的形式进行传递。图中 a 的引用方是 d.field1。d.field1 指向的是 a 的地址，但是 a 被转移到 a’，所以有必要让 d.field1 指向 a 的新地址 a’。如图中所示，d.field1 对应的卡片被添加到了 a’ 所在区域的转移专用记忆集合中。⑥ 这一步并非转移的处理内容，只是补充说明。对象转移最终返回额是转移后的地址。在调用转移的地方，返回的地址会被赋值给引用放。图中 d.field1 的地址被替换成了对象 a’ 的地址
步骤 ③ 转移完成根转移之后，那些被转移队列引用的对象会依次转移。直到转移队列被清空，转移就完成。至此，回收集合内所有的存活对象都被成功转移。
Card Tables and Concurrent Phases如果垃圾回收器没有回收整个堆（增量回收），则垃圾回收器需要知道从堆的未回收的部分到正在回收的堆的部分的指针在哪。这通常用于分代垃圾回收器，其中，堆的未回收部分通常是老年代，而堆的回收部分是年轻代。保存这些信息的数据结构（指向年轻代对象的老年代指针）是一个 Remembered Set（记忆集）。Card Table（卡表）是一种特殊类型的记忆集。Java HotSpot VM 使用字节数组作为卡表。每个字节称为一张卡。一张卡对应于堆中的一系列地址。Dirtying a card（脏卡）意思是将字节的值更改为一个 dirty value（脏值）。一个脏值可能包含一个从老年代到年轻代，卡所覆盖地址的指针。
Processing a card 意味着检查卡片，看看是否有一个老年代到年轻代的指针，并且可能对这些信息做一些事情，比如将其转移到另一个数据结构。
热卡片频繁发生修改的存储空间所对应的卡片称为热卡片（hot card）。热卡片可能会多次被转移专用记忆集合线程处理成脏卡片，从而加重转移专用记忆集合线程的负担，因此需要特别处理。
要想发现热卡片，需要用到卡片计数器，它记录了卡片变成脏卡片的次数。卡片计数器记录了自上次转移以来哪些卡片变成了脏卡片，以及变成脏卡片的次数，其内容会在下次转移时被清空。
变成脏卡片的次数超过阈值（默认是 4）的卡片会被当成热卡片，在被处理为脏卡片后添加到热队列尾部。热队列的大小是固定的（默认是 1 KB）。如果队列满了，则从队列头部取出老卡片，给新的卡片腾出位置。取出的卡片由转移专用记忆集合维护线程当成普通卡片处理。
热队列的卡片不会被转移专用记忆集合维护线程处理，因为即使处理了，它也有可能马上又变成脏卡片。因此，热队列中的卡片会被留到转移的时候再处理。
分代 G1GC 模式G1GC 中存在 “纯 G1GC 模式”（pure garbage-first mode）和 “分代 G1GC 模式”（generational garbage-first mode） 两种模式。实际上，OpenJDK 虽然实现了纯 G1GC 模式，但是并没有将这种模式开放给用户。用户们使用的都是分代 G1GC 模式。
分代 G1GC 模式也分为新生代 GC 和老年代 GC。G1GC 中的新生代 GC 称为完全新生代 GC（fully-young collection），老年代 GC 称为部分新生代 GC（partially-young collection）。
完全新生代 GC 和部分新生代 GC 的主要区别在于回收集合的选择：

完全新生代 GC 将所有新生代区域选入回收集合
部分新生代 GC 将所有新生代区域，以及一部分老年代区域选入回收集合


注意：所有新生代区域都会被选入回收集合

完全新生代 GC 的执行过程完全新生代 GC 不会选择老年代区域，而是将所有新生代区域（创建区域、存活区域）都选入回收集合，然后转移回收集合内的存活对象。晋升的对象会被转移到老年代，其余对象则被转移到存活区域。


完全新生代 GC 的执行过程

部分新生代 GC 则是除了所有新生代区域外，还会选择一部分老年代区域进入回收集合。除了回收集合的选择方式，部分新生代 GC 和完全新生代 GC 的执行过程是一样的。


部分新生代 GC 的执行过程


Allocation Evacuation Failure与 CMS 一样，G1 与应用程序并发执行，并且存在应用程序分配对象的速度比垃圾回收器恢复可用空间速度快的风险。

这种会导致回收过程中反而内存扩大

在 G1 中，Java 堆耗尽的问题可能发生在 G1 将存活数据从一个区域复制到另一个区域的过程中。如果在垃圾回收区域的疏散期间无法找到闲置的区域，则会发生分配失败，并且将会执行一个 stop-the-world 的 full collection。
浮动垃圾对象可能会在 G1 回收期间死亡，且不会被回收。G1 使用一种称为 snapshot-at-the-beginning (SATB) 的技术来保证垃圾回收器找到所有存活对象。SATB 声明任何在并发标记（整个堆上的标记）开始的时候处于存活状态的对象都被认为是存活的，以便回收。SATB 允许浮动垃圾，以类似于 CMS 增量更新的方式。
PausesG1 暂停应用程序以将活动对象复制到新区域。这些暂停可以是仅回收年轻区域的年轻回收暂停，也可以是疏散年轻和老年区域的混合回收暂停。与 CMS 一样，当应用程序停止时，有一个最终标记或注释暂停来完成标记。CMS 也有初始标记暂停，而 G1 将初始标记工作作为疏散暂停的一部分。G1 在回收结束时有一个清理阶段，它是部分 STW，部分并发的。清理阶段的 STW 部分识别空区域，并确定作为下一次回收候选的老年区域。
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java HotSpot VM 笔记</title>
    <url>/2022/07/20/JVM/Java-HotSpot-VM-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[即时编译器目前主流的两款商用 Java VM （HotSpot、OpenJ9）里，Java 程序最初都是通过解释器（Interperter）进行解释的。当 VM 发现某个方法或者代码块的运行特别频繁，就会把这些代码认定为 “热点代码”（Hot Spot Code），为了提到热点代码的执行效率，在运行时，VM 会将这些代码编译成本地机器码，并以各种手段尽可能地进行代码优化，运行时完成这个任务的后端编译器被称为即时编译器。
HotSpot 分代针对 J2SE 5.0 HotSpot JVM：
Java HotSpot 虚拟机的内存被分为三代：young generation（年轻代）、old generation（老年代）、permanent generation（永久代）。大多数对象一开始的时候都是分配在年轻代。老年代的对象是那些已经在年轻代经历了几次回收且存货下来的对象，以及一些可以直接分配在老年代的大型对象。永久代存储描述类和方法的对象，以及类和方法本身。
年轻代包含一个叫 Eden 的区域，以及 2 个较小的 Survivor Spaces。大多数对象一开始都是被分配在 Eden。（之所以用”大多数”，因为少部分大型对象可能直接被分配在老年代）。Survivor Spaces 存放那些至少活过 1 次年轻代的回收，被给予了更多死亡的机会，但是依然存活下来，足够老，可以”晋升”到老年代。在任何给定的时刻，Survivor Spaces 中只有 1 个持有对象，另一个Survivor Space 是空的，且保留不使用，直到下一次回收，循环使用。

每次回收，将会交换幸存者空间的使用。

当年轻代满了的时候，年轻代会执行垃圾回收（有时候也叫 minor collection）。当老年代或者永久代满了，所谓的 full collection 将会执行（有时候也叫 major collection）。也就是说，所有的代都会回收垃圾。通常，年轻代首先被回收，使用特别为它设计的回收算法，因为这种算法通常是在年轻代识别垃圾最高效的算法。如果发生压缩，每个代也都是单独压缩的。
Serial CollectorSerial Collector 可以叫做串行回收器。使用串行回收器，年轻代和老年代都会在 stop-the-world 状态下，串行地进行回收工作（使用单 CPU）。也就是说，当回收工作进行时，应用执行会终止（即停止全部线程）。
使用串行回收器进行年轻代回收下图描述了年轻代使用串行回收器回收的操作。Eden 中存活的对象将拷贝到一开始是空的幸存者空间（即To）。



除了那些太大，To 空间都放不下的对象，这样的对象会直接拷贝到老年代。

在被占用的幸存者空间（即From）中，存活下来的对象，而且相对比较年轻的（经历回收次数不多）会转移到另一个幸存者空间（To）。

相对比较老的（经历回收次数多）对象会拷贝到老年代。


另外注意：如果 To 空间满了，那些来自于 Eden 或者 From 空间的，存活着，但还没有拷贝的对象直接进入老年代，不管它们经历了几次存活。

在存活对象拷贝之后，任何还留在 Eden 或者 From 空间的对象，按定义来说，都不再存活，而且，它们也不必再检查了。

图中标记了 “X” 的对象都是垃圾对象，不过实际上，回收器也不会检查它们，或者标记它们，只是为了展示，一般直接回收掉。

在年轻代回收完毕之后，Eden 和之前被占用的幸存者空间（之前的From）都是空的，仅仅只有之前是空的幸存者空间（之前的To）包含了存活对象。这时候可以说，幸存者空间交换了角色（To 和 From 角色交换，如下图）。


Serial Old 回收器Serial 回收器老年代版本，老年代和永久代通过 “标记-清理-压缩” 回收算法进行回收工作。在标记阶段，回收器识别哪些对象是存活的。清理阶段识别、清理老年代中垃圾。然后，回收器执行移动压缩，将存活的对象移动到老年代的一端（永久代也类似），使剩下的空闲区域形成一个连续的块位于另一端。压缩可以让以后分配到老年代和永久代的操作使用快速的 bump-the-pointer 技术。
串行回收器的使用场景现在，串行回收器并非没有它的价值。对于运行在 Client 模式下的虚拟机，串行回收器是默认的新生代回收器。优势在于：简单高效、没有线程交互开销。
串行回收器的选择在 J2SE 5.0 发行版，在非 server-class 的机器上，默认选择串行回收器。在其他机器，串行回收器需要使用 -XX:+UseSerialGC 命令行选项。
Parallel CollectorParallel Collector 可以叫做并行回收器。
使用并行回收器进行年轻代回收并行回收器使用的是串行回收器进行年轻代回收工作的算法的并行版本。它仍然是一个 stop-the-world 并进行拷贝的回收器，但是，它可以使用多 CPU，并行地执行年轻代的回收工作，减少了垃圾回收的开销，因此可以提高应用吞吐量。下图描述了串行回收器和并行回收器在年轻代工作时的区别。


使用并行回收器进行老年代回收用并行回收器进行老年代垃圾回收工作，将会使用和串行回收器相同的串行 “标记-清理-压缩” 回收算法。
何时使用并行回收器?运行在多处理器的机器上，并且，没有对暂停时间要求不高的应用程序将能从并行回收器获益。

因为有可能发生长时间的老年代回收，尽管比较少见。

比较合适使用并行回收器的应用，例如：批处理、账单服务、支付、科学计算等。
Parallel Compacting CollectorParallel Compacting Collector，可以翻译为并行压缩回收器。
首先在 JDK 5 update 6 中提供， JDK 6 中实现性能显著改进。
参考文档JDK
日志
JDK 6

默认情况不启用并行压缩，如果需要，添加选项 -XX:+UseParallelOldGC 到 Java 命令行。
注意：并行压缩不能与 CMS 回收器一起使用。它只能与年轻代的并行回收器一起使用。
使用 Parallel Compacting Collector 进行年轻代回收对于 Parallel Compacting Collector 进行年轻代垃圾回收工作，会使用与 Parallel Collector 一样的算法。
使用 Parallel Compacting Collector 进行老年代回收使用 Parallel Compacting Collector，老年代和永久代在 stop-the-world 下进行垃圾回收，通常伴随着滑动压缩。

与 Parallel 一样，都需要 stop-the-world

回收器使用三个阶段。(1) 每个代，从逻辑上被划分为固定大小的区（region）。在 marking 阶段，应用程序代码直接可达的存活对象的初始集合在垃圾回收线程被划分，然后并行地标记所有的存活对象。当识别出对象是存活时，对象所在 region 关于对象大小和位置的信息数据被更新。
(2) 汇总阶段是在 region 上操作，而不是对象。由于之前回收的压缩，通常，每个代左边的部分是密集的，包含了大多数存活对象。从这些密集的 region 中回收空间是不值得它们去压缩的。region 到那一点的左边被认为是 dense  prefix，并且没有对象会移动到那些区域。那一点右边的区域会被压缩，消除所有死亡的空间。汇总阶段计算并存储下每个压缩 region 存活数据的第一个字节的新位置。注意：汇总阶段当前以串行实现，并行化是可能的，但是对于执行来说，不如标记和压缩阶段的并行化重要。
(3) 在压缩阶段，垃圾回收线程使用汇总的数据来识别需要填充的 region，并且线程可以独立把数据拷贝进 region。这样就产生了一个一端高密度的堆，另一端是一个巨大的空块。
何时使用 Parallel Compacting Collector与并行回收器一样，并行压缩回收器对于运行在多核 CPU 的机器上的应用程序是有益的。此外，老年代回收的并行操作缩短了暂停时间，并且，对于有暂停时间约束的应用程序，并行压缩回收器比并行回收器更适合。
并行压缩回收器也许不太适合运行在大型的共享机器的应用程序，在这种情况下，单个应用程序不能长时间独自霸占多 CPU。在这样的机器上，要么考虑减少垃圾回收现成的数量（通过 -XX:ParaleelGCThreads=n 命令行选项），要么选择别的回收器。
选择并行压缩回收器如果你想使用并行压缩回收器，你必须指定命令行选项 -XX:+UseParallelOldGC
Concurrent Mark-Sweep (CMS) Collector并发标记清理回收器，可以简称为 CMS。
使用并发标记清理收集器进行老年代收集使用 CMS 进行的老年代清理工作能够与应用程序并发执行。
对于 CMS 来说，1 个收集的周期从一个短暂的停止开始（叫做 initial mark，初始标记），识别出直接可达的存活对象，形成初始集合。然后，在并发标记阶段，收集器标记所有从这些集合中，间接可达的存活对象。因为在标记阶段的时候，应用程序也在运行，更新引用，所以不能保证在并发标记阶段结束的时候，所有存活的对象都能被标记到。

可能存在存活对象在并发阶段被认为是死亡对象，见对象消失。也可能存在浮动垃圾，但是不具有致命影响。

为了解决这个问题，应用程序再一次停止（叫做 remark），通过重访在并发标记阶段被修改的对象最终确定标记。因为 remark 阶段比 initial 标记工作量更大，多线程并行运行可以提高效率。

并发标记阶段必须再次停止用户线程，否则又会产生对象消失的问题。

在 remark 阶段结束的时候，所有堆中存活的对象都能保证被标记，因此，接下来的并发清理阶段会回收所有识别出来的垃圾。


由于一些任务，比如重访 remark 阶段的对象，增加了收集器的工作量，它的开销也相应增加。不过，对于大多数尝试减少停止时间的 GC 来说，这也是一种权衡。
CMS 是仅有的一个不压缩的收集器。也就是说，在释放了死亡对象的空间之后，它不会把存活的对象移动到老年代的一边。


这节约了时间，但是由于空闲空间不是连续的，收集器不再简单地使用一个指针指向下一个对象可分配的空间区域。相反，它现在需要使用空闲列表。也就是说，它会创建一些列表，连接着未分配的区域内存，每次对象需要分配时，基于内存需要，搜索适当的列表，找到足够大能够存储对象的一块区域。结果，分配进入老年代比使用简单的 bump-the-pointer 代价更大。这也会给年轻代的收集工作带来额外的开销，因为大多数老年代的分配工作都是因为对象在年轻代收集阶段晋升到老年代。
另一个 CMS 的缺陷是，需要比其他收集器更多的堆内存。考虑到应用程序可以在并发标记阶段运行，它可以继续分配内存，因此有可能继续增加老年代。另外，虽然 CMS 能够保证，识别在 GC 过程中所有存活的对象，但是一些对象可能在并发标记阶段变成了垃圾，它们得不到清理直到下一次老年代收集工作。这种垃圾叫做 floating garbage（浮动垃圾）。
与其他 GC 不同的是，CMS 不会在老年代满了的时候才开始进行老年代回收工作。相反，它会早一点开始回收工作，以便在老年代满之前完成清理。

因为 CMS 收集期间，老年代仍然可能增长。如果不早一点，CMS 可能会回退到使用并行和串行收集器，进行更费时的 stop-the-world  标记-清理-压缩算法。

为了避免上述可能，CMS 收集器会根据之前的回收时间和老年代占满的时间进行统计，得到合适的时间来提前开始。如果老年代的占用，超过了一个叫 initiating occupancy 的东西，CMS 回收器也会开始回收。

initiating occupancy 的值可以通过命令行选项 -XX:CMSInitiatingOccupancyFraction=n，其中 n 是一个老年代大小的百分数值。默认是 68。

增量模式Incremental Mode，增量模式、增量 GC。通过慢慢地进行 GC 在缩短 mutator 最大暂停时间的一种手段。
CMS 回收器使用一种&#x3D;&#x3D;并发阶段&#x3D;&#x3D;增量进行的模式。这个模式通过阶段性的停止并发阶段来让出 CPU 给应用程序，以减少长并发阶段的影响。回收器的工作被划分成一个一个小块的时间。
当运行在一些处理器比较少的机器上时（比如只有 1 个或 2 个），应用程序又需要并发回收器提供低暂停时间，那么这个特性还是有用的。
什么时候使用 CMS 回收器?如果 (1) 你的应用程序需要更短的垃圾回收暂停时间，(2) 而且，可以承担得起垃圾回收器与应用程序一起共享处理器资源，那么你可以选择 CMS 回收器。

由于并发性，CMS 回收器在回收周期内，会占用应用程序一定的 CPU 周期

通常，应用程序有相对大一点的老年代，并且运行在两个以上的处理器机器上时，更有利于该回收器。例如，Web 服务器。
对于那些需要低暂停时间的应用程序来说，可以考虑 CMS 回收器。对于老年代不太大，又运行在单单处理器上的交互式应用程序来说，CMS 回收器可能也有不错的效果。
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 网络路由</title>
    <url>/2022/10/04/Linux/Linux-%E7%BD%91%E7%BB%9C%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[Linux 路由Linux 上分为三种路由:

主机路由，直接指名到某台具体的主机怎么走，主机路由也叫静态路由
网络路由，指明某类网络怎么走
默认路由，不走主机路由和网络路由的就走默认路由。操作系统上设置的默认路由一般也称为网关

多条路由的匹配规则。在 Linux 中，路由条目的优先级确定方式是先匹配掩码长度，再比较路由开销（metric）。也就是说，掩码位长的路由条路优先级一定比掩码位短的优先级高，所以主机路由的优先级最高，然后是直连网络（同网段）的路由，然后是网络路由，最后是默认路由。若路由条目的掩码长度相同，则比较节点之间的管理距离，管理距离短的生效。
例如下面的路由表，若 ping 192.168.5.20，先比对 192.168.100.78，无法匹配，然后比对网络路由，发现 192.168.0.0 匹配成功，所以选择该路由。
[root@xuexi ~]# route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 192.168.100.2 0.0.0.0         UG    100 0 0 eth0172.16.10.0 0.0.0.0 255.255.255.0   U     100 0 0 eth1192.168.0.0 192.168.100.70 255.255.0.0     UG    0 0 0 eth0192.168.100.0 0.0.0.0 255.255.255.0   U     100 0 0 eth0192.168.100.78 0.0.0.0 255.255.255.255 UH    0 0 0 eth0


由于两块网卡 eth0 和 eth1 都是 192.168.100.0&#x2F;24 网段地址，所以它们的路由条目在掩码长度的匹配上是相同的，但是与 eth0 直连的网段主机通信时，肯定会选择 eth0 这条路由，因为 eth1 与该网段主机距离增加了 1。
[root@xuexi ~]# route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 192.168.100.2 0.0.0.0         UG    100 0 0 eth0192.168.100.0 0.0.0.0 255.255.255.0   U     100 0 0 eth0192.168.100.0 0.0.0.0 255.255.255.0   U     101 0 0 eth1

所有网络设备，无论它们是主机，路由器，还是其他类型的网络节点（例如网络连接的打印机），都需要决定将 TCP&#x2F;IP 数据包路由到何处。
router -n 命令列出路由表；-n 表示仅将结果显示为 IP 地址，并且不尝试执行 DNS 查找，该 DNS 查找将使用主机名 IP（如果可用）
[root@localhost ~]# route -nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface0.0.0.0         10.0.3.2        0.0.0.0         UG    101    0        0 enp0s810.0.3.0        0.0.0.0         255.255.255.0   U     101    0        0 enp0s8192.168.59.0    0.0.0.0         255.255.255.0   U     102    0        0 enp0s3192.168.122.0   0.0.0.0         255.255.255.0   U     0      0        0 virbr0

使用 -n 选型时，默认网关始终与 0.0.0.0 一起显示。默认网关的网络掩码为 0.0.0.0 意味着，无论网络类别如何，路由表中未通过附加目寻址到恩地网络或另一个出战路由器的任何数据包都将发送到默认网关。
route 命令对于Flags列，如果没有安装路由软件，则只可能出现下面的3种值：U (route is up)H (target is a host)G (use gateway，也即是设置了下一跳的路由条目)
]]></content>
  </entry>
  <entry>
    <title>VirtualBox 网络类型整理</title>
    <url>/2022/10/04/Linux/VirtualBox-%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[网络地址转换NAT – Network Address Translation (NAT)虚拟机没有自己独立的 IP
虚拟机不存在于真实的网络中、
虚拟机可以访问主机，但是主机无法访问虚拟机
VirtualBox 中 NAT 又分为: NAT 和 NAT Network
NAT 使用内置的网段, NAT Network 可以自定义网段
NAT 网关地址是 10.0.2.1, NAT Network 的网关地址是 x.x.x.1（自定义网段的第一个非零 IP）

VMWare Station 会添加一个用于 NAT 的适配器，VirtualBox 并不添加 NAT 的适配器，因此 VMWare Station 可以自由设定 NAT 网络的网段，且不需要端口转发就能进行 SSH 连接。

Host-Only 网络模式虚拟机不能连接外网（因此不需要设置网关和 DNS）。宿主机和虚拟机们必须在同一网段才能互联。
网络模式为 Host-Only 时，可以在 File（管理） &gt; Host Network Manager（主机网络管理器） 设置宿主机的 IP 等信息。（也可以直接在 Windows 网络连接的 VirtualBox Host-Only Network 适配器中修改。）
桥接网卡 – Brdged networking虚拟机有独立的 IP，就像处于同一个局域网
]]></content>
  </entry>
  <entry>
    <title>yum 的使用</title>
    <url>/2022/07/25/Linux/yum-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[更新所有已安装的 rpm 包yum -y update
yum clean all
]]></content>
  </entry>
  <entry>
    <title>Java 线程池笔记</title>
    <url>/2022/09/14/Multithreading/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[ThreadPoolExecutorThreadPoolExecutor 继承了 AbstractExecutorService，成员变量 ctl 是一个 Integer 的原子变量，用来记录线程池状态和线程池中线程个数。

高 3 位用来表示线程池状态，低 29 位用来记录线程池线程个数。即，线程池状态理论上可以至多拥有 8 种。

实际上，线程池的状态如下：



线程池状态
描述



RUNNING
接收新任务并且处理阻塞队列里的任务


SHUTDOWN
拒绝新任务但是处理阻塞队列里的任务


STOP
拒绝新任务并且抛弃阻塞队列里的任务，同时会中断正在处理的任务


TIDYING
所有任务都执行完（包含阻塞队列里面的任务）后当前线程池活动线程数位 0，将要调用 terminated 方法


TERMINATED
终止状态。terminated 方法调用完成以后的状态


线程池参数：



参数
描述



corePoolSize
核心线程数，即使他们空闲也会保持在线程池中


maximumPoolSize
线程池中允许的最大线程数


keepAliveTime
保持存活时间，如果线程数超过核心线程数，而且超过的线程不在工作（空闲），他们允许有keepAliveTime 的时间存活，以便等待新任务。


TimeUnit
时长单位，用于 keepAliveTime


workQueue
用于保存等待执行的任务的阻塞队列


threadFactory
executor 用于创建线程的工厂


RejectedExecutionHandler
饱和策略，当队列满并且线程个数达到 maximunPoolSize 后采取的策略



keepAliveTime

一般情况下，keepAliveTime 可以设置为 0，表示线程运行完毕立即销毁；keepAliveTime &lt; 0，初始化才会报错
如果调用了 allowCoreThreadTimeOut(true)，那么 keepAlive &lt;&#x3D; 0 就会报错，这表示允许核心线程等待任务超时，而不是常驻。
newFixedThreadPoolnewFixedThreadPool 创建一个核心线程个数和最大线程个数都为 nThreads 的线程池：
public static ExecutorService newFixedThreadPool(int nThreads) &#123;        return new ThreadPoolExecutor(nThreads, nThreads,                                      0L, TimeUnit.MILLISECONDS,                                      new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; //使用自定义线程创建工厂 public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123;        return new ThreadPoolExecutor(nThreads, nThreads,                                      0L, TimeUnit.MILLISECONDS,                                      new LinkedBlockingQueue&lt;Runnable&gt;(),                                      threadFactory); &#125;

keepAliveTime 为 0，说明只要线程个数比核心线程个数多并且当前空闲则回收。
这里传递了 new LinkedBlockingQueue&lt;Runnable&gt;() 作为阻塞队列，默认大小为 Integer.MAX_VALUE，因此可以认为是一个无界队列。
newSingleThreadExecutor创建一个核心线程数和最大线程数都为 1 的线程池：
ExecutorService executor = Executors.newSingleThreadExecutor();


有界队列禁止设置长度为 0，至少是 1，因此似乎没有办法做到仅固定线程活跃，其他任务拒绝：
// 错误ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(            THREAD_POOL_SIZE, THREAD_POOL_SIZE, 0L, TimeUnit.SECONDS,            new ArrayBlockingQueue&lt;&gt;(0), new ThreadPoolExecutor.AbortPolicy());




ExecutorExecutor &gt; ExecutorService &gt; AbstractExecutorService &gt; ThreadPoolExecutor
execute() 和 submit() 有什么区别？

execute 无法返回值；submit 可以返回值

submit 底层调用了 execute


public ThreadPoolExecutor(	int corePoolSize,	int maximumPoolSize,	long keepAliveTime,	TimeUnit unit,	BlockingQueue&lt;Runnable&gt; workQueue,	ThreadFactory threadFactory,	RejectedExecutionHandler handler)
shutdown调用 shutdown 方法后，线程池就不会再接受新的任务了，但是工作队列里面的任务还是要执行的。该方法会立即返回，并不等待队列任务完成再返回。
shutdownNow调用 shutdownNow 方法后，线程池就不会再接受新的任务了，并且会丢弃工作队列里面的任务，正在执行的任务会被中断，该方法会立即返回，并不等待激活的任务执行完成。
org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor创建一个 Spring 线程池 ThreadPoolTaskExecutor
它暴露了Executor的配置参数作为bean属性
ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();//配置核心线程数executor.setCorePoolSize(100);//配置最大线程数executor.setMaxPoolSize(200);//配置队列大小executor.setQueueCapacity(2000000);//配置线程池中的线程的名称前缀executor.setThreadNamePrefix(&quot;mythread-&quot;);//线程执行时间executor.setKeepAliveSeconds(customPool.getKeepAliveSeconds());// rejection-policy：当pool已经达到max size的时候，如何处理新任务// CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行executor.setRejectedExecutionHandler(new ThreadPoolRejectedPolicyHandler());//执行初始化executor.initialize();return executor;


线程池 main 线程等待所有线程结束@Testpublic void mainWait() throws InterruptedException &#123;    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();    executor.setCorePoolSize(5); //核心池大小    executor.setMaxPoolSize(10); //最大线程数    executor.setQueueCapacity(10); //队列程度    executor.setThreadNamePrefix(&quot;sub-thread-&quot;);//线程前缀名称    executor.initialize(); //初始化    int count = 5; // 任务数量    CountDownLatch countDownLatch = new CountDownLatch(count); // 同步工具    for (int i = 0; i &lt; count; i++) &#123;        executor.execute(() -&gt; task(countDownLatch));    &#125;    System.out.println(&quot;main 线程等待子线程完成...&quot;);    countDownLatch.await();    System.out.println(&quot;main 线程工作结束.&quot;);    executor.shutdown();&#125;private void task(CountDownLatch countDownLatch) &#123;    try &#123;        System.out.println(Thread.currentThread().getName() + &quot; 工作开始！&quot;);        Thread.sleep((long) (Math.random() * 2000));        System.out.println(Thread.currentThread().getName() + &quot; 工作结束！&quot;);        countDownLatch.countDown();    &#125; catch (InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;]]></content>
  </entry>
  <entry>
    <title>SMB 协议对接</title>
    <url>/2022/09/14/Protocol/SMB-%E5%8D%8F%E8%AE%AE%E5%AF%B9%E6%8E%A5/</url>
    <content><![CDATA[参考引用https://github.com/hierynomus/smbj
fileAttributes，包含文件属性掩码https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/ca28ec38-f155-4768-81d6-4bfeb8586fc9
命令行使用
安装 smbclient 工具

apt -y --force-yes install smbclient


列出所有的共享名称

smbclient -L //&lt;HOSTNAME&gt; -U &lt;USERNAME&gt;%&lt;PASSWORD&gt;


进入特定共享名

smbclient 命令
查看当前文件夹

smb: \&gt; ls


创建一个目录

smb: \&gt; mkdir directory-name


进入目录smb: \&gt; cd DMS_Input_DistAndShop_CIB

yum install samba-client



下载

get xxmget xxmget xx


上传

关闭提示，这样可以在选择多个文件上传、下载的时候不会提示是否确认的信息。
prompt off

mput abc.txtmput abc*.txt

其他默认共享是系统安装完毕后就自动开启的共享,也叫管理共享,常被管理员用于远程管理计算机。在 Windows 2000&#x2F;XP 及更高级的版本中,默认开启的共享有“c$”、“d$”等所有的逻辑盘以及“admin$”、“ipc$”,这些共享都有“$”标志,意为隐含的。
假设你的计算机名为 CannedBread，在运行对话框输入: \\CannedBread\C$ 即可访问
命令连接目标 Windows 服务器共享目录（Windows安装完毕会开启驱动器的隐藏共享，需要管理员权限，访问路径是：盘符$)
smbclient //192.168.199.196/share -U Administrators/JiangChunbo

Java 使用maven
&lt;dependency&gt;    &lt;groupId&gt;com.hierynomus&lt;/groupId&gt;    &lt;artifactId&gt;smbj&lt;/artifactId&gt;    &lt;version&gt;0.11.5&lt;/version&gt;&lt;/dependency&gt;

SMB 关于 Windows 的共享文件夹
如果开启了密码保护需要提供账户和密码
计算机处于睡眠状态时无法访问共享目录
如果为 EveryOne 开启了访问权限，即使不存在的账户，也可以访问，此时密码应该被忽略
如果账户是系统存在的，则会进行密码认证，失败则不通过。
获得一个 SMBClient无参构造器:
SMBClient client = new SMBClient();

自定义配置:
SmbConfig config = SmbConfig.builder()        .withTimeout(120, TimeUnit.SECONDS) // Timeout sets Read, Write, and Transact timeouts (default is 60 seconds)        .withSoTimeout(180, TimeUnit.SECONDS) // Socket Timeout (default is 0 seconds, blocks forever)        .build();SMBClient client = new SMBClient(config);


获得一个 Connection// 注意关闭try (Connection connection = client.connect(&quot;127.0.0.1&quot;)) &#123;&#125; catch (IOException e) &#123;    // 可能 client connect 超时    throw new RuntimeException(e.getMessage(), e);&#125;


获得一个 Session获得一个会话示例代码:
Session session = connection.authenticate(    new AuthenticationContext(&quot;USERNAME&quot;, &quot;PASSWORD&quot;.toCharArray(), null));

获得 DiskShare// Connect to Sharetry (DiskShare share = (DiskShare) session.connectShare(&quot;shareDirectory&quot;)) &#123;    for (FileIdBothDirectoryInformation f : share.list(&quot;data&quot;, &quot;*.csv&quot;)) &#123;        System.out.println(&quot;File : &quot; + f.getFileName());    &#125;&#125;

整体 Demo获得共享名称为 shareDir 下的所有文件名信息，并输出: 
/**    * 1. 使用 try 语句块自动关闭资源    * 2. client.connect 参数 hostname 可能导致抛出异常    * 3. connection.authenticate 认证失败可能导致抛出异常    * 4. session.connectShare shareName 不存在可能导致抛出异常    * 5. share.list 传入的 path 错误可能导致抛出异常    */try (SMBClient client = new SMBClient();        Connection connection = client.connect(&quot;127.0.0.1&quot;);        Session session = connection.authenticate(new AuthenticationContext(&quot;USERNAME&quot;, &quot;PASSWORD&quot;.toCharArray(), null));        DiskShare share = (DiskShare) session.connectShare(&quot;shareDir&quot;)) &#123;    for (FileIdBothDirectoryInformation f : share.list(&quot;&quot;, &quot;*.csv&quot;)) &#123;        System.out.println(&quot;File : &quot; + f.getFileName());    &#125;&#125; catch (Exception e) &#123;    throw new RuntimeException(e);&#125;


com.hierynomus.smbj.share.File
打开一个文件（读）

File smbFileRead = dirShare.openFile(    fileName, // 路径    EnumSet.of(AccessMask.GENERIC_READ), // Set&lt;AccessMask&gt;    null, // Set&lt;FileAttributes&gt;    SMB2ShareAccess.ALL, // Set&lt;SMB2ShareAccess&gt;    SMB2CreateDisposition.FILE_OPEN, // SMB2CreateDisposition    null); // Set&lt;SMB2CreateOptions&gt;


SMB2CreateDisposition: 如果传递 FILE_OPEN，那么文件找不到的情况下会抛出异常；如果设置为 FILE_OPEN_IF，那么文件找不到的情况下会静默继续

远程拷贝

就是直接在远程机器上将一个文件拷贝到另一个文件
// 确保拷贝到的文件夹存在this.ensureDirectoryExists(diskShare, dir);com.hierynomus.smbj.share.File backupShareFile = diskShare.openFile(        &quot;copy-directory\\&quot; + filename,        EnumSet.of(AccessMask.GENERIC_ALL), // Set&lt;AccessMask&gt;        null, // Set&lt;FileAttributes&gt;        SMB2ShareAccess.ALL, // Set&lt;SMB2ShareAccess&gt;        SMB2CreateDisposition.FILE_CREATE, // SMB2CreateDisposition        null);smbFile.remoteCopyTo(backupShareFile);



如何判断一个 File 是否是文件夹

// FileIdBothDirectoryInformationboolean isDirectory = (f.getFileAttributes() &amp; 0x10) == 0x10;// Fileboolean directory = shareFile.getFileInformation().getStandardInformation().isDirectory();



案例将共享文件夹 \\127.0.0.1\shareDirectory 下的所有文件都转移到 \\127.0.0.1\shareDirectory\backup 文件夹下
public static void transferAllFiles(String path) &#123;    try (SMBClient client = new SMBClient();            Connection connection = client.connect(&quot;127.0.0.1&quot;);            Session session = connection.authenticate(new AuthenticationContext(&quot;USERNAME&quot;, &quot;PASSWORD&quot;.toCharArray(), null));            DiskShare share = (DiskShare) session.connectShare(&quot;shareDirectory&quot;)) &#123;        List&lt;FileIdBothDirectoryInformation&gt; fileIdBothDirectoryInformationList = share.list(path, &quot;*&quot;);        fileIdBothDirectoryInformationList = fileIdBothDirectoryInformationList.stream().filter(fileIdBothDirectoryInformation -&gt; &#123;            // 过滤掉文件夹            return (fileIdBothDirectoryInformation.getFileAttributes() &amp; 0x10) == 0;        &#125;).collect(Collectors.toList());        for (FileIdBothDirectoryInformation f : fileIdBothDirectoryInformationList) &#123;            com.hierynomus.smbj.share.File shareFile = share.openFile(                    path + &quot;\\&quot; + f.getFileName(), // 路径                    EnumSet.of(AccessMask.GENERIC_ALL), // Set&lt;AccessMask&gt;                    null, // Set&lt;FileAttributes&gt;                    SMB2ShareAccess.ALL, // Set&lt;SMB2ShareAccess&gt;                    SMB2CreateDisposition.FILE_OPEN, // SMB2CreateDisposition                    null); // Set&lt;SMB2CreateOptions&gt;            com.hierynomus.smbj.share.File backupShareFile = share.openFile(                    path + &quot;\\backup\\&quot; + f.getFileName(),                    EnumSet.of(AccessMask.GENERIC_ALL), // Set&lt;AccessMask&gt;                    null, // Set&lt;FileAttributes&gt;                    SMB2ShareAccess.ALL, // Set&lt;SMB2ShareAccess&gt;                    SMB2CreateDisposition.FILE_CREATE, // SMB2CreateDisposition                    null);            shareFile.remoteCopyTo(backupShareFile);            // 最后要删掉            shareFile.deleteOnClose();        &#125;    &#125; catch (Exception e) &#123;        throw new RuntimeException(e);    &#125;&#125;]]></content>
  </entry>
  <entry>
    <title>TCP 协议笔记</title>
    <url>/2022/07/20/Protocol/TCP-%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[TCP
报文种类
SYN
Data
FIN
Reset
ACK

SYN、Data、FIN 这三种报文发送方一定要收到 ACK 报文，如果在超时时间内不确认，发送方会一直重传，直到对方确认，或者达到重传上线次数而 Reset 连接。
三次握手


三次握手本质上是四次报文交互：

A 发送 SYN 报文给 B
B 发送 ACK 报文给 A，确认步骤 1
B 发送 SYN 报文给 A
A 发送 ACK 报文给 B，确认步骤 3

为了缩短延迟，将步骤 2、步骤 3 合并在一个报文发送，即 SYN + ACK 报文，形成三次握手。
第 1 次握手：
Client 将标志位 SYN 置为 1，随机产生一个 Initial sequence number（简称为 seq），假设 seq &#x3D; x
将该数据包发送给 Server，Client 进入 SYN_SENT 状态
第 2 次握手：
Server 接收到数据包后，由标志位 SYN &#x3D; 1 知道该报文是 Client 请求建立连接
Server 也会记录 Client 的 seq&#x3D;x

Server 不会将 SYN 与 SYN+ACK 混淆，因为只有 SYN&#x3D;1

Server 准备一个报文，将标志位 SYN 和 ACK 都置为 1，ack &#x3D; x + 1，随机产生一个 seq &#x3D; y，并将该数据包发送给 Client，进入 SYN_RCVD 状态
第 3 次握手：
Client 收到确认后，检查 ack 是否为 x + 1，如果正确，则将标志位 ACK 置为 1，ack &#x3D; y + 1，并将该数据包发送给 Server，Client 进入 ESTABLISHED 状态
Server 检查 ack 是否为 y + 1，ACK 是否为 1，如果正确，则建立连接成功，Server 进入 ESTABLISHED 状态
四次挥手假设 Client 主动关闭连接，
第 1 次挥手：Client 发送一个 FIN，以及一个序号 seq，告知 Server：我打算关闭连接了，Client 进入 FIN-WAIT-1 状态
第 2 次挥手：Server 收到 FIN 后，发送 ACK 给 Client，Server 进入 CLOSE-WAIT 状态，这时候 Server 可能还有一些数据没有传输完毕，继续传输。
第 3 次挥手：当 Server 没有数据发送给 Client 时，Server 发送一个 FIN 给 Client，告知 Client：我也没有数据给你了，我也可以关闭了，Server 进入 LAST-ACK 状态
第 4 次挥手，Client 收到 FIN，Client 进入 TIME_WAIT 状态，发送 ACK 给 Server，Server 接收到 ACK 之后，进入 CLOSED 状态。
TIME_WAIT 存在的问题？一个连接进入 TIME_WAIT 状态后需要等待 2 * MSL 的事件才能断开连接释放连接占用的资源
服务器：短时间内关闭了大量的 Client 连接，会造成服务器上出现大量的 TIME_WAIT 连接，占据大量的 tuple，严重消耗着服务器的资源。
客户端：短时间内大量的短链接，会大量消耗 Client 机器的接口，端口只有 65535 个，端口被耗尽，无法发起新的连接。
关于 Windows 的端口使用问题：
Windows 系统供用户使用的端口是具有一定配置的，可以通过以下命令查看：
C:\Users\JiangChunbo&gt;netsh int ipv4 show dynamicport tcp协议 tcp 动态端口范围---------------------------------启动端口        : 49152端口数          : 16384

通常具有一个启动端口（start）表示可用的起始端口号，以及端口数（num）表示从起始端口号开始可用的端口数。默认是从 49152 - 65535。
参考 MaxUserPort、TcpTimedWaitDelay、优化网络性能的可修改设置
测试 Windows 端口耗尽，例如使用如下 PHP 脚本将本机器的端口全部耗尽：
while (true) &#123;    $conn = mysqli_connect(&quot;******&quot;, &quot;******&quot;, &quot;******&quot;);    mysqli_close($conn);&#125;

这时候，尝试申请数据库连接的时候会产生如下警告：



TCP 协议端口连接状态LISTENING提供某种服务，侦听远方 TCP 端口的连接请求，当提供的服务没有连接时，处于 LISTENING 状态，端口时开放的，等待连接。
SYN_SENT(客户端状态)客户端调用 connect，发送一个 SYN 请求建立一个连接，在发送连接请求后等待匹配的连接请求，此时状态为 SYN_SENT
SYN_RECEIVED（服务端状态）在收到和发送一个连接请求后，等待对方对连接请求的确认，当服务器收到客户端发送的同步信号时，将标志位 ACK 和 SYN 置为 1 发送给客户端，此时服务端处于 SYN_RCVD 状态，如果连接成功就变为 ESTABLISED，正常情况下 SYN_RECEIVED 非常短暂
ESTABLISHEDESTABLISHED 状态是表示两台机器正在传输数据
FIN-WAIT-1等待远程 TCP 连接中断请求，或先前的连接中断请求的确认，主动关闭端应用程序调用 close，TCP 发出 FIN 请求主动关闭连接，之后进入 FIN_WAIT1状态
FIN-WAIT-2从远程 TCP 等待连接中断请求，主动关闭端接到 ACK 后，就进入了 FIN-WAIT-2。这是在关闭连接时，客户端和服务端两次握手之后的状态，是著名的半关闭状态，在这个状态下，应用程序还有接受数据的能力，但是已经无法发送数据，但是也有一种可能是，客户端一直处于 FIN-WAIT-2 状态，服务端则一直处于 WAIT_CLOSE 状态，而直到应用层来决定关闭这个状态。
CLOSE-WAIT等待从本地用户发来的连接中断请求，被动关闭端 TCP 接到 FIN 后，就发出 ACK 以回应 FIN 请求（它的接收也作为文件结束符传递给上层应用程序），并进入 CLOSE_WAIT
CLOSING等待远程 TCP 对连接中断的确认，处于此种状态比较少见
LAST-ACK等待原来的发向远程 TCP 的连接中断请求的确认，被动关闭段一段时间后接收到文件结束符的应用程序将调用 CLOSE 关闭连接，TCP 也发送一个 FIN，等待对方的 ACK，进入 LAST-ACK
TIME-WAIT在主动关闭段接收到 FIN 后，TCP 就发送 ACK 包，并进入 TIME-WAIT 状态，等待足够的事件以确保 TCP 接收到连接中断请求的确认，很大程度上保证了双方都可以正常结束，但是也存在问题，必须等待 2MSL 时间的过去才能进行下一次连接。
CLOSED被动关闭端在接收到 ACK 包后，就进入了closed的状态，连接结束，没有任何连接状态
]]></content>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT 笔记</title>
    <url>/2022/10/03/RFC/JWT-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[参考https://jwt.io/introduction
什么是 JSON Web Token?JSON Web Token(JWT) 是一个开放标准（RFC 7519），它定义了一种紧凑和自包含的方式，用于以 JSON 对象哎各方之间安全地传输信息。此信息可以进行验证和信任，因为它是经过数字签名地。JWT 可以使用 secret 或者使用 RSA 或 ECDSA 地公钥&#x2F;私钥对进行签名。
虽然可以对 JWT 进行加密，以便在各方之间提供保密性，但是我们将重点关注已签名的令牌。签名令牌可以验证其中包含的声明的完整性，而加密令牌可以向其他方隐藏这些声明。当使用公钥&#x2F;私钥对对令牌进行签名时，该签名还证明只有持有私钥的一方才时对其进行签名的一方。
JSON Web Token 结构是什么?在其紧凑的形式中，JSON Web Token 由以点（.）分隔的三个部分组成，它们是:

Header
Payload
Signature

因此，JWT 通常看起来像下面这样:
xxxxx.yyyyy.zzzzz

HeaderHeader 通常由两部分组成：令牌（即 JWT）的类型，以及所使用的签名算法（如: HMAC SHA256 或者 RSA）。
&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;
然后，对这个 JSON 进行 Base64Url 编码，形成 JWT 的第一部分。
Payload令牌的第二部分是有效载荷，其中包含声明。声明是关于实体（通常是用户）和其他数据的语句。有三种类型的声明：registered，public，以及 private 声明

Registered claims: 这是一组预定义的声明，它们不是强制性的，而是推荐的，以提供一组有用的、可互操作的声明。其中一些是: iss（发行者），exp（过期时间），sub（主题），aud（手中）等其他。


注意，声明的名字只有三个字符，因为 JWT 旨在紧凑。


Public claims: 使用 JWT 的人可以随意定义它们。但是为了避免冲突，应该在 IANA JSON Web Token 注册表中定义它们，或者将它们定义为包含抗冲突名称空间的 URI。

Private claims: 这些是创建用于在同意使用它们的各方之间共享信息的自定义声明，既不是 registered 声明，也不是 public 声明


&#123;  &quot;sub&quot;: &quot;1234567890&quot;,  &quot;name&quot;: &quot;John Doe&quot;,  &quot;admin&quot;: true&#125;

然后，对有效载荷进行 Base64Url 编码，形成 JSON Web 令牌的第二部分。

请注意，对于已经签名的令牌，这些信息虽然受到保护，不会被篡改，但任何人都可以阅读。除非加密，否则不要将机密信息放在 JWT 的有效载荷或头元素中。

Signature要创建签名部分，你必须获取编码的 header，编码的有效载荷，secret，表头中指定的算法，并对其签名。
例如，如果你想使用 HMAC SHA256 算法，签名将按以下方式创建: 
HMACSHA256(  base64UrlEncode(header) + &quot;.&quot; +  base64UrlEncode(payload),  secret)

该签名用于验证消息在执行过程中没有被更改，并且，对于使用私钥签名的令牌，它还可以验证 JWT 的发送方是否就是它所说的那个人。
JSON Web Token 如何工作在身份认证中，当用户使用凭据成功登陆时，将返回一个 JSON Web Token。由于令牌是凭证，因此必须非常小心地注意，防止出现安全问题。一般来说，令牌的保存时间不应超过所需时间。
由于缺乏安全性，也不应将敏感会话数据存储在浏览器存储中。
无论何时用户想要访问受保护的路由或资源，用户代理都应该发送 JWT，通常在 Authorization 头部使用 Bearer 模式。header 的内容应如下: 
Authorization: Bearer &lt;token&gt;

在某些情况下，这可以是无状态授权机制。服务器的受保护路由将在 Authorization 头部检查有效的 JWT，如果存在有效的 JWT，则允许用户访问受保护的资源。如果 JWT 包含必要的数据，那么查询数据库以执行某些操作的需求可能会减少，尽管情况可能并非总是如此。
注意，如果通过 HTTP 头发送 JWT 令牌，应该尽量避免它们变得太大。有些服务器不接受超过 8KB 的报头。如果你试图在 JWT 令牌中嵌入太多信息（比如通过包含用户所有的权限），那么你可能需要另一种解决方案，比如 Auth0 Fine-Grined Authorization。
如果令牌是在 Authorization 头部发送的，那么跨域资源共享（CORS）就不是问题，因为它不适用 Cookie。
]]></content>
  </entry>
  <entry>
    <title>RFC 6749</title>
    <url>/2022/07/26/RFC/RFC-6749/</url>
    <content><![CDATA[1.1. Roles 角色
OAuth 定义了四个角色：

resource owner 资源拥有者:

一个实体，其能够授予受保护的资源的访问权限。当 resource owner 是一个人，他被称之为一个终端用户。

resource server 资源服务器

一个服务，其托管受保护的资源，能够接受并响应使用 access token 进行受保护资源的请求。

client 客户端

一个应用，代表资源拥有者发出受保护资源的请求，并使用其授权。术语 “client” 并不表示任何特别的实现特征（例如，不论该应用在服务器，桌面，或者其他设备上执行）。

authorization server

一个服务，在成功认证了  并获得了授权之后，颁发 access_token 给 client。
OAuth 定义了四种授予类型:

authorization code，授权码
implicit，隐藏式
resource owner password credentials，密码
client credentials，凭证式

authorization code
企业微信的授权与 code 很类似，但有所不同。企业微信 code 并不是换取 access_token，而是换取 userid。也就是，一般的 OAuth2，code 与 user 有关联，code 换取的 access_token 与 user 也有关联，用户可以通过 access_token 访问自己权限下的信息。 

resource owner password credentials，密码A 网站直接要求用户提供 B 网站的用户名和密码。拿到之后，A 直接向 B 请求令牌。
client credentials，客户端凭证式适用于没有前端的命令行应用。
这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。
企业微信的 access_token 获取类似于这种方式
(A) client 通过将 resource owner 的 user-agent 重定向到 authorization 后端，开始流程。client 包含它的 client identifier，requested scope，local state，以及一个 redirection uri，一旦授权（或者拒绝）该访问，授权服务器会把 user-agent 发回该 uri。

client 可以认为是第三方应用的页面（上面具有一个授权按钮），用户点击该按钮，就会跳转到授权服务器，同时会附带一些参数。

(B) 授权服务器认证 resource owner，并确定 resource owner 是授权还是拒绝 client 的范围请求。
(C) 假设 resource owner 授权访问，授权服务器使用之前提供的 redirection uri 将 user-agent 重定向回 client。redirection uri 包含 authorization code 以及之前 client 提供的任何本地状态。

code 的实现可以是 UUID、UUID+MD5 等

(D) client 通过前面步骤获得的 authorization code 从授权服务器的 token 后端请求 access token。当发出请求时，client 使用授权服务器认证。client 包含 redirection URI ，用于获取进行验证的授权码。
(E) 授权服务器认证客户端，验证授权码，确保接受到的 redirection URI  
10. Security Considerations10.4. Refresh TokensAuthorization Server 可以（MAY）给 Web 应用客户端和本地应用客户端颁发 Refresh Token。
Refresh Token 必须（MUST）在运输和存储的过程中保密，并且仅仅在 Authorization Server 和颁发了 Refresh Token 的客户端之间共享。Authorzation Server 必须（MUST） 维护 Refresh Token 和颁发了 Refresh Token 的客户端之间的绑定关系。Refresh Token 必须（MUST）只能使用 TLS 传输。??
每当客户身份可以验证时，Authorzation Server 必须（MUST）验证 Refresh Token 和客户身份之间的绑定关系。当无法进行客户端认证时，Authorization Server 应当（SHOULD）调配其他方案，以检测 Refresh Token 滥用。
例如，Authorization Server 可以使用 Refresh Token 循环，每个 access Token 刷新响应就在循环中颁发一个新的 Refresh Token。前一个 Refresh Token 失效，但是还会被 Authorization Server 保留。如果一个 Refresh Token 被渗透了，随后都被攻击者和合法客户端使用，其中一个会出现无效的 Refresh Token，它将告知授权服务器违规。
授权服务器必须确保 Refresh Token 不能被生成，篡改，或者猜测以生成有效的刷新令牌。
]]></content>
  </entry>
  <entry>
    <title>OAuth 2.0 Authorization Server 设计</title>
    <url>/2022/08/12/Security/OAuth-2-0-Authorization-Server-%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>OAuth2 设计</title>
    <url>/2022/08/03/Security/OAuth2-%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[OAuth2 设计暴露的端点
GET &#x2F;oauth&#x2F;authorize该端点采用 GET 请求，主要是让用户能够跳转到授权页面。

GET &#x2F;oauth&#x2F;confirm_access提供用户确认授权的视图

POST &#x2F;oauth&#x2F;authorize用户确认授权


]]></content>
  </entry>
  <entry>
    <title>OAuth 2.0 Client 设计</title>
    <url>/2022/08/04/Security/OAuth-2.0-Client-%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[Client依赖&lt;!-- spring boot web starter --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.oltu.oauth2&lt;/groupId&gt;    &lt;artifactId&gt;org.apache.oltu.oauth2.client&lt;/artifactId&gt;    &lt;version&gt;1.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;    &lt;artifactId&gt;shiro-spring-boot-web-starter&lt;/artifactId&gt;    &lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt;


实体
AuthorizationServerConfig接口，提供各个授权服务器的基本配置

AuthorizationServerToken接口，提供各个授权服务器的 token 访问

AuthorizationServer实体类，实现了 token 访问和基本信息访问


AuthorizationServer.java 用于表示该客户端接入的某一个授权服务器。
考虑到客户端可能接入多个授权服务器，因此需要维护客户端在不同授权服务器中的基础信息。
基础信息包括：

name, 标识不同授权服务器
client_id, 该授权服务器中的 client_id
client_secret, 该授权服务器中 client_secret
access_token_uri, 该授权服务器暴露的 token 获取端点
user_info_uri, 该资源服务器暴露的 user_info 获取端点
redirect_uri, 跳转地址
…

AuthorizationServerConfigpackage com.jiangchunbo.oauth2.client.entity;public interface AuthorizationServerConfig &#123;    /**     * 返回授权服务器的唯一标识，如 baidu、tencent     *     * @return name     */    String getName();    /**     * 授权服务器的 authorize 端点地址     *     * @return authorize_uri     */    String getAuthorizeUri();    /**     * 授权服务器的 scope     *     * @return scope     */    String getScope();    /**     * 授权地址额外的自定义参数     *     * @return params     */    String getCustomParams();    /**     * access_token 获取地址     *     * @return access_token_uri     */    String getAccessTokenUri();    /**     * 该授权服务器中的 client_id     *     * @return client_id     */    String getClientId();    /**     * 该授权服务器中 client_secret     *     * @return client_secret     */    String getClientSecret();    /**     * 跳转地址     *     * @return redirect_uri     */    String getRedirectUri();    /**     * 获取用户信息地址     *     * @return user_info_uri     */    String getUserInfoUri();&#125;

AuthorizationServerTokenpackage com.jiangchunbo.oauth2.client.entity;public interface AuthorizationServerToken &#123;    /**     * 返回存储的 access token     *     * @return access token     */    String getAccessToken();    /**     * 返回存储的 refresh token     *     * @return refresh token     */    String getRefreshToken();    /**     * 返回存储的 access token 过期时间     *     * @return access token 过期时间     */    String getAccessTokenExpire();    /**     * 返回存储的 refresh token 过期时间     *     * @return refresh token 过期时间     */    String getRefreshTokenExpire();&#125;

AuthorizationServerpublic class AuthorizationServer implements AuthorizationServerConfig, AuthorizationServerToken &#123;    private Integer id;    private String name;    private String authorizeUri;    private String scope;    private String customParams;    private String accessTokenUri;    private String clientId;    private String clientSecret;    private String redirectUri;    private String userInfoUri;    private String accessToken;    private String refreshToken;    private String accessTokenExpire;    private String refreshTokenExpire;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    @Override    public String getCustomParams() &#123;        return customParams;    &#125;    public void setCustomParams(String customParams) &#123;        this.customParams = customParams;    &#125;    @Override    public String getScope() &#123;        return scope;    &#125;    public void setScope(String scope) &#123;        this.scope = scope;    &#125;    public String getAccessTokenUri() &#123;        return accessTokenUri;    &#125;    public void setAccessTokenUri(String accessTokenUri) &#123;        this.accessTokenUri = accessTokenUri;    &#125;    public String getClientId() &#123;        return clientId;    &#125;    public void setClientId(String clientId) &#123;        this.clientId = clientId;    &#125;    public String getClientSecret() &#123;        return clientSecret;    &#125;    public void setClientSecret(String clientSecret) &#123;        this.clientSecret = clientSecret;    &#125;    @Override    public String getRedirectUri() &#123;        return redirectUri;    &#125;    public void setRedirectUri(String redirectUri) &#123;        this.redirectUri = redirectUri;    &#125;    @Override    public String getUserInfoUri() &#123;        return userInfoUri;    &#125;    public void setUserInfoUri(String userInfoUri) &#123;        this.userInfoUri = userInfoUri;    &#125;    public String getName() &#123;        return name;    &#125;    public void setAuthorizeUri(String authorizeUri) &#123;        this.authorizeUri = authorizeUri;    &#125;    @Override    public String getAuthorizeUri() &#123;        return this.authorizeUri;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getAccessToken() &#123;        return accessToken;    &#125;    public void setAccessToken(String accessToken) &#123;        this.accessToken = accessToken;    &#125;    public String getRefreshToken() &#123;        return refreshToken;    &#125;    public void setRefreshToken(String refreshToken) &#123;        this.refreshToken = refreshToken;    &#125;    public String getAccessTokenExpire() &#123;        return accessTokenExpire;    &#125;    public void setAccessTokenExpire(String accessTokenExpire) &#123;        this.accessTokenExpire = accessTokenExpire;    &#125;    public String getRefreshTokenExpire() &#123;        return refreshTokenExpire;    &#125;    public void setRefreshTokenExpire(String refreshTokenExpire) &#123;        this.refreshTokenExpire = refreshTokenExpire;    &#125;&#125;


授权服务器配置 Bean创建 Bean 时调用 init 方法从数据库加载所有配置到内存

也可以考虑从配置文件加载

@Componentpublic class AuthorizationServerConfigProperties extends ConcurrentHashMap&lt;String, AuthorizationServerConfig&gt; &#123;    @Resource    AuthorizationServerMapper authorizationServerMapper;    @PostConstruct    public void init() &#123;        final List&lt;AuthorizationServerConfig&gt; configs = authorizationServerMapper.selectAllConfig();        if (configs != null &amp;&amp; !configs.isEmpty()) &#123;            for (AuthorizationServerConfig config : configs) &#123;                this.put(config.getName(), config);            &#125;        &#125;    &#125;&#125;

DAO(Mapper)@Mapperpublic interface AuthorizationServerMapper &#123;    /**     * 依据授权服务器的标识符从数据库访问信息     *     * @param name 授权服务器标识符     * @return 基本配置信息     */    AuthorizationServerConfig selectConfigByName(String name);    /**     * 从数据库取出所有的授权服务器配置信息     *     * @return 授权服务器配置信息列表     */    List&lt;AuthorizationServerConfig&gt; selectAllConfig();    /**     * 依据授权服务器的标识符从数据库取出信息     *     * @param name 授权服务器标识符     * @return 授权服务器信息     */    AuthorizationServer selectByName(String name);    /**     * 根据主键 Id 更新存储的授权服务器 token 信息     *     * @param authorizationServer token 信息     * @param id                  主键 id     * @return 影响行数     */    Integer updateTokenById(@Param(&quot;authorizationServer&quot;) AuthorizationServer authorizationServer, @Param(&quot;id&quot;) Integer id);&#125;

&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.jiangchunbo.oauth2.client.mapper.AuthorizationServerMapper&quot;&gt;    &lt;update id=&quot;updateTokenById&quot;&gt;        update `authorization_server`        set `access_token`=#&#123;authorizationServer.accessToken&#125;,            `access_token_expire`=#&#123;authorizationServer.accessTokenExpire&#125;,            `refresh_token`=#&#123;authorizationServer.refreshToken&#125;,            `refresh_token_expire` = #&#123;authorizationServer.refreshTokenExpire&#125;        where `id` = #&#123;id&#125;    &lt;/update&gt;    &lt;select id=&quot;selectConfigByName&quot; resultType=&quot;com.jiangchunbo.oauth2.client.entity.AuthorizationServer&quot;&gt;        select *        from `authorization_server`        where `name` = #&#123;name&#125;    &lt;/select&gt;    &lt;select id=&quot;selectByName&quot; resultType=&quot;com.jiangchunbo.oauth2.client.entity.AuthorizationServer&quot;&gt;        select *        from `authorization_server`        where `name` = #&#123;name&#125;    &lt;/select&gt;    &lt;select id=&quot;selectAllConfig&quot; resultType=&quot;com.jiangchunbo.oauth2.client.entity.AuthorizationServer&quot;&gt;        select *        from `authorization_server` where `is_del`=0    &lt;/select&gt;&lt;/mapper&gt;


Servicepublic interface AuthorizationServerService &#123;    /**     * 更新 token 相关信息     *     * @param authorizationServer token 信息     * @param id                  主键 id     * @return 影响函数     */    Integer updateTokenById(AuthorizationServer authorizationServer, Integer id);    /**     * 使用 code 请求 access_token；如果缓存 token 未过期，则使用缓存 token     *     * @param token code token     * @return access_token     * @throws Exception 异常     */    String getAccessToken(OAuthCodeToken token) throws Exception;&#125;

@Servicepublic class AuthorizationServerServiceImpl implements AuthorizationServerService &#123;    @Resource    AuthorizationServerMapper authorizationServerMapper;    @Override    public Integer updateTokenById(AuthorizationServer authorizationServer, Integer id) &#123;        return authorizationServerMapper.updateTokenById(authorizationServer, id);    &#125;    @Override    public String getAccessToken(OAuthCodeToken token) throws Exception &#123;        final String name = token.getName();        final AuthorizationServer server = authorizationServerMapper.selectByName(name);        if (server == null) &#123;            throw new RuntimeException(&quot;未找到 &quot; + name + &quot; 相关的配置&quot;);        &#125;        if (!StringUtils.isEmpty(server.getAccessToken()) &amp;&amp; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).parse(server.getAccessTokenExpire()).after(new Date())) &#123;            return server.getAccessToken();        &#125;        final String code = token.getCode();        final OAuthClientRequest accessTokenRequest = OAuthClientRequest.tokenLocation(server.getAccessTokenUri())                .setGrantType(GrantType.AUTHORIZATION_CODE)                .setClientId(server.getClientId())                .setClientSecret(server.getClientSecret())                .setCode(code)                .setRedirectURI(server.getRedirectUri())                .buildQueryMessage();        OAuthClient oAuthClient = new OAuthClient(new URLConnectionClient());        OAuthAccessTokenResponse oAuthResponse = oAuthClient.accessToken(accessTokenRequest, OAuth.HttpMethod.GET);        String accessToken = oAuthResponse.getAccessToken();        final String refreshToken = oAuthResponse.getRefreshToken();        Long expiresIn = oAuthResponse.getExpiresIn();        final String accessTokenExpire = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)                .format(new Date(System.currentTimeMillis() + expiresIn * 1000));        final String refreshTokenExpire = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)                .format(new Date(System.currentTimeMillis() + 10L * 365 * 24 * 60 * 60 * 1000));        final AuthorizationServer authorizationServer = new AuthorizationServer();        authorizationServer.setAccessToken(accessToken);        authorizationServer.setRefreshToken(refreshToken);        authorizationServer.setAccessTokenExpire(accessTokenExpire);        authorizationServer.setRefreshTokenExpire(refreshTokenExpire);        this.updateTokenById(authorizationServer, server.getId());        return accessToken;    &#125;&#125;



Shiro 相关的准备Shiro 配置类@Configuration@ConditionalOnProperty(name = &quot;shiro.web.enabled&quot;, matchIfMissing = true)public class ShiroConfiguration &#123;    @Bean    public Realm baiduOAuthRealm() &#123;        final BaiduOAuthRealm baiduOAuthRealm = new BaiduOAuthRealm();        baiduOAuthRealm.setAuthenticationTokenClass(OAuthCodeToken.class);        return baiduOAuthRealm;    &#125;    @Bean(&quot;oauth2&quot;)    public OAuth2AuthenticationFilter oAuth2AuthenticationFilter() &#123;        return new OAuth2AuthenticationFilter();    &#125;    @Bean    public FilterRegistrationBean&lt;OAuth2AuthenticationFilter&gt; oAuth2AuthenticationFilterRegistrationBean() &#123;        final FilterRegistrationBean&lt;OAuth2AuthenticationFilter&gt; registrationBean = new FilterRegistrationBean&lt;&gt;();        registrationBean.setFilter(oAuth2AuthenticationFilter());        registrationBean.setEnabled(false);        return registrationBean;    &#125;    /**     * 配置 chain definition     *     * @return chainDefinition     */    @Bean    protected ShiroFilterChainDefinition shiroFilterChainDefinition() &#123;        DefaultShiroFilterChainDefinition chainDefinition = new DefaultShiroFilterChainDefinition();        chainDefinition.addPathDefinition(&quot;/index.html&quot;, &quot;oauth2&quot;);        chainDefinition.addPathDefinition(&quot;/**&quot;, &quot;anon&quot;);        return chainDefinition;    &#125;&#125;

AuthenticatingFilterpublic class OAuth2AuthenticationFilter extends AuthenticatingFilter &#123;    private final static String CODE_PARAM = &quot;code&quot;;    private final static String NAME_PARAM = &quot;name&quot;;    /**     * 当 isAccessDenied 返回 true 时，回退到该方法，该方法一般会执行 login 逻辑     *     * @param request  请求     * @param response 响应     * @return 是否继续     * @throws Exception executeLogin 抛出的一些异常     */    @Override    protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception &#123;        Subject subject = getSubject(request, response);        if (!subject.isAuthenticated() &amp;&amp; !StringUtils.isEmpty(request.getParameter(CODE_PARAM))) &#123;            return executeLogin(request, response);        &#125;        return true;    &#125;    /**     * 执行 login 逻辑的时候创建的 token     *     * @param request  请求     * @param response 响应     * @return 执行 login 的 token     */    @Override    protected AuthenticationToken createToken(ServletRequest request, ServletResponse response) &#123;        String code = request.getParameter(CODE_PARAM);        code = !StringUtils.isEmpty(code) ? code : &quot;&quot;;        final String name = request.getParameter(NAME_PARAM);        return new OAuthCodeToken(name, code);    &#125;    /**     * 登录失败的逻辑     *     * @param token    token     * @param e        异常信息     * @param request  请求     * @param response 响应     * @return 是否继续过滤器     */    @Override    protected boolean onLoginFailure(AuthenticationToken token, AuthenticationException e, ServletRequest request, ServletResponse response) &#123;        try &#123;            final String body = OAuthResponse.errorResponse(HttpServletResponse.SC_BAD_REQUEST)                    .setError(&quot;错误&quot;)                    .setErrorDescription(e.getMessage())                    .buildJSONMessage().getBody();            response.setContentType(MediaType.APPLICATION_JSON_VALUE);            response.setCharacterEncoding(StandardCharsets.UTF_8.name());            response.getWriter().print(body);            response.getWriter().flush();        &#125; catch (IOException | OAuthSystemException ex) &#123;            // TODO            throw new RuntimeException(ex);        &#125;        return true;    &#125;&#125;


AuthenticationToken存储 code 以及 name 标识授权服务器
public class OAuthCodeToken implements AuthenticationToken &#123;    /**     * 授权码     */    private final String code;    /**     * 每个授权服务器方的名字标识，如: baidu、tencent     */    private final String name;    public OAuthCodeToken(String name, String code) &#123;        this.name = name;        this.code = code;    &#125;    @Override    public Object getPrincipal() &#123;        return name;    &#125;    @Override    public Object getCredentials() &#123;        return code;    &#125;    public String getName() &#123;        return name;    &#125;    public String getCode() &#123;        return code;    &#125;&#125;


RealmOAuthRealm 提供基本的 OAuth2 获取用户名的流程
public abstract class OAuthRealm extends AuthenticatingRealm &#123;    @Resource    AuthorizationServerConfigProperties authorizationServerProperties;    @Resource    AuthorizationServerService authorizationServerService;    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;        // 确保 token 中的 credential 与 authentication info 的 credentials 一致，否则后面验证会出错        OAuthCodeToken codeToken = (OAuthCodeToken) token;        SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo();        try &#123;            String username = extractUsername(codeToken);            authenticationInfo.setPrincipals(new SimplePrincipalCollection(username, getName()));            authenticationInfo.setCredentials(codeToken.getCode());            return authenticationInfo;        &#125; catch (Exception e) &#123;            return authenticationInfo;        &#125;    &#125;    protected abstract String extractUsername(OAuthCodeToken codeToken) throws Exception;&#125;

BaiduOAuthRealm 实现了 OAuthRealm，返回 netdisk_name 名称
public class BaiduOAuthRealm extends OAuthRealm &#123;    @Override    protected String extractUsername(OAuthCodeToken codeToken) throws Exception &#123;        OAuthClient oAuthClient = new OAuthClient(new URLConnectionClient());        final String accessToken = authorizationServerService.getAccessToken(codeToken);        final AuthorizationServerConfig serverConfig = authorizationServerProperties.get(codeToken.getName());        try &#123;            // 保存 access_token 和 expires in            OAuthClientRequest userInfoRequest = new OAuthBearerClientRequest(serverConfig.getUserInfoUri())                    .setAccessToken(accessToken)                    .buildQueryMessage();            OAuthResourceResponse resourceResponse = oAuthClient.resource(userInfoRequest, OAuth.HttpMethod.GET, OAuthResourceResponse.class);            final Map&lt;String, Object&gt; data = JSONUtils.parseJSON(resourceResponse.getBody());            return data.get(&quot;netdisk_name&quot;).toString();        &#125; catch (OAuthSystemException | OAuthProblemException e) &#123;            throw new AuthenticationException(e.getMessage());        &#125;    &#125;&#125;]]></content>
  </entry>
  <entry>
    <title>短信接口防盗用</title>
    <url>/2022/07/27/Security/%E7%9F%AD%E4%BF%A1%E6%8E%A5%E5%8F%A3%E9%98%B2%E7%9B%97%E7%94%A8/</url>
    <content><![CDATA[
校验 Referer 头部
签名校验
mobile 参数可以略微进行 AES 加密等，增加复杂度
IP + UA 限制次数例如，使用 Redis 记录次数

假设 key 特定前缀是 code_send_limit_
key &#x3D; code_send_limit_ + &lt;IP 和 UA 的混合&gt;value &#x3D; 次数

incr  expireAt

public class FrequencyInterceptor implements HandlerInterceptor &#123;    /**     * 最大限制     */    private final int maxLimit;    /**     * 时间段     */    private final int periodInSeconds;    RedisTemplate&lt;String, Object&gt; redisTemplate;    public FrequencyInterceptor(int maxLimit, int periodInSeconds, RedisTemplate&lt;String, Object&gt; redisTemplate) &#123;        this.maxLimit = maxLimit;        this.periodInSeconds = periodInSeconds;        this.redisTemplate = redisTemplate;    &#125;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        String ipAddr = IpUtil.getIpAddr(request);        String userAgent = request.getHeader(&quot;user-agent&quot;);        MessageDigest md5 = MessageDigest.getInstance(&quot;md5&quot;);        byte[] digest = md5.digest((ipAddr + userAgent).getBytes(StandardCharsets.UTF_8));        final String ipAndUa = new BigInteger(1, md5.digest()).toString(16);        String key = &quot;send_msg_limit:&quot; + ipAndUa;        Integer limit = (Integer) redisTemplate.opsForValue().get(key);        if (limit == null) &#123;            // 此处可能高并发            Long newValue = redisTemplate.opsForValue().increment(key);            if (newValue == null) &#123;                // 出错                throw new RuntimeException(&quot;网络繁忙，请稍后重试&quot;);            &#125;            // 只需考虑第一个设置过期时间            if (newValue == 1) &#123;                redisTemplate.expire(key, Duration.ofSeconds(periodInSeconds));                return true;            &#125; else if (newValue &lt;= maxLimit) &#123;                return true;            &#125; else &#123;                // 如果是溢出请求，全部打回                throw new RuntimeException(&quot;操作频繁，请稍后重试&quot;);            &#125;        &#125; else if (limit &gt; 5) &#123;            // 一般情况，溢出打回            throw new RuntimeException(&quot;操作频繁，请稍后重试&quot;);        &#125; else &#123;            Long newValue = redisTemplate.opsForValue().increment(key);            if (newValue == null) &#123;                throw new RuntimeException(&quot;网络繁忙，请稍后重试&quot;);            &#125;            if (newValue &lt;= maxLimit) &#123;                return true;            &#125; else &#123;                throw new RuntimeException(&quot;操作频繁，请稍后重试&quot;);            &#125;        &#125;    &#125;    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        System.out.println(&quot;postHandle...&quot;);    &#125;    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;        System.out.println(&quot;afterCompletion...&quot;);    &#125;&#125;]]></content>
  </entry>
  <entry>
    <title>IDEA Tomcat 控制台乱码</title>
    <url>/2022/10/12/Tomcat/IDEA-Tomcat-%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[环境D:\apache-tomcat-9.0.65\bin&gt;catalina versionUsing CATALINA_BASE:   &quot;D:\apache-tomcat-9.0.65&quot;Using CATALINA_HOME:   &quot;D:\apache-tomcat-9.0.65&quot;Using CATALINA_TMPDIR: &quot;D:\apache-tomcat-9.0.65\temp&quot;Using JRE_HOME:        &quot;C:\Program Files\Java\jdk1.8.0_341&quot;Using CLASSPATH:       &quot;D:\apache-tomcat-9.0.65\bin\bootstrap.jar;D:\apache-tomcat-9.0.65\bin\tomcat-juli.jar&quot;Using CATALINA_OPTS:   &quot;&quot;Server version: Apache Tomcat/9.0.65Server built:   Jul 14 2022 12:28:53 UTCServer number:  9.0.65.0OS Name:        Windows 11OS Version:     10.0Architecture:   amd64JVM Version:    1.8.0_341-b10JVM Vendor:     Oracle Corporation


Tomcat 日志配置配置文件是 conf/logging.properties。
############################################################# Handler specific properties.# Describes specific configuration info for Handlers.############################################################1catalina.org.apache.juli.AsyncFileHandler.level = FINE1catalina.org.apache.juli.AsyncFileHandler.directory = $&#123;catalina.base&#125;/logs1catalina.org.apache.juli.AsyncFileHandler.prefix = catalina.1catalina.org.apache.juli.AsyncFileHandler.maxDays = 901catalina.org.apache.juli.AsyncFileHandler.encoding = GBK2localhost.org.apache.juli.AsyncFileHandler.level = FINE2localhost.org.apache.juli.AsyncFileHandler.directory = $&#123;catalina.base&#125;/logs2localhost.org.apache.juli.AsyncFileHandler.prefix = localhost.2localhost.org.apache.juli.AsyncFileHandler.maxDays = 902localhost.org.apache.juli.AsyncFileHandler.encoding = GBK3manager.org.apache.juli.AsyncFileHandler.level = FINE3manager.org.apache.juli.AsyncFileHandler.directory = $&#123;catalina.base&#125;/logs3manager.org.apache.juli.AsyncFileHandler.prefix = manager.3manager.org.apache.juli.AsyncFileHandler.maxDays = 903manager.org.apache.juli.AsyncFileHandler.encoding = GBK4host-manager.org.apache.juli.AsyncFileHandler.level = FINE4host-manager.org.apache.juli.AsyncFileHandler.directory = $&#123;catalina.base&#125;/logs4host-manager.org.apache.juli.AsyncFileHandler.prefix = host-manager.4host-manager.org.apache.juli.AsyncFileHandler.maxDays = 904host-manager.org.apache.juli.AsyncFileHandler.encoding = GBKjava.util.logging.ConsoleHandler.level = FINEjava.util.logging.ConsoleHandler.formatter = org.apache.juli.OneLineFormatterjava.util.logging.ConsoleHandler.encoding = GBK


1catalina: 程序的输出，tomcat 的日志输出等
2localhost: 程序异常没有被捕获的时候抛出的地方
3manager: manager 项目专用
4host-manager: manager 项目专用


以上这几个配置初始可能是 UTF-8，而 Windows 控制台的编码通常是 GBK，为了正常显示，建议全部修改为 GBK。

]]></content>
  </entry>
  <entry>
    <title>基于 IDEA 的 Tomcat 部署启动</title>
    <url>/2022/10/13/Tomcat/%E5%9F%BA%E4%BA%8E-IDEA-%E7%9A%84-Tomcat-%E9%83%A8%E7%BD%B2%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[war模式：将web工程以war包的形式上传到服务器（需要在pom文件中设置打包方式为war (war)）war exploed模式：将web工程以当前文件夹的位置关系上传到服务器
]]></content>
  </entry>
  <entry>
    <title>数据文档生成器 screw</title>
    <url>/2022/07/18/Tool/%E6%95%B0%E6%8D%AE%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90%E5%99%A8-screw/</url>
    <content><![CDATA[数据文档生成器 screw相关链接https://github.com/yihr/screw
参考文章
maven 依赖&lt;dependency&gt;	&lt;groupId&gt;cn.smallbun.screw&lt;/groupId&gt;	&lt;artifactId&gt;screw-core&lt;/artifactId&gt;	&lt;version&gt;1.0.3&lt;/version&gt;&lt;/dependency&gt;

JUnit 生成@SpringBootTestpublic class DBDocument &#123;    @Autowired    DataSource dataSource;    @Test    public void contextLoads() &#123;        // 生成文件配置        EngineConfig engineConfig = EngineConfig.builder()            /* 生成文件路径，本地路径 */            .fileOutputDir(&quot;D:/&quot;)            /* 是否打开输出的目录 */            .openOutputDir(true)            /* 文件类型 */            .fileType(EngineFileType.HTML)            /* 生成模板实现 */            .produceType(EngineTemplateType.freemarker)            .build();        // 生成文档配置（包含以下自定义版本号、描述等配置连接）        Configuration config = Configuration.builder()            .version(&quot;1.0.0&quot;)            .description(&quot;数据库文档&quot;)            .dataSource(dataSource)            .engineConfig(engineConfig)            .produceConfig(getProcessConfig())            .build();        // 执行生成        new DocumentationExecute(config).execute();    &#125;    /**     * 配置想要生成的表 + 配置想要忽略的表     *      * @return     */    public static ProcessConfig getProcessConfig() &#123;        return ProcessConfig.builder()            .build();    &#125;&#125;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>screw</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 笔记</title>
    <url>/2022/07/20/VersionControl/Git-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[官方网址
https://git-scm.com/
https://git-scm.com/book/zh/v2/
使用前的准备配置用户信息
项目配置优先生效，如果没有项目配置，则使用全局配置。
服务器 Git裸仓库搭建
常用命令Getting and Creating Projectsclonegit clone &lt;repository&gt;克隆仓库。默认克隆全部分支。
git clone -b &lt;branch&gt; &lt;repository&gt; &lt;dirname&gt;指定克隆某个分支。如果只需要一个分支，可以使用此命令，减少 clone 时间。
执行了这条命令之后自动在当前文件夹下初始化本地库且克隆了远程库，提供了一个名为 origin 的指向远程库的别名。
注意：(1) windows 的凭据管理器会记住你的登录信息并不再需要登录，因此在同一机器上想要达到不同角色 push 的效果时需注意。(2) 通过添加 -b 参数可以指定克隆的分支。long style: –branch(3) dirname 表示生成的本地文件夹名称，默认为仓库名
Branching and Mergingbranch可以简写为 git branch，列出本地存在的分支。当前分支会以绿色高亮并带 * 前缀。short style: git branch -l
git branch --remote列出远程分支，short style: git branch -r
git branch --all列出所有分支，short style: git branch -a
git branch --list &lt;pattern&gt;使用 shell 通配符列出 branch，pattern 可以传入多个，它们之间是 “或” 关系，即匹配任意一个即可。
git branch -d &lt;branch&gt;删除分支。或者：git branch -D &lt;branch&gt;
git branch -m &lt;oldbranch&gt; &lt;newbranch&gt;重命名分支。如果  已经存在，需要使用 -M 强制。
git branch --set-upstream-to=&lt;远程主机&gt;/&lt;远程分支&gt; &lt;本地分支&gt;reset撤销 addeditgit add frotz.c filfre.cgit reset 

你愉快地在做某件事，发现这些文件的更改都完成了。你不想在 git diff 看到他们，因为你打算操作别的文件了，这些文件的更改可能会干扰你的注意力。
有人让你 pull，这些更改听起来值得合并
但是，你已经弄脏了 index（例如，你的 index 并不匹配 HEAD commit）。但你知道，你打算 pull 的操作并不会影响 frotz.c 或者 filfre.c，因此你 revert 对这两个文件索引的更改。在工作树中你的更改仍然存在。
然后，你可以 pull 且 merge，frotz.c 和 filefre.c 的更改仍然在工作树

&amp;nbsp;
remote管理被跟踪仓库的设置

git remote [-v | --verbose]

查看所有的别名。
-v | –verbose 表示显示更详细内容。

git remote add &lt;别名&gt; &lt;地址&gt;

给远程库添加别名。

git remote rename &lt;old&gt; &lt;new&gt;

将名为 &lt;old&gt;  的 remote 重命名为 &lt;new&gt;。更新所有远程跟踪分支和配置设置。

git remote remove &lt;name&gt;

删除名为 &lt;name&gt; 的 remote。所有 跟踪的 remote 分支和配置设置都会被删除。
&amp;nbsp;
checkoutgit checkout &lt;branch&gt;切换分支。
情况一  是本地已存在的分支。立即切换，保留工作树的改动。
情况二  本地不存在，远程不存在。从远程拉取分支，并切换，保留工作树的改动。
情况三  本地和远程都不存在。git 会将  识别为一个本地文件或文件夹，此时 git 会丢弃该文件当前工作树上所有的改动（危险！！！）。用法：git checkout . 可以以当前所在目录为根，递归丢弃当前文件夹下所有改动。
git checkout -b &lt;branch&gt;等价于 git branch &lt;branch&gt; + git checkout &lt;branch&gt;，但如果  已经存在，则会报错，因为 git branch &lt;branch&gt; 不允许创建重名分支。
git checkout -B &lt;branch&gt;情况一 如果  不存在，则创建并切换。情况二 如果  存在，则将  重置为当前分支的状态，切换，工作树保留。（危险！！！）
将 dev 分支的某个文件改动合并到 master# 切换到 mastergit checkeout master# 进入手选模式git checkout --patch dev 要合并的文件路径



rmgit rm --cached &lt;file&gt;删除文件缓存。可以将已经被 git 跟踪，但从此不想被跟踪的文件进行缓存删除。
git rm -r --cached &lt;dir&gt;删除文件夹缓存。可以将已经被 git 跟踪，但从此不想被跟踪的文件进行缓存删除。-r 代表递归，用于文件夹。
删除一个 maven 项目下所有 target 文件夹的跟踪：
git rm --cache -r --ignore-unmatch */target


Administrationclean删除所有未跟踪的文件
git clean -d -f

stashgit stash创建储藏
git stash list查看贮藏
git stash apply使用贮藏。默认使用最近的一个，如果要指定最近的第二个，则 git stash apply stash@&#123;2&#125;
config修改 git log 显示格式
# 本地仓库格式修改git config log.date &quot;format:%Y-%m-%d %H:%M:%S&quot;git config log.date iso8601git config log.date short # 只显示日期# 修改全局样式git config --global log.date &quot;format:%Y-%m-%d %H:%M:%S&quot;git config --global log.date iso8601git config --global log.date short # 只显示日期




凭证存储官方文档
凭证存储涉及到免密登录
IDE 的使用Eclipse 如何给没有 git 版本控制的项目添加版本控制？
Github 访问慢https://blog.csdn.net/qq_45921491/article/details/115977828
]]></content>
      <tags>
        <tag>Version Control</tag>
      </tags>
  </entry>
  <entry>
    <title>GitLab 使用笔记</title>
    <url>/2022/09/22/VersionControl/GitLab-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[参考文档https://docs.gitlab.com/runner/register/
https://docs.gitlab.com/ee/ci/yaml/gitlab_ci_yaml.html
Docker 安装异步启动
sudo docker run \    --detach \    --hostname gitlab.mczaiyun.top \    --publish 443:443 \    --publish 80:80 \    --publish 222:22 \    --name gitlab \    --restart always \    --volume /srv/gitlab/config:/etc/gitlab \    --volume /srv/gitlab/logs:/var/log/gitlab \    --volume /srv/gitlab/data:/var/opt/gitlab \    gitlab/gitlab-ce:latest

–detach   后台运行–hostname 指定服务域名–publish 映射端口–name gitlab–restart 自动重启，docker 启动的时候，容器也会跟着启动–volume 目录映射
默认账号 root，默认密码存放在 /etc/gitlab/initial_root_password，该文件有时效性，需要及时修改
sudo docker run \    -d \    --name gitlab-runner \    --restart always \    -v /srv/gitlab-runner/config:/etc/gitlab-runner \    -v /var/run/docker.sock:/var/run/docker.sock \    gitlab/gitlab-runner:latest




Gitlab 修改 root 初始密码且忘记密码# gitlab-rails console -e production  irb(main):003:0&gt; User.all =&gt; #&lt;ActiveRecord::Relation [#&lt;User id:1 @root&gt;]&gt; irb(main):004:0&gt; user=User.where(id:1).first =&gt; #&lt;User id:1 @root&gt; irb(main):008:0&gt; user.password=&#x27;12345678&#x27; =&gt; &quot;12345678&quot; irb(main):009:0&gt; user.password_confirmation=&#x27;12345678&#x27; =&gt; &quot;12345678&quot; irb(main):010:0&gt; user.save! =&gt; true

Docker 容器中修改 Gitlab 的 hostname
关闭 docker

进入容器的配置文件夹，修改 config.v2.json、hostname、hosts 文件


]]></content>
  </entry>
  <entry>
    <title>SVN 使用笔记</title>
    <url>/2022/09/28/VersionControl/SVN-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[忽略文件（夹）svn pg svn:ignoresvn ps svn:ignore &#x27;value&#x27; path]]></content>
  </entry>
  <entry>
    <title>VirtualBox CentOS 设置静态 IP</title>
    <url>/2022/09/26/Virtualization/VirtualBox-CentOS-%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81-IP/</url>
    <content><![CDATA[参考指引https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html-single/networking_guide/index#sec-Configuring_IP_Networking_with_ifcg_Files
关于 PREFIX 和 NETMASK https://forums.centos.org/viewtopic.php?t=45322
步骤可选步骤如果你使用 Host-Only 网卡模式，打开主机网络管理器，配置适配器:


点击创建新的适配器:



创建完毕之后，宿主机的适配器也会产生新的项目:



配置相关的属性，比如手动配置适配器的 IP 地址，子网掩码，DHCP 服务器等: 



此处可以不启用 DHCP 服务，因为虚拟机选择的是静态 IP

关键步骤
编辑网卡配置文件

vim /etc/sysconfig/network-scripts/ifcfg-eth1


需要确认自己 Host-Only 的网卡文件是哪一个，然后编辑它


编辑配置

DEVICE=eth1BOOTPROTO=staticONBOOT=yesPREFIX=24IPADDR=192.168.101.101


比如上图的适配器是 192.168.101.1，为了让虚拟机和宿主机在同一个网段，我们也需要配置相同网段的 IPADDR
仅需要上面这几个配置就足够了



重启 network 服务

systemctl restart network]]></content>
      <tags>
        <tag>Virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue CLI 笔记</title>
    <url>/2022/11/15/Vue/Vue-CLI-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[参考引用官方文档
1. 安装
首先你需要具有 npm

# 查看版本vue --version# Vue CLI 2+npm install -g vue-cli# Vue CLI 3+npm install -g @vue/cli

2. 创建项目# Vue CLI 2+vue init webpack project-name# Vue CLI 3+vue create my-project

vue.config.js跨域 proxy
将 /api/user 代理到 http://localhost:3000/api/user

module.exports = &#123;  devServer: &#123;    proxy: &#123;      &#x27;/api&#x27;: &#x27;http://localhost:3000&#x27;    &#125;  &#125;&#125;;


将 /api/user 代理到 http://localhost:3000/user

适用于不同接口的处理，如 api、file
module.exports = &#123;  devServer: &#123;    proxy: &#123;      &#x27;/api&#x27;: &#123;        target: &#x27;http://localhost:3000&#x27;,        pathRewrite: &#123;&#x27;^/api&#x27; : &#x27;&#x27;&#125;      &#125;    &#125;  &#125;&#125;;

]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 打包部署脚本</title>
    <url>/2022/07/18/Vue/Vue-%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[Vue 打包部署脚本环境准备npm install --save-dev scp2 cross-env ora@4.1.1 chalk

配置文件const scpClient = require(&#x27;scp2&#x27;);      // 基于ssh2的纯javascript安全复制程序const ora = require(&#x27;ora&#x27;);             // 一个优雅的 Node.js 终端加载动画效果const chalk = require(&#x27;chalk&#x27;);         // 字体颜色插件const spinner = ora(&#x27;正在发布到 &#x27; + process.env.NODE_ENV + &#x27; 服务器...\n&#x27;);spinner.start();const SERVER_LIST = &#123;    &#x27;development&#x27;: &#123;        hostname: &#x27;0.0.0.0&#x27;,            // ip        port: 22,                       // 端口        username: &#x27;root&#x27;,               // 登录服务器的账号        password: &#x27;xxx&#x27;,                // 登录服务器的账号        path: &#x27;/opt/www&#x27;                // 发布至静态服务器的项目路径    &#125;,    &#x27;production&#x27;: &#123;        hostname: &#x27;0.0.0.0&#x27;,      // ip        port: 22,                       // 端口        username: &#x27;root&#x27;,               // 登录服务器的账号        password: &#x27;xxx&#x27;,                // 登录服务器的账号        path: &#x27;/opt/www&#x27;                // 发布至静态服务器的项目路径    &#125;,&#125;;// 如果是公钥认证在这里创建私钥文件const path = &#x27;C:\\Users\\Administrator\\.ssh\\id_rsa&#x27;const privateKey = require(&#x27;fs&#x27;).readFileSync(path).toString()const server = SERVER_LIST[process.env.NODE_ENV];scpClient.scp(    &#x27;dist/&#x27;,    &#123;        host: server.hostname,        port: server.port,        username: server.username,        password: server.password,        privateKey,        path: server.path    &#125;,    function (err) &#123;        spinner.stop();        if (err) &#123;            console.log(chalk.red(&#x27;发布失败.\n&#x27;));            throw err;        &#125; else &#123;            console.log(chalk.green(&#x27;Success! 成功发布到&#x27; + process.env.NODE_ENV + &#x27;服务器! \n&#x27;));        &#125;    &#125;);


package.json
&quot;scripts&quot;: &#123;  &quot;build&quot;: &quot;vue-cli-service build&quot;,  &quot;deploy&quot;: &quot;npm run build &amp;&amp; cross-env NODE_ENV=development node ./deploy&quot;&#125;,
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-codemirror 笔记</title>
    <url>/2022/11/15/Vue/vue-codemirror-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[参考引用https://www.npmjs.com/package/vue-codemirror
https://github.com/surmon-china/vue-codemirror/tree/v4.0.6
安装默认下载是最新版本只支持Vue3
# 支持 Vue2npm install vue-codemirror@4.0.6


使用main.js 导入
import VueCodemirror from &#x27;vue-codemirror&#x27;// import base styleimport &#x27;codemirror/lib/codemirror.css&#x27;Vue.use(VueCodemirror)




options
autoCloseBrackets

能够自动输入另一个右括号
import &quot;codemirror/addon/edit/closebrackets.js&quot;;


foldGutter

是否折叠

gutters

翻译是沟，其实就是显示行号的那一列。类型数组，按照定义的顺序显示。如:
gutters: [&#x27;CodeMirror-foldgutter&#x27;, &#x27;CodeMirror-linenumbers&#x27;, &#x27;CodeMirror-lint-markers&#x27;],

将会按照折叠箭头、行号、提示的顺序显示。

indentUnit

缩进空格量。默认: 2

lineNumbers

是否显示行号。true | false

lineWrapping

宽度不够是否换行。如果为 false，codemirror 将会显示滚动条。

lint

是否错误提示。

mode

支持的语言: https://codemirror.net/5/mode/
设置 codemirror 的语言
application&#x2F;json

matchBrackets

当光标在括号周围时，能够高亮匹配的两个括号
import &quot;codemirror/addon/edit/matchbrackets.js&quot;;


theme

主题，需要引入相应的文件，如:
import &#x27;codemirror/theme/xq-light.css&#x27;



主题可以从以下两个链接查看默认提供的主题。
https://codemirror.net/demo/theme.html
https://www.codenong.com/cs106429772/
问题修改字体?默认是 monospace
找到 codemirror.css 中 
.CodeMirror &#123;    /* Set height, width, borders, and global font properties here */    font-family: monospace;    height: 300px;    color: black;&#125;

然后添加自定义字体:
.CodeMirror &#123;    /* Set height, width, borders, and global font properties here */    font-family: Consolas, monospace;    height: 300px;    color: black;&#125;


代码折叠// 支持各种代码折叠import &quot;codemirror/addon/fold/foldgutter.css&quot;;import &quot;codemirror/addon/fold/foldcode.js&quot;;import &quot;codemirror/addon/fold/foldgutter.js&quot;;import &quot;codemirror/addon/fold/brace-fold.js&quot;;import &quot;codemirror/addon/fold/comment-fold.js&quot;;]]></content>
  </entry>
  <entry>
    <title>Maven 笔记</title>
    <url>/2022/09/08/maven/Maven-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[Maven 笔记Maven 是什么官方介绍 What is  Maven?
Maven 是 Apache 软件基金会唯一维护的一款【自动化构建工具】。专注于 Java 平台的【项目构建】和【项目管理】
InheritanceMaven 为构建管理带来的强大的额外特性就是项目继承 (Inheritance) 的概念。
对于父工程和聚合 (多模块) 工程，packaging 类型必须是 pom。这些类型定义了绑定到一组生命周期阶段的目标。例如，如果 packaging 是 jar, 那么 package 阶段就会执行 jar:jar 目标。
请注意 relativePath 元素。它不是必需的，但是它可以作为一个指示器，告诉 Maven 在搜索本地以及远程仓库之前，首先搜索该工程的父工程给定的路径。

个人感觉 relativePath 使用场景很小

构建项目的主要环节
clean：清理，删除以前的编译结果
compile：编译，将 Java 源程序编译为字节码
test：对项目进行测试
package：将项目进行打包，以 jar 或 war 格式。
install：将打包的结果 jar 或者 war 安装到本地仓库。
deploy：将打包的结果部署到远程仓库或者 war 包部署到服务器上运行

Maven 常用命令mvn -version / mvn -v 显示版本信息mvn clean 清理mvn compile 编译mvn test 编译并测试mvn package 生成 target 目录，编译、测试代码，生成测试报告，生成 jar&#x2F;warmvn site 生成项目相关信息的网站mvn clean compile 清理之后编译mvn clean package 清理之后打包mvn clean install 清理之后安装mvn clean deploy 清理之后发布
依赖依赖的范围依赖范围 &lt;scope&gt; 控制哪些依赖在哪些 classpath 中可用，哪些依赖包含在一个应用中。
【compile】默认的范围；编译范围依赖在所有的 classpath 中可用，同时它们也会被打包。
【provided】provided 依赖只有在当 JDK 或者一个容器已提供该依赖之后才使用。例如， 如果你开发了一个web 应用，你可能在编译 classpath 中需要可用的 Servlet API 来编译一个 servlet，但是你不会想要在打包好的 WAR 中包含这个Servlet API；这个Servlet API JAR 由你的应用服务器或者servlet 容器提供。已提供范围的依赖在编译classpath （不是运行时）可用。它们不是传递性的，也不会被打包。
或者还有 lombok 的使用，打包完毕之后便不再需要包含这个 API。
【runtime】 runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要JDBC API JAR，而只有在运行的时候才需要JDBC 驱动实现。
【test】 test范围依赖 在一般的编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。
【system】 system范围依赖与provided类似，但是你必须显式的提供一个对于本地系统中JAR文件的路径。这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。这样的构建应该是一直可用的，Maven 也不会在仓库中去寻找它。如果你将一个依赖范围设置成系统范围，你必须同时提供一个systemPath元素。注意该范围是不推荐使用的（建议尽量去从公共或定制的 Maven 仓库中引用依赖）。
【import】 import 仅支持在 &lt;dependencyManagement&gt; 中的类型依赖项上。该选项可以用来解决 Maven 的单继承。
通常，我们会使用 spring-boot-starter-parent 作为项目的父工程，因为其中进行了很多版本管理，同时我们也希望引入其他版本管理的工程，如 spring-cloud、spring-cloud-alibaba。
&lt;dependencyManagement&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;            &lt;version&gt;Hoxton.SR1&lt;/version&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;scope&gt;import&lt;/scope&gt;        &lt;/dependency&gt;&lt;/dependencyManagement&gt;


&lt;version&gt;
&lt;parent&gt; 标签下的 &lt;version&gt;

Snapshot版本代表不稳定、尚处于开发中的版本  Release版本则代表稳定的版本如果 deploy 到远程服务器 如果是 release 只能 deploy 一次，以后部署的话，就会报错冲突，因为是稳定版但是如果是 snapshot 的话，你可以 deploy 多次，每一次都会冲掉原来的版本，表示不稳定

&lt;dependency&gt; 下的 &lt;version&gt;

显式设置依赖的版本
&lt;dependencyManagement &gt;Maven 使用 dependencyManagement 元素来提供一种管理依赖版本的方式。通常会在一个组织或项目的最顶层的父 POM 中看到。
使用 pom.xml 中的 &lt;dependencyManagement &gt; 能让所有在子项目中引用一个依赖而不用显式地写 &lt;version&gt;，Maven 会沿着父子层次向上找，直到找到一个拥有 dependencyManagement 元素的项目，然后它就会使用这个版本号。
dependencyManagement 只是声明依赖，并不引入依赖，因此子项目需要显式进行依赖引入。
&lt;optional&gt;表示在使用该库的时，此依赖是可选的。如果该库在其他地方被使用，则此依赖的版本将被考虑到依赖计算中，但它不会被传递。注意：由于技术原因，这个字段的类型是 String，但语义类型实际上是 Boolean。默认值为 false。

常用的有 spring-boot-devtools

]]></content>
  </entry>
  <entry>
    <title>获取用户 IP</title>
    <url>/2022/07/28/%E6%9D%82%E9%A1%B9/%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7-IP/</url>
    <content><![CDATA[function getIp()&#123;	$ips = array();	if ($_SERVER[&#x27;HTTP_CLIENT_IP&#x27;]) &#123;		$ips[] = $_SERVER[&#x27;HTTP_CLIENT_IP&#x27;];	&#125;	if ($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]) &#123;		$tmp = explode(&#x27;, &#x27;, $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]);		$ips = array_merge($ips, $tmp);	&#125;	if ($_SERVER[&#x27;REMOTE_ADDR&#x27;]) &#123;		$ips[] = $_SERVER[&#x27;REMOTE_ADDR&#x27;];	&#125;	$ip = &#x27;&#x27;;	foreach ($ips as $k =&gt; $v) &#123;		if(!preg_match(&#x27;/^(10|172\.16|192\.168)\./&#x27;, $v) &amp;&amp; strtolower($v) != &#x27;unknown&#x27;) &#123;			$ip = $v;			break;		&#125;	&#125;	return $ip;&#125;
]]></content>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2022/07/16/%E6%9D%82%E9%A1%B9/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[设计模式参考图解设计模式
1. Iterator 模式2. Adapter 模式Adapter 模式也被称为 Wrapper 模式。
Adapter 模式角色
Target

该角色负责定义所需的方法。

Adaptee（被适配者）

Adaptee 是一个持有既定方法的角色

Adapter（适配器）

Adapter 模式的主人公。使用 Adaptee 的方法来满足 Target 的需求。在类适配器模式中，Adapter 通过继承来使用 Adaptee；在对象适配器模式中，Adapter 通过委托来使用 Adaptee 角色。
适配器和被适配者并不需要继承相同的抽象类或接口。

如果在类适配器模式中，会让适配器实现被适配者，但似乎不如对象适配器的委托优雅。

例子


适配器
被适配者



InputStreamReader
InputStream 系列


OutputStreamWriter
OutputStream 系列


FutureTask
Runnable



由于 InputStream 和 OutputStream 只能输入&#x2F;输出字节，需要经过一个适配过程，将字节转换为字符，这就是适配器模式。

7. Abstract Factory 模式父类决定实例的生成方式，但不决定所要生成的具体的类，具体的处理全部交给子类负责。
FileSystemProvider.newInputStream 用于生成文件  InputStream，底层依赖于 FileSystemProvider，可能是 WindowsFileSystem 也可能是 ZipFileSystem。类似 Abstract Factory 的变体。
11. Decorator 模式装饰器（Decorator）模式 可以在不改变原有对象的情况下拓展其功能。
Decorator 模式中的角色
Component

增加功能时的核心角色

ConcreteComponent

实现了 Component 角色所定义的接口

Decorator

该角色具有与 Component 相同的接口，内部保存了被装饰的对象。

ConcreteDecorator

具体的 Decorator 角色
以 Java IO 库来说，InputStream 和 OutputStream 扮演 Component 角色。
FilterInputStream 和 FilterOutputStream 扮演 Decorator
对于字节流来说， FilterInputStream （对应输入流）和 FilterOutputStream（对应输出流）是装饰器模式的核心，分别用于增强 InputStream 和OutputStream 子类对象的功能。
我们常见的 BufferedInputStream、DataInputStream 等等都是FilterInputStream 的子类，BufferedOutputStream、DataOutputStream 等等都是 FilterOutputStream 的子类。
从 BufferedInputStream 的构造器参数也可以知道，传入一个 InputStream 对象，进而装饰。
public BufferedInputStream(InputStream in, int size) &#123;    super(in);    if (size &lt;= 0) &#123;        throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;);    &#125;    buf = new byte[size];&#125;

21. Proxy 模式Proxy 模式中的角色在 Proxy 模式中一般有以下角色：

Subject（主体）

Subject 定义了使 Proxy 和 RealSubject 之间具有一致性的接口。

Proxy（代理人）

Proxy 会尽量处理来自外界的请求。当自己不能处理时，才会将工作交给 RealSubject。Proxy 也要实现 Subject 定义的接口。

RealSubject（实际主体）

RealSubject 会在 Proxy 无法胜任工作时出场。它也会实现 Subject 接口。
Proxy 模式变体
Virtual Proxy（虚拟代理）Virtual Proxy 就是上面呈现的 Proxy 模式。当真正需要 RealSubject 时，才生成和初始化实例。

Remote Proxy（远程代理）Remote Proxy 可以让我们不必在意 RealSubject 是否在远程网络上，透明地使用它的功能。Java 的 RMI（Remote Method Invocation：远程方法调用）就相当于 Remote Proxy。

Access ProxyAccess Proxy 用于限制 RealSubject 的功能访问。例如，这种代理只允许访问特定的方法，当访问其他方法时则报错。


]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2022/07/24/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[冒泡排序public void sort() &#123;    for (int i = 0; i &lt; arr.length; i++) &#123;        for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123;            if (arr[j] &gt; arr[j + 1]) &#123;                // 交换            &#125;        &#125;    &#125;&#125;


归并排序public class MergeSorter &#123;    public static void main(String[] args) &#123;        MergeSorter mergeSorter = new MergeSorter(new int[]&#123;3, 1, 4&#125;);        mergeSorter.sort();        System.out.println(Arrays.toString(mergeSorter.getArr()));    &#125;    private final int[] arr;    public MergeSorter(int[] arr) &#123;        this.arr = arr;    &#125;    public int[] getArr() &#123;        return arr;    &#125;    public void sort() &#123;        doSort(0, arr.length - 1);    &#125;    private void doSort(int left, int right) &#123;        if (left == right) &#123;            return;        &#125;        doSort(left, (left + right) / 2);        doSort((left + right) / 2 + 1, right);        merge(left, (left + right) / 2, right);    &#125;    private void merge(int left, int middle, int right) &#123;        // 两个元素        if (right - left == 1 &amp;&amp; arr[left] &gt; arr[right]) &#123;            int tmp = arr[left];            arr[left] = arr[right];            arr[right] = tmp;            return;        &#125;        int[] merged = new int[right - left + 1];        // merged 数组的指针        int mergedPoint = 0;        int leftPoint = 0; // left 指针        int rightPoint = middle + 1; // right 指针        while (leftPoint &lt;= middle &amp;&amp; rightPoint &lt;= right) &#123;            int value;            if (arr[leftPoint] &lt;= arr[rightPoint]) &#123;                value = arr[leftPoint++];            &#125; else &#123;                value = arr[rightPoint++];            &#125;            merged[mergedPoint++] = value;        &#125;        while (leftPoint &lt;= middle) &#123;            merged[mergedPoint++] = arr[leftPoint++];        &#125;        while (rightPoint &lt;= right) &#123;            merged[mergedPoint++] = arr[rightPoint++];        &#125;        System.arraycopy(merged, 0, arr, left, merged.length);    &#125;&#125;
]]></content>
  </entry>
  <entry>
    <title>数据结构——二叉树</title>
    <url>/2022/07/24/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[数据结构——二叉树树的递归遍历递归遍历框架代码清单如下：

也就是一个递归框架

/* ⼆叉树遍历框架 */void traverse(TreeNode root) &#123;    // 前序遍历    traverse(root.left)    // 中序遍历    traverse(root.right)    // 后序遍历&#125;
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ 学习笔记</title>
    <url>/2022/07/22/%E9%9D%A2%E8%AF%95/MQ-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[MQ 学习笔记1. 使用场景
异步
解耦
削峰

异步提高系统的响应速度、吞吐量。
场景一 异步处理播放记录
空中课堂有很多点播模块，如：名师讲堂、抗议助学、互动课堂、同步课堂、家长课堂、苏e优课等。
通常这些模块需要：

记录观看的用户信息
自增对应模块表的观看量
维护旧数据表的观看量（逻辑未完全迁移）
维护大屏统计表的数据量
……

以上这一系列操作的业务可能有一定耗时（操作的数据库表较多），但对用户来说响应结果并不重要，使用 MQ 异步处理。
解耦场景一 VOD 的任务流
VOD 用户上传的视频可能需要转码、截取封面图，这些操作不可能同步，通常会在视频上传之后开启一个任务流分步处理，并将结果回调给特定的地址。
扩展：通常 VOD 提供了两组通知模式，回调+主动拉取，回调并不可靠，可能会因为跨网络的原因导致消息丢失；通常选择可靠回调，定时主动拉取事件集，并在处理之后给出确认响应。
场景二 企微事件回调
在企微的人员架构变动之后，后台会接收到回调事件，接收事件的服务可能只是一个统计入口服务，比如自建代开发应用事件回调服务、第三方应用事件回调服务，并不希望将这些回调事件的处理逻辑混合到这些系统中，可以推送到 MQ 中供其他服务进行使用。
削峰场景一 校园安全人脸捕捉削峰
门禁机设备推送抓拍信息（回调接口），如果返回错误码，或者网络原因超时（可配置），会一直重试。

一定程度确保了消息不丢失

这样可能会导致门禁机在网络不通的情况下一直调用，所以一般会取消离线发送。
离线发送：设备注册失败 or 心跳不正常，取消推送抓拍信息，直到恢复。
上述场景可能有个问题：学校整体网络都有问题，抓拍的图片堆积太多，如果等待网络恢复，瞬间发送大量的包含 base64 等信息的抓拍信息，会导致服务器压力较大！
引入 MQ，将 Capture 的信息先推送到消息队列，异步地匀速处理。
2. 如何保证消息幂等RocketMQ 包含了一个 MessageID，但是消息多的情况下未必唯一。
自己带一个有业务标识的 MessageID
3. 消息有序全局有序、局部有序：MQ 只需要保证局部有序
]]></content>
  </entry>
  <entry>
    <title>Redis 分布式锁</title>
    <url>/2022/11/10/%E9%9D%A2%E8%AF%95/Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[分布式锁的实现尝试获得锁使用 SETNX 命令，key 可以认为是锁的名字，value 是每个操作者持有的唯一值。

锁的名字应该是一个约定好的共识。

&gt; SETNX lockKey uniqueValue(integer) 1&gt; SETNX lockKey uniqueValue(integer) 0

第一个执行 SETNX 的请求可以拿到锁。后面的请求都因为 key 已经存在而无法获得锁。
光是 SETNX 是不够的，还需要给锁设置一个过期时间，防止某些原因请求线程无法释放锁，因此，通常使用以下方法:
&gt; SET lockKey uniqueValue EX 3 NXOK


释放锁就是 DEL 对应的 key。
&gt; DEL lockKey(integer) 1

通常使用 Lua 脚本保证释放锁的原子性。因为 Redis 在执行 Lua 脚本时，是原子性的。
// 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放（防止释放了别人的锁）// 避免误释放的前提是 value 唯一性if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then    return redis.call(&quot;del&quot;,KEYS[1])else    return 0end



设置过期时间又会引入一个问题，如果业务时间大于锁过期时间，产生锁提前过期（释放）问题，此时其他请求可以获得锁。
解决方法: 锁续约。Redission
]]></content>
  </entry>
  <entry>
    <title>InnoDB 日志</title>
    <url>/2022/10/08/Database/MySQL/InnoDB%20%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[参考文献解析 roll_pointer
庖丁解牛 
InnoDB之UNDO LOG介绍
Undo LogsUndo Log 是一条或者多条 Undo Log Record 的集合，每一条 Undo Log Record 都与一个读写事务相关。每条 Undo Log 记录包含了有关如何撤销事务最新更改的信息[?]。
1. Undo TablespacesUndo Tablesapces 包含许多 Undo Log。

MySQL 最多支持 127 个 Undo Tablespace。默认为 2 个。

InnoDB 是一个多版本的存储引擎。它可以保留有关更改行的旧版本的信息，以支持事务功能，例如并发和回滚。此信息以一个称为回滚段的数据结构，存储于 undo 表空间。回滚段驻留在 undo 表空间和全局临时表空间中[1]。



2. Rollback SegmentInnoDB 在 Undo Tablespace 中使用 Rollback Segment 来组织 Undo Log，最多支持 128 个 Rollback Segment。
其中第 0 号、33-127号针对普通表设计，1-32 号针对临时表设计。

一个事务可能即操作了临时表，也操作了物理表，因此，一个事务是可以使用多个 Rollback Segment。

3. Rollback Segment Array HeaderUndo Tablespace 文件中的第 3 个 Page 固定作为这 128 个 Rollback Segment 的目录，即 Rollback Segment Array Header
4. Rollback Segment Header通过 Rollback Segment Header 来管理 Rollback Segment，Rollback Segment Header 通常在 Rollback Segment 第 1 页。





字段
说明



Max Size
参数名 TRX_RSEG_MAX_SIZE， 回滚段可用的最大 Page 数


History Size
参数名 TRX_RSEG_HISTORY_SIZE，History List 包含的 Page 数


History List Base Node
参数名 TRX_RSEG_HISTORY


History List 把所有已经提交，但还没有被 purge 的事务的 Undo Log 连接起来，purge 线程可以通过此 List 对已经没有事务使用的 Undo Log 进行 purge。
每个事务在需要记录 Undo Log 时都会申请 1 个或者 2 个 Slot（INSERT 和 UPDATE 分开），同时把事务的第一个 Undo Page 放入对应 Slot 中
5. Undo PageUndo Page 一般可以分为两种：Header Page 和 Normal Page。



Undo Header Page 是事务需要写 Undo Log 时申请的第一个 Undo Page
Undo Header Page 是当活跃事务产生的 Undo Record 超过 Undo Header Page 容量后，单独分配的 Undo Page
6. Undo Page Header




字段
说明



Undo Page Type
TRX_UNDO_PAGE_TYPE，使用该页事务的类型可选值: TRX_UNDO_INSERT、TRX_UNDO_UPDATE


Latest Log Record Offset
最新事务开始记录 Undo Log 的位置


Free Space Offset
页内空闲空间起始地址，在此之后可记录 Undo Log


Undo Page List Node
undo page list节点，可以把同一个事务所用到的所有undo page双向串联起来


6. Undo SegmentInnoDB 中的 Undo Tablespace 中准备了大量的 Undo Segment 槽位，默认按照 1024 一组划分为 Rollback Segment。

每个 Undo Tablespace 最多会包含128 个 Rollback Segment。1 个 Undo Slot 对应 1 个 Undo Segment

每个写事务开始写操作之前都需要持有一个 Undo Segment。在任何时刻，每个 Undo Segment 都是被一个事务独占的。
对于较大的 Undo Log 随着不断地写入，按需分配足够多的 Undo Page 分散承载。
每个 Undo Segment  至少持有 1 个 Undo Page，每个 Undo Page 会在开头 38 - 56 字节记录 Undo Page Header。

Rollback Segment 中 Undo Slot 具体的数值是 $\frac {Page Size}{16}$，见15.6.6 Undo Logs。因为默认 Page Size &#x3D; 16 KB，因此默认以 1024 一组划分为一个 Rollback Segment。

7. Undo Segment HeaderUndo Segment 中的第 1 个 Undo Page 还会在 56~86 字节记录 Undo Segment Header。





字段
说明



State
TRX_UNDO_STATE，Undo Segment 的状态


Last Log Offset
TRX_UNDO_LAST_LOG，当前页最后一个 Undo Log Header 的位置


Undo Segment FSEG Entry
TRX_UNDO_FSEG_HEADER，segment对应的inode的（space_id，page_no，offset等）


Undo Segment Page List Base Node
TRX_UNDO_PAGE_LIST,undo page list的Base Node，对于同一个事务下的undo header page和undo normal page构成双向链表


TRX_UNDO_PAGE_LIST：对于一般事务来说，不会出现一页写不下的情况，所以，对于大多数事务该链表长度是 1。
在事务结束 (commit &#x2F; rollback) 的时候，会依次检查一些条件：
// trx_undo_set_state_at_finish()if (undo-&gt;size == 1 &amp;&amp; mach_read_from_2(page_hdr + TRX_UNDO_PAGE_FREE) &lt; TRX_UNDO_PAGE_REUSE_LIMIT) &#123;    // 如果占用 Page == 1，而且本页使用空间偏移量小于 3 / 4    // 那么，标记为 TRX_UNDO_CACHED    state = TRX_UNDO_CACHED;&#125; else if (undo-&gt;type == TRX_UNDO_INSERT) &#123;    // 如果类型为 INSERT    // 那么，标记为 TRX_UNDO_TO_FREE    state = TRX_UNDO_TO_FREE;&#125; else &#123;    // 最后就是类型为 UPDATE 而且占用空间较多    state = TRX_UNDO_TO_PURGE;&#125;

对于标记为 TRX_UNDO_CACHED 的 Undo Segment 会在 trx_undo_insert_cleanup &#x2F; trx_undo_update_cleanup 中添加到 insert cached list &#x2F; update cached list 头部。
对于 INSERT 类型的清理在 trx_commit_in_memory() 会直接释放掉标记为 TRX_UNDO_TO_FREE 的 Undo Segment。
UPDATE 类型的 Undo Segment 会等待 Purge 完毕回收。
8. Undo Log Header每个写事务会修改一些数据记录，对应产生一些 Undo Log Record。这些 Undo Log Record 连接在一起形成该事务的 Undo Log。这些 Undo Log Record 开头存在一个 Undo Log Header 记录一些信息。






字段
占用
说明



Transaction ID
8
事务 ID


Delete Mark
2
表示该 Undo Log 是否存在 TRX_UNDO_DEL_MARK_REC 类型的 Undo Log Record，避免 Purge 时不必要的扫描


Log Start Offset
2
记录 Undo Log Header 的结束位置，便于之后 Header 增加内容时的兼容


Next Undo Log
2
后一个 Undo Log


Prev Undo
2
前一个 Undo Log


8. Undo Log Record 结构主要分为两大类：

insert undo log record
update undo log record其中，update undo log record 还有其他更多的类别

8.1. Insert Undo Log RecordTRX_UNDO_INSERT_REC



TRX_UNDO_INSERT_REC
说明



next (2)
下一个 undo log 的位置


type_cmpl (1)
Undo 类型，TRX_UNDO_INSERT_REC: 11


Undo Number
在一个事务中从 0 开始递增


Table ID



Key Field 1 Length



Key Field 1 Content



…



Key Field n Length



Key Field n Content



start
undo 开始的位置



INSERT 操作的 undo log record 在事务提交后就可以删除

8.2. Update Undo Log Record该类别的 Undo Log Record 可以再分为三种：

TRX_UNDO_DEL_MARK_REC
TRX_UNDO_UPD_DEL_REC
TRX_UNDO_UPD_EXIST_REC

TRX_UNDO_UPD_EXIST_REC



字段
占用
说明



end of record
2
本页中，该记录的末尾偏移量。只有当记录完全写完才能写入，事先不知道大小。


type_cmpl
1
TRX_UNDO_UPD_EXIST_REC


undo_no

在一个事务中从 0 开始递增


table id

表 ID


info bits
1



trx_id
压缩
旧记录的 trx_id


roll_pointer
压缩
旧记录的 roll_pointer


clustered index 1 length

聚簇索引 1 长度


clustered index 1 value

聚簇索引 1 值


…
…
…


clustered index n length

聚簇索引 n 长度


clustered index n value

聚簇索引 n 值


n_updated

共有多少个列被更新了


len of index_col_info




索引列各列信息




start of record
2
本页中，该记录的起始偏移量


TRX_UNDO_DEL_MARK_REC



字段
占用
说明



end of record (2)




Type and Flags (1)

TRX_UNDO_DEL_MARK_REC


Undo Number

在一个事务中从 0 开始递增


Table ID




Info Bits




trx_id

旧记录的 trx_id


roll_pointer

旧记录的 roll_pointer


clustered index 1 length

聚簇索引 1 长度


clustered index 1 value

聚簇索引 1 值


…
…
…


clustered index n length

聚簇索引 n 长度


clustered index n value

聚簇索引 n 值


start of record




事务中 DELETE 仅将记录的 deleted_flag 标识设置为 1




当对每一条数据记录进行 delete mark 操作前，需要把该数据记录的 trx_id 和 roll_pointer 的旧值记录到 undo log record，再将 trx_id 和 roll_pointer 更新。





撤销日志是为了实现事务原子性而出现的产物。事务处理过程中，如果出现了错误或者用户执行了 rollback 语句，MySQL 可以利用 undo log 中的信息将数据恢复到事务开始之前的状态撤销日志在 MySQL InnoDB 存储引擎中还用来实现多版本并发控制。

在全局临时表空间中的 Undo Log 用于事务修改用户定义的临时表中的数据。这些 Undo Log 不会记录 Redo Log，因为崩溃恢复不需要它们。它们仅在服务器运行时用于回滚。这种类型的 Undo Log 通过避免 Redo 日志 I&#x2F;O 对性能有帮助。每个 undo 表空间和全局临时表空间最多支持 128 个回滚段。innodb_rollback_segments 变量定义了回滚段的数量。事务最多分配 4 个 undo 日志，每个对应下面的操作类型：

INSERT 用户定义的表
UPDATE 和 DELETE 用户定义的表
INSERT 用户定义的临时表
UPDATE 和 DELETE 用户定义的临时表根据需要分配 undo 日志。例如，执行常规表和临时表上的 INSERT，UPDATE，以及 DELETE 操作的事务需要完全分配 4 个 undo 日志；仅在常规表上执行 INSERT 操作的事务只需要 1 个 undo 日志。


如果每个事务执行 INSERT 或者 UPDATE 或者 DELETE 操作之一，那么 InnoDB 可以支持的并发独写事务数是：(innodb_page_size / 16) * innodb_rollback_segments * number of undo tablespaces
如果每个事务执行 INSERT 加上 UPDATE 或者 DELETE 操作之一，那么 InnoDB 可以支持的并发独写事务数是：(innodb_page_size / 16 / 2) * innodb_rollback_segments * number of undo tablespaces
如果每个事务都在临时表上执行 INSERT 操作，那么 InnoDB 可以支持的并发独写事务数是：(innodb_page_size / 16) * innodb_rollback_segments

Undo Log 分配当开启一个事务的时候，会调用 trx_assign_rseg_durable 分配一个 Rollback Segment。只读事务
trx_assign_rseg_temp();-&gt; get_next_temp_rseg();-&gt; trx_sys-&gt;tmp_rsegs
读写事务
trx_assign_rseg_durable() -&gt; get_next_redo_rseg()    -&gt;get_next_redo_rseg_from_trx_sys() -&gt; (trx_sys-&gt;rsegs)      get_next_redo_rseg_from_undo_spaces() -&gt; (undo_space-&gt;rsegs())
当 InnoDB 没有配置独立 Undo Tablespace 时， trx_sys-&gt;regs 为读写事务分配回滚段；否则从 undo_spaces-&gt;regs() 分配回滚段当第一次真正产生修改需要写 Undo Log Record 的时候，调用 trx_undo_assign_undo 来获得一个 Undo Segment
trx_undo_assign_undo(*trx. *undo_ptr, type) &#123;    /*     尝试获取缓存中可用的 Undo Log     1. 对于 type == TRX_UNDO_INSERT          从 rseg-&gt;insert_undo_cached 链表上获取 Undo Log 对象，并从链表移除          之后调用 trx_undo_insert_header_reuse 重新初始化 Undo Page Header     2. 对于 type == TRX_UNDO_UPDATE          从 rseg-&gt;update_undo_cached 链表上获取 Undo Log 对象，并从链表移除          之后调用 trx_undo_header_create 创建新的 Undo Log Header    */              undo = trx_undo_reuse_cached();    if (undo == nullptr) &#123;// 如果没有缓存的 Undo Log 对象，调用 trx_undo_create 从回滚段上分配一个空闲的 Undo Slot        trx_undo_create();    &#125;&#125;
Undo Log 写入1. 分配回滚段事务从调用 trx_start_low 函数开始。
当该事务被判定为读写模式时，会分配 TRX_ID 以及回滚段。
// 来自 trx_start_low 片段if (!trx-&gt;read_only &amp;&amp;      (trx-&gt;mysql_thd == nullptr || read_write || trx-&gt;ddl_operation)) &#123;    // 分配 Rollback Segment    trx_assign_rseg_durable(trx);    // 分配 TRX_ID    trx-&gt;id = trx_sys_allocate_trx_id();&#125;


当写事务开始时，会先调用 trx_assign_rseg_durable  分配一个 Rollback Segment。
分配策略：依次尝试下一个活跃的 Rollback Segment。
/ Assign a durable rollback segment to a transaction in a round-robinfashion.@param[in,out]	trx	transaction that involves a durable write. */void trx_assign_rseg_durable(trx_t *trx) &#123;  ut_ad(trx-&gt;rsegs.m_redo.rseg == nullptr);  trx-&gt;rsegs.m_redo.rseg = srv_read_only_mode ? nullptr : get_next_redo_rseg();&#125;

2. 使用回滚段当第一次真正产生修改需要写 Undo Record 的时候，会从 trx_undo_report_row_operation 进入，接着调用 trx_undo_assign_undo 获得一个 Undo Segment。优先复用 trx_rseg_t 上 Cached List 中的 trx_undo_t，也就是已经分配出来但没有被正在使用的 Undo Segment。
如果没有缓存的 Undo Segment，才调用 trx_undo_create 创建新的 Undo Segment，trx_undo_create 会轮询选择当前 Rollback Segment 中可用的 Slot，申请新的 Undo Page，初始化 Undo Page Header，Undo Segment Header
3. 写入对于 INSERT UNDO LOG 写入的入口函数 trx_undo_page_report_insert
对于 UPDATE UNDO LOG 写入的入口函数 trx_undo_page_report_modify
在写入过程中，可能出现 Undo Page 空间不足的情况，当出现这种情况，会调用 trx_undo_erase_page_end 来清除刚刚写入的区域，然后调用 trx_undo_add_page 申请一个新的 Undo Page 加入到 Undo Page List，同时 undo-&gt;last_page_no 指向新的 Undo Page，重新尝试写入。
表空间系统表空间The System Tablespace
系统表空间是更改缓冲区的存储区域。如果在系统表空间中创建表，而不是每张表一个文件或者常规表空间，它也可能包含表和索引数据。在过于的版本中，系统表空间包含 InnoDB 的数据字典。在 MySQL 8.0 中，InnoDB 将元数据存储在数据字典中。系统表空间可以有一个或者多个数据文件。默认地，会在数据文件夹下创建一个系统表空间数据文件，名为 ibdata。系统表空间的大小和数量由 innodb_data_file_path 启动项定义。
File-Per-Table Tablespaces对于单个 InnoDB 表，file-per-table 表空间包含了该表的数据以及索引，并存储于文件系统的单个文件中
Redo Log 重做日志用来实现事务的持久性Redo Log 是在崩溃期间使用的基于磁盘的数据结构，以纠正不完整事务写入的数据。在正常操作期间，Redo Log 将那些来自于 SQL 语句或者低级 API 调用的表数据修改操作请求进行编码。在初始化并接受连接之前，那些由于无法预期的关闭导致未能将数据文件更新的修改操作会被重新执行。

重做日志用来实现事务的持久性默认地，Redo Log 在物理上表现为磁盘上两个名为 ib_logfile0 和 ib_logfile1 的文件。MySQL 以循环的方式写入 Redo Log 文件。根据受影响的记录，Redo Log 将它们编码；这些数据统称为 redo。

Changing the Number or Size of Redo Log Files如果要修改 Redo Log 的大小数量，需要执行以下步骤：

停止 MySQL Server 并确保它没有错误关闭
编辑 my.cnf 更改日志文件配置。要更改日志文件大小，配置 innodb_log_file_size。为了增加日志文件的数量，需配置 innodb_log_files_in_group
再次启动 MySQL 服务Group Commit for Redo Log Flushing与其他符合 ACID 数据库引擎一样，InnoDB 在提交事务之前会刷写（flush） Redo Log。InnoDB 使用组提交功能，将多个 flush 请求组合在一起，以避免为每个提交进行一次 flush 操作。使用组提交，InnoDB 向日志文件发出单个的写入，用于为同一时间的多个用户事务执行提交动作，这可以显著提高吞吐量。Redo Log Archiving复制 Redo Log 记录的备份工具有时候可能会在进行备份操作时无法跟上 Redo Log 的生成速度，导致由于这些记录被覆盖而导致 Redo Log 记录丢失。在备份操作期间，存在着显著的 MySQL 服务活动，并且 Redo Log 文件存储介质比备份存储介质更快的速度运行时，最常常发生此问题。在 MySQL 8.0.17 中引入的重做记录归档功能，通过在 Redo Log 文件之外将 Redo Log 记录顺序写入归档文件来解决此事。Performance Considerations

Undo Tablespaces撤销表空间包含 undo 日志，这些记录是包含有关如何撤销事务的最新的更改的信息。InnoDB 是一个多版本的存储引擎。它可以保留有关更改行的旧版本的信息，以支持事务功能，例如并发和回滚。此信息以一个称为回滚段的数据结构，存储于 undo 表空间。回滚段驻留在 undo 表空间和全局临时表空间中。
Default Undo Tablespaces初始化 MySQL 实例的时候，会创建两个默认的 undo 表空间。默认 undo 表空间的创建位置由 innodb_undo_directory 变量定义。如果 innodb_undo_directory 变量未定义，则再数据目录中创建默认的 undo 表空间。默认 undo 表空间数据文件名为 undo_001 和 undo_002。数据字典中定义的相应的 undo 表空间名称是 innodb_undo_001 和 innodb_undo_002
Undo Tablespace Size在 MySQL 8.0.23 之前，undo 表空间的大小取决于 innodb_page_size。对于默认的 16K 页大小，初始 undo 表空间是 10MB。
Dropping Undo TablespacesMySQL 8.0.14 可以使用 DROP UNDO TABLESPACES 语法在运行时删除使用 CREATE UNDO TABLESPACES 语法创建的表空间。
MVCCReadView，每个事务在读取数据的时候都会被分配一个视图，通过视图就可以判断其他事务对数据的可见性。
分配：通过 trx_assign_read_view() 分配视图
回收：事务结束时，会通过 view_close() 对其视图进行回收。
m_low_limit_id：读取行为不应该看到 trx_id &gt;&#x3D; m_low_limit_id 的事务，即高水位。分配时取 trx_sys::max_trx_id，即当前还没有被分配的事务最大 ID
m_up_limit_id：读取行为应该可以看到所有 trx_id &lt; m_up_limit_id 的事务，即低水位。低水位，如果m_ids不为空，取其最小值，否则取trx_sys::max_trx_id，即与高水位相等。

关于 m_low_limit_id 和 m_up_limit_id 的解释以及高水位和低水位的比喻均来自于源码注释。

m_ids：在此视图初始化时，通过 copy_trx_ids() 从 trx_sys::rw_trx_ids 拷贝一份活跃事务ID(不包含当前事务ID)。
]]></content>
  </entry>
  <entry>
    <title>Redis 面试预备</title>
    <url>/2022/07/24/%E9%9D%A2%E8%AF%95/Redis-%E9%9D%A2%E8%AF%95%E9%A2%84%E5%A4%87/</url>
    <content><![CDATA[Redis 面试预备为什么用 Redis
高并发
高可用

缓存缓存穿透缓存中不存在，数据库也不存在
这样会导致每次使用该 key 请求时都会查询数据库
缓存穿透大量请求的 key 不存在于缓存，导致请求直接落到数据库
解决方法:

对参数进行校验。比如 id 不能小于 0、特定数据的格式，如果不满足，则直接返回错误消息给客户端。

通过布隆过滤器判断 key 是否不存在。如果 key 不存在，直接返回给客户端。如果 key 可能存在，则走缓存或查询数据库。

将无效的 key 也缓存下来。如果受到恶意攻击，每次构建不同的请求 key，会导致 redis 缓存大量无效的 key。尽量将无效的 key 过期时间设置短一些。


缓存雪崩缓存在同一时间大面积失效，大量请求落到数据库，甚至引起数据库宕机。
例如，缓存模块产生问题（如：宕机等）。
解决方法：

使用 Redis 集群，增加可用性。

限流


热点数据在某一时刻大面积失效。
比如，用户晚上活动少，热点数据缓存在夜间过期。第二天早上集中某个时刻活跃。
解决方法:

缓存设置时间随机、更长甚至永不失效

缓存和数据库一致性解决:

缓存空对象

布隆过滤器



BloomFilter ，MySQL 的 id 引入该过滤器。

使用场景
缓存

记录用户在线人数


使用 zSet 结构
用户每次调用接口，在鉴权的时候刷新一次该用户 user_id 对应的 score
定时脚本，删除过期的数据:
$redis-&gt;zRemRangeByScore(REDIS_ONLINE_USER, 0, time() - 5200);]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL replication 一主多从</title>
    <url>/2022/11/18/Database/MySQL/MySQL-replication-%E4%B8%80%E4%B8%BB%E5%A4%9A%E4%BB%8E/</url>
    <content><![CDATA[一主多从master步骤一 检查配置 my.cnf 必要选项，如果修改了需要重启 mysqld 使参数生效
[mysqld]log_bin=mysql-binserver-id=1000

步骤二 配置 replication 用户
create user &#x27;replication&#x27;@&#x27;%&#x27; identified with mysql_native_password by &#x27;replication&#x27;;grant replication slave on *.* to &#x27;replication&#x27;@&#x27;%&#x27;;flush privileges;

slave步骤一 配置 my.cnf 必要选项，如果修改了需要重启 mysqld 使参数生效
[mysqld]server-id=2000

配置步骤一 登录 master，查看 master 状态
show master status;+------------------------------------+----------+--------------+------------------+-------------------+| File                               | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------------------------+----------+--------------+------------------+-------------------+| iZbp13qubkh4obhv5jxw91Z-bin.000001 |      155 | test         |                  |                   |+------------------------------------+----------+--------------+------------------+-------------------+

步骤二 登录 slave
-- 查看是否有残余配置show slave status\G;-- 先停止再清除stop slave;reset slave all;-- 根据 master 的状态进行配置change master tomaster_host = &#x27;&lt;IP&gt;&#x27;,master_port = 13306,master_user = &#x27;replication&#x27;,master_password = &#x27;root&#x27;,master_log_file = &#x27;iZbp13qubkh4obhv5jxw91Z-bin.000001&#x27;,master_log_pos = 155;-- 启动 slavestart slave;show slave status\G;
注意 Slave_IO_Running 和 Slave_Slave_Running 需要均显示为 Yes，才表示成功，否则留意错误提示。
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL replication 原理</title>
    <url>/2022/11/18/Database/MySQL/MySQL-replication-%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[MySQL Replication 实现原理MySQL复制功能是通过 3 个线程实现的，1 个在复制源服务器上，另 2 个在副本服务器上。
这三个线程都是 start slave 之后，双方才出现的。
通过在 master 机器上查看线程
mysql&gt; show processlist;+-------+-----------------+-----------------+-------------+-------------+---------+---------------------------------------------------------------+------------------+| Id    | User            | Host            | db          | Command     | Time    | State                                                         | Info             |+-------+-----------------+-----------------+-------------+-------------+---------+---------------------------------------------------------------+------------------+| 17091 | root            | localhost:60990 | NULL        | Binlog Dump |     408 | Master has sent all binlog to slave; waiting for more updates | NULL             |+-------+-----------------+-----------------+-------------+-------------+---------+---------------------------------------------------------------+------------------+

通过在 slave 机器上查看线程
mysql&gt; show processlist;+----+-----------------+-----------------+-------------+---------+------+--------------------------------------------------------+------------------+| Id | User            | Host            | db          | Command | Time | State                                                  | Info             |+----+-----------------+-----------------+-------------+---------+------+--------------------------------------------------------+------------------+|  9 | system user     | connecting host | NULL        | Connect |  138 | Waiting for master to send event                       | NULL             || 10 | system user     |                 | NULL        | Query   |   32 | Slave has read all relay log; waiting for more updates | NULL             |+----+-----------------+-----------------+-------------+---------+------+--------------------------------------------------------+------------------+
Binlog dump threadbinlog 转储线程。Master 创建一个线程，以便在 Slave 连接时将二进制日志内容发送到 Slave。
Replication I&#x2F;O thread在 Slave 服务器上发出 start slave 语句时，Slave 将创建一个I &#x2F; O线程，该线程连接到 Master 并要求它发送记录在其二进制日志中的更新。
Replication I &#x2F; O线程读取源 Binlog Dump 线程发送的更新 （请参见上一项），并将它们复制到本地的中继日志文件中。
该线程的状态可以通过 show slave status 命令中的  Slave_IO_running 输出得知。 或者， show status 的输出Slave_running。
Replication SQL threadSlave 创建一个 SQL 线程以读取由 Replication I &#x2F; O 线程写入的中继日志，并执行其中包含的事件。
在前面的描述中，每个 Replication 连接有三个线程。具有多个 Slave 的 Master 为每个当前连接的 Slave 创建一个二进制日志转储线程，当然，每个 Slave 都有自己的Replication I &#x2F; O 和 SQL 线程。
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL replication 多主一从</title>
    <url>/2022/11/18/Database/MySQL/MySQL-replication-%E5%A4%9A%E4%B8%BB%E4%B8%80%E4%BB%8E/</url>
    <content><![CDATA[多主一从数据汇集场景，确保场景内表结构一致
master步骤一 配置 my.cnf 必要选项，如果修改了需要重启 mysqld 使参数生效
[mysqld]server-id = 1000log_bin=mysql-bin

步骤二 配置 replication 用户
create user &#x27;replication&#x27;@&#x27;%&#x27; identified with mysql_native_password by &#x27;replication&#x27;;grant replication slave on *.* to &#x27;replication&#x27;@&#x27;%&#x27;;flush privileges;

slave步骤一 配置 my.cnf 必要选项，如果修改了需要重启 mysqld 使参数生效
[mysqld]server-id = 2000

步骤二 分别查看多个 master 的状态
show master status;+------------------------------------+----------+--------------+------------------+-------------------+| File                               | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------------------------+----------+--------------+------------------+-------------------+| iZbp13qubkh4obhv5jxw91Z-bin.000001 |      155 | test         |                  |                   |+------------------------------------+----------+--------------+------------------+-------------------+

步骤三 对 slave 进行配置
-- 查看是否有残余配置show slave status\G;-- 先停止再清除stop slave;reset slave all;
对不同的 master 建立通道，注意 for channel 应当不同
change master tomaster_host = &#x27;112.124.1.100&#x27;,master_user = &#x27;replication&#x27;,master_port = 3306,master_password = &#x27;replication&#x27;,master_log_file = &#x27;mysql-bin.000006&#x27;,master_log_pos = 155,master_connect_retry = 15,master_retry_count = 0for channel &#x27;master1&#x27;;
启动通道
start slave for channel &#x27;master1&#x27;;start slave for channel &#x27;master2&#x27;;
查看状态
show slave status\G;
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL undo 分配</title>
    <url>/2022/05/09/Database/MySQL/MySQL-undo-%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[分配临时回滚段和持久回滚段的函数名不同只在于末尾的单词不同：
trx_assign_rseg_temp
trx_assign_rseg_durable
当一个事务被判定为读写模式时，会为其分配 trx_id 以及持久回滚段。
分配临时回滚段是当调用 trx_undo_report_row_operation 时，判断是否是临时表而动态分配的。
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 免密登录</title>
    <url>/2022/11/28/Database/MySQL/MySQL-%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[编辑 my.cnf 配置文件
在 [mysqld] 下面添加以下选项:
skip-grant-tables

重新启动 mysql
systemctl restart mysql

直接免密登录
mysql

需要先刷一下权限，否则执行 ALTER 你会得到如下错误:
ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement

修改新密码
alter user root@localhost identified by &#x27;new_password&#x27;;

删除选项 skip-grant-tables，重启服务即可。
]]></content>
  </entry>
  <entry>
    <title>MySQL 执行计划参考</title>
    <url>/2022/10/02/Database/MySQL/MySQL-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[参考文章官方文档
EXPLAIN 语句提供有关 MySQL 如何执行语句的信息。EXPLAIN 工作于 SELECT, DELETE, INSERT, REPLACE, UPDATE 语句。EXPLAIN 为每一个使用了 SELECT 语句的表返回一行信息。在输出信息中，它按照 MySQL 在执行语句的时候读取的表的顺序进行输出。这意味着，MySQL 从第 1 张表读取一行，那么它从第 2 张表中寻找匹配的行，然后从第三张表，等等。
idSELECT 标识符。这是本次查询中 SELECT 的序列号。如果行是其他行的 UNION 结果，该值可以为 NULL。在这种情况下，table 列显示诸如 *&lt;union M, N&gt;*，标识该行是 id 值为 M 和 N 行的 UNION。
select_typeSELECT 的类型，可以是下表中的任意一种。



select_type 值
意义



SIMPLE
简单 SELECT（没有使用 UNION 或者子查询）


PRIMARY
最外层查询


UNION
UNION 查询中第二或后面的 SELECT 语句


DEPENDENT UNION
UNION 查询中第二或后面的 SELECT 语句，依赖于外部查询


UNION RESULT
UNION 的结果


SUBQUERY
子查询中第一个 SELECT


DEPENDENT SUBQUERY
子查询第一个 SELECT，依赖于外部查询


DERIVED
派生表


DEPENDENT DERIVED
依赖于其他表的派生表


MATERIALIZED



UNCACHEABLE SUBQUERY



UNCACHEABLE UNION



table该行输出所引用的表名称。可以是下面的值中的一个：

&lt;union ***M,N***&gt;: 该行引用 id 值为 M 和 N 的行 UNION。

&lt;derived ***N***&gt;: 引用 id 值为 N 的行的派生表结果。例如，一个派生表可能源自于 FROM 子句的子查询。

&lt;subquery ***N***&gt;: 引用 id 值为 N 的行的 materialized 子查询结果。


typeEXPLAIN 的列 type 输出描述了表如何连接。下列描述了连接类型，顺序由好到差：

system表只有一行（&#x3D; 系统表）。这是 const 连接的特例。

const当比较 PRIMARY KEY 或者 UNIQUE 索引所有部分与常量值的时候，const 被使用。这里之所以用“所有部分”，是因为 PRIMARY KEY 和 UNIQUE 都可以基于多字段建立。

eq_ref从 B 表中读取仅匹配的一行，与 A 表的每一行进行组合。除了 system 和 const 类型，这可能是最好的连接类型。当索引的所有部分被用于连接，而且索引是 PRIMARY KEY 或者 UNIQUE NOT NULL 索引，eq_ref 被使用。


eq_ref 用于使用等于运算符的索引列。比较值可以是常量或者表达式，该表达式使用前表读取的列。比如下面例子：
SELECT * FROM ref_table,other_table  WHERE ref_table.key_column=other_table.column;SELECT * FROM ref_table,other_table  WHERE ref_table.key_column_part1=other_table.column  AND ref_table.key_column_part2=1;

对于第 2 个 SQL，必须充分使用索引的“所有部分”，可以是列，可以是常量；而且，至少有一个列，否则全是常量就变成 const 连接类型了


ref从 B 表中读取匹配的所有行，与 A 表的每一行进行组合。如果连接仅仅使用最左前缀，或者 key 不是 PRIMARY KEY 或者 UNIQUE 索引，ref 将被使用。总之，如果连接无法选择单列，而是多列，就有可能是 ref。

ref 可以用于 &#x3D; 或者 &lt;&#x3D;&gt; 操作符进行比较的索引列。
-fultext使用全文索引执行连接

ref or null省略

range使用索引来选择行，只有那些在给定范围内的行数据会被取出。输出行中的 key 标识哪个索引被使用到。key_len 包含使用的最长 key 的长度。对于此类型，ref 列为 null。


range 用于 key 列与常量进行比较，涉及的运算符有 &#x3D;, &lt;&gt;, &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, IS NULL, &lt;&#x3D;&gt;, BETWEEN, LIKE, IN()

index除了索引树被扫描以外，index 连接类型和 ALL 相同。发生在两种情况下：
如果索引对于查询来说是覆盖索引，并且可用于满足表所需的所有数据，则仅仅扫描索引树。在这种情况下，Extra 列显示 Using index。仅扫描索引树通常比 ALL 更快，因为索引的大小通常小于表数据。
以索引的顺序，使用来自索引的读取执行全表扫描来检索数据。Using index 不会出现在 Extra 列。



当查询仅使用单个索引的一部分时，MySQL 使用 index 类型。

ALL从 B 表进行全表扫描，与 A 表每一行进行组合。

keykey 列表示 MySQL 实际决定使用的 key（索引）。如果 MySQL 决定使用 possible keys 索引之一来检索行，那么，那个索引将被列为 key 值。
对于 InnoDB 来说，辅助索引可能会覆盖被选择的列，即使查询也取出主键，因为 InnoDB 将主键和每个辅助索引存储在一起。如果 key 是 NULL，说明 MySQL 找不到更有效地执行查询地索引。
key_lenkey_len 标识 MySQL 决定使用的 key 的长度。key_len 可以让你确定联合索引实际使用的部分。如果 key 列是 NULL，那么 key_len 也是 NULL。
由于 key 的存储不同，对于可以为 NULL 的列会比 NOT NULL 列的 key 长度大 1 位。
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL InnoDB Buffer Pool</title>
    <url>/2022/07/20/Database/MySQL/MySQL-%E7%BC%93%E5%86%B2%E6%B1%A0-Buffer-Pool/</url>
    <content><![CDATA[MySQL InnoDB Buffer Pool​

本文主要内容源自官网：MySQL :: MySQL 8.0 Reference Manual :: 15.5.1 Buffer Pool感兴趣的可以直接阅读

​缓冲池是主内存的一块区域，其中 InnoDB 访问表和索引数据时会在其中进行缓存。Buffer Pool 允许从内存中访问频繁使用的数据，这加快了处理速度。在专用服务器上，通常将多达 80% 的物理内存分配给 Buffer Pool。
为了大容量的读操作效率，Buffer Pool 被分为多个页面，这些页面可能包含多个行。为了缓存管理的效率，Buffer Pool 被实现为 Page 的链表。使用 LRU （Least Recently Used，最近最少使用）算法的变体将数据从缓存中老化淘汰出去。
知道如何利用 Buffer Pool，以将经常访问的数据保存在内存中是 MySQL 调整的重要方面。
缓冲池 LRU 算法缓冲池 LRU 算法将缓冲池作为列表进行管理。当缓冲池空间不足，但有新页面需要添加到缓冲池时，将驱逐最近最少使用的页面，并将新页面添加到列表的 Midpoint（中点）。总列表分为两个子列表（Sublist）：

最前面的是最近访问过的新页面（或者叫 young 页面，年轻页面）子列表

末尾是最近访问的旧页面的子列表





​该算法将经常需要访问的页面保留在 New Sublist。Old Sublist 包含不常用的页面，这些页面是驱逐的候选对象。
通常情况，该算法遵循以下规则：
1.  的 Buffer Pool 用于 Old Sublist

列表的 Midpoint 是 New Sublist 的 Tail 和 Old Sublist 的 Head 相交的边界。

当 InnoDB 将页面读入缓冲池时，它首先将页面插入 Midpoint。通过用户触发的动作（比如 SQL 查询）或者预读操作可以对页面进行读取。


注意：官方这里说的读取（read）并不代表访问（access），请看下面。

访问（access）Old Sublist 中的页面会让其变得 young，然后将其移至 New Sublist 的 Head。如果是因为用户触发的动作需要读取页面，则将立即进行第一次 access，使页面 young。如果是由于预读操作而读取了该页面，则第一次 access 不会立即访问，甚至在页面离开之前都不会发生！

注意：预读未必会让页面变 young。

随着数据库的运行，通过将页面移动到列表的尾部，缓冲池中的页面将会“老化”。New 和 Old Sublist 都会随着其他页面的更新而老化。随着将页面插入 Midpoint，旧子列表中的页面也会老化。最终，未使用的页面到达子列表的尾部并被逐出。

注意：这里有个有趣的现象，页面是先插入到 Midpoint，而且这些页面插入之后属于 Old Sublist 的范围，所以他们很可能会马上“老化”，唯一让他们变得 young 的途径就是 access 一次。
默认情况下，查询（Query）读取的页面会立即移入新的子列表，这意味着它们在缓冲池停留的时间更长。
举个例子，mysqldump 操作或者 SELECT 不带 WHERE 子句的语句可能会将大量数据带入缓冲池，并驱逐出相当多的旧数据，即使加入 New Sublist Head 的新数据在 access 一次之后都不会再被使用了。同样，预读线程加载的页面，且仅仅访问过一次，那么也会移至 New Sublist 的开头。这些情况可能会将常用页面推到旧的子列表，然后被逐出。
所以，这似乎有个问题，有些 page 明明使用的频率不如其他页面，却可以插在其他页面前面，甚至逐出其他页面 ，官方给出了优化此行为的方法：让缓冲池的扫描具有“抵抗力”、配置 InnoDB 缓冲池预读（具体见官网）。
使用标准监视器监视 Buffer Pool----------------------BUFFER POOL AND MEMORY----------------------Total large memory allocated 137428992 # 为缓冲池分配的总内存（单位：字节）Dictionary memory allocated 2774195 # 为 InnoDB 数据字典分配的总内存（单位：字节）Buffer pool size   8192 # 分配给缓冲池的页数Free buffers       957 # 缓冲池空闲列表的页数Database pages     6896 # 缓冲池 LRU 列表的页数Old database pages 2525 # 缓冲池 Old Sublist 的页数Modified db pages  0 # 缓冲池中当前修改的页数Pending reads      0 # 等待读入缓冲池的页数# Pending writes LRU 来自于 LRU 列表底部待写的旧脏页数# Pending writes flush list 检查点期间要刷新的缓冲池页面数# Pending writes single page 缓冲池中暂挂的独立页面写入数Pending writes: LRU 0, flush list 0, single page 0# Pages made young 缓冲池 LRU 列表中变年轻的页面数（已移至 New Sublist 开头）# Pages made not young 缓冲池 LRU 列表中非年轻的页数（在 Old Sublist 没有年轻的页面）Pages made young 38061, not young 2052025# youngs/s 每秒导致 LRU 列表中旧页面访问的平均次数# non-youngs/s 0.00 youngs/s, 0.00 non-youngs/s# Pages read 从缓冲池读取的页面总数# Pages created 从缓冲池中创建的页面总数# Pages written 从缓冲池写入的页面总数Pages read 416647, created 103098, written 239695# reads/s 平均每秒缓冲池页面读取数# creates/s 平均每秒创建缓冲池的数目# writes/s 平均每秒缓冲池页面写入数0.00 reads/s, 0.00 creates/s, 0.00 writes/sNo buffer pool page gets since the last printoutPages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/sLRU len: 6896, unzip_LRU len: 0I/O sum[0]:cur[0], unzip sum[0]:cur[0]
​
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL undo 分配</title>
    <url>/2022/05/09/Database/MySQL/undo-%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[分配临时回滚段和持久回滚段的函数名不同只在于末尾的单词不同：
trx_assign_rseg_temp
trx_assign_rseg_durable
当一个事务被判定为读写模式时，会为其分配 trx_id 以及持久回滚段。
分配临时回滚段是当调用 trx_undo_report_row_operation 时，判断是否是临时表而动态分配的。
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>undo 清理</title>
    <url>/2022/05/02/Database/MySQL/undo-%E6%B8%85%E7%90%86/</url>
    <content><![CDATA[purge_queuepurge_queue中记录了所有等待Purge的Rollback Segment和其History中trx_no最小的事务
预处理storage&#x2F;innobase&#x2F;trx&#x2F;trx0undo.cc
事务结束的时候，对于需要Purge的Update类型的Undo Log，会按照事务提交的顺序trx_no，挂载到Rollback Segment Header的History List上。
在 trx_undo_update_cleanup 函数中调用
void trx_undo_update_cleanup(trx_t *trx, trx_undo_ptr_t *undo_ptr, page_t *undo_page, bool update_rseg_history_len, ulint n_added_logs, mtr_t *mtr) &#123;  ...  // 将 update undo 添加到 history  trx_purge_add_update_undo_to_history(      trx, undo_ptr, undo_page, update_rseg_history_len, n_added_logs, mtr);  ...&#125;

流程



srv_do_purge() 为入口函数
trx_purge() 获取最老的视图复制给 purge_sys-&gt;view，方便之后真正 purge undo log 时判断其是否不会再被访问到了。
trx_sys-&gt;mvcc-&gt;clone_oldest_view(&amp;purge_sys-&gt;view);


通过 trx_purge_attach_undo_recs() 获取需要被 purge 的undo log：
n_pages_handled = trx_purge_attach_undo_recs(n_purge_threads, batch_size);

trx_purge_attach_undo_recs
通过 trx_purge_fetch_next_rec() 循环获取可以被purge 的 undo log，默认最多获取 300 个 undo 页

可以通过 innodb_purge_batch_size 来调整

trx_purge_fetch_next_rec 流程
trx_purge_choose_next_log

该函数作用：选择下一个需要清理的 undo log，并且更新 purge_sys 的信息
通过 trx_purge_choose_next_log() 从purge_sys::purge_queue 取出第一个回滚段



trx_purge_get_next_rec

从其 history list 上读取最老还未被 purge 的事务的undo log header。从此 undo log header 依次读取undo log record，每次读取会设置purge_sys的变量
读取完毕后，重新统计此回滚段最老还未被purge的事务的位点，然后重新放入purge_sys::purge_queue；最后回到第一步。
trx_purge_choose_next_log依次从 purge_queue 中 pop 出拥有全局最小 trx_no 的 Undo Log。
TrxUndoRsegsIterator::set_next() 流程如果满足 m_iter != m_trx_undo_rsegs.end()，表示当前即将处理的 rollback segment 还未到最后一个，即还有更多的 rollback segment 需要处理。
如果当前即将处理的 rollback segment 已经到最后一个了，那么将会进入一个 while(!m_purge_sys-&gt;purge_queue-&gt;empty()) 循环：

如果满足 m_trx_undo_rsegs.get_trx_no() == UINT64_UNDEFINED，表示当前需要处理的 rollback segment 对应的事务并不存在（一条伪记录），那么将会将 purge_queue 顶部的元素赋值给 m_trx_undo_rsegs。弹出顶部 rollback segment

其次，如果满足 purge_sys-&gt;purge_queue-&gt;top().get_trx_no() == m_trx_undo_rsegs.get_trx_no()，表示 purge_queue 顶部的 rollback segment 对应的事务就是当前待处理的事务，那么将purge_queue 顶部的 rollback segment 添加到 m_trx_undo_rsegs。弹出顶部 rollback segment

否则，表示当前待处理的 rollback segment 集合对应的事务并不等于 purge_queue 顶部事务，跳出循环


]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 常用函数</title>
    <url>/2022/11/07/Database/PostgreSQL/PostgreSQL-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[String Functions and Operators|| 操作符可以连接字符串；也可以连接非数组类型。
concatconcat ( val1 &quot;any&quot; [, val2 &quot;any&quot; [, ...] ] )

连接所有参数的文本表示。NULL 参数被忽略。
与 || 的区别在于：

concat 会忽略 null 值，将非 null 值连接
|| 如果有任意一个为 null， 整个表达式为 null

to_char格式化
日期&#x2F;时间格式化的模板模式参考官网
一些常用的格式化模式:



Pattern
描述



YYYY
year (4 or more digits)


MM
month number (01–12)


DD
day of month (01–31)


HH24
hour of day (00–23)


MI
minute (00–59)


SS
second (00–59)


split_part第 3 个参数是索引，从 1 开始。
select split_part(&#x27;1,2,3&#x27;, &#x27;,&#x27;, 1);


字符串 &#39;1,2,3&#39; 可以替换为字段

 split_part------------ 1(1 row)

如果索引值不存在，也会返回
select split_part(&#x27;1,2,3,&#x27;, &#x27;,&#x27;, 5);
 split_part------------(1 row)

取出最后一部分:
select split_part(&#x27;/江苏/南京市/建邺区&#x27;, &#x27;/&#x27;, length(replace(&#x27;/江苏/南京市/建邺区&#x27;, &#x27;/&#x27;, &#x27;//&#x27;)) - length(&#x27;/江苏/南京市/建邺区&#x27;) + 1);select split_part(&#x27;江苏/南京市/建邺区&#x27;, &#x27;/&#x27;, length(replace(&#x27;江苏/南京市/建邺区&#x27;, &#x27;/&#x27;, &#x27;//&#x27;)) - length(&#x27;江苏/南京市/建邺区&#x27;) + 1);

 split_part------------ 建邺区(1 row)



string_agg聚合函数。必须配合 group by。
直接把一个表达式变成字符串
string_agg(expression, delimiter)


在某些场景下可能配合 JOIN 使用.

]]></content>
  </entry>
  <entry>
    <title>postgresql 笔记</title>
    <url>/2022/09/28/Database/PostgreSQL/PostgreSQL-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[参考引用https://blog.csdn.net/lmmilove/article/details/122111192
Linux 安装客户端apt install postgresql-client


psql
建立连接

psql --host=HOST --username=USERNAME --dbname=DBNAME


psql 内置命令


命令
含义



\c dbname
切换数据库


\l
查看所有数据库


\d
查看当前数据库中的表


\d table
查看表中的字段


\d+ table
查看表中的字段（详细）


\q
推出登录


pg_dump
导出表结构

pg_dump --host=HOST --username=USERNAME -s -t &lt;TABLE&gt; &lt;DBNAME&gt;




选项
含义



-s
只导出表结构


-t
table, 跟上表名


SQL
修改表字段

alter table table_name alter field_name type varchar(32) using field_name::varchar(32);


如果需要发生显式的类型转换，需要增加 USING 关键字。即使不需要发生显式的类型转换，也可以增加 USING 关键字（稳妥）。

]]></content>
  </entry>
  <entry>
    <title>PHP Excel 框架 phpoffice/phpspreadsheet</title>
    <url>/2022/11/15/Framework/PHP/PHP-Excel-%E6%A1%86%E6%9E%B6-phpoffice-phpspreadsheet/</url>
    <content><![CDATA[phpoffice&#x2F;phpspreadsheethttps://github.com/PHPOffice/PhpSpreadsheet
1. composer 依赖通过 composer 导入相关依赖
composer require phpoffice/phpspreadsheet

&quot;require&quot;: &#123;  &quot;phpoffice/phpspreadsheet&quot;: &quot;^1.6&quot;&#125;


2. 读取 Excel 步骤$filename=&#x27;&#x27;;// 创建 Reader$reader= \PhpOffice\PhpSpreadsheet\IOFactory::createReader(&#x27;Xlsx&#x27;); //也可以使用文件名，自动识别后缀，创建 Reader$objReader = \PhpOffice\PhpSpreadsheet\IOFactory::createReaderForFile($filename);// 如果只读，提高效率$reader-&gt;setReadDataOnly(true);// $filename 相对路径或绝对路径$spreadsheet = $reader-&gt;load($filename);

3. 相关类Spreadsheet


函数
描述
应用



getActiveSheet()
获得活跃的工作簿



createSheet()
创建新工作簿



Worksheet方法


函数
描述
应用



setTitle()
设置工作簿的标题



getHighestRow()
获得最大行数



setCellValue()
以坐标方式设置单元格的值。



setCellValueByColumnAndRow()
以列号、行号方式设置单元格值



getCell()
以坐标方式获取单元格的值



getCellByColumnAndRow()
以列号、行号方式获取单元格的值



getRowDimension()
以行号方式获得行维度



getColumnDimension()
以列名方式获得列维度。如：’A’



getStyle()
以坐标方式获得样式
查看


getDataValidation()
以坐标方式获得数据校验
查看


mergeCells()
合并单元格，参数示例：A1:E1



mergeCellsByColumnAndRow
合并单元格，需要传入 4 个参数表示两个单元格



应用// 如果要获取整列单元格的样式，则仅仅传入列名// 注意：对于列名是大写字母，而不是索引数字$style = $worksheet-&gt;getStyle(&#x27;C&#x27;);// 如果要配置整列的单元格，则这样传入参数$worksheet-&gt;getDataValidation(&#x27;$A:$A&#x27;);


RowDimension方法


函数
描述
应用



setRowHeight()
设置行高




注意，设置行高并不是绝对准确的，excel 会适当缩放

应用// 设置行高// 行高这里传入索引数字，从 1 开始$worksheet-&gt;getRowDimension($row)-&gt;setRowHeight(13.2);

ColumnDimension


函数
描述
应用



setWidth()
设置宽度



// 设置列宽$worksheet-&gt;getColumnDimensionByColumn(1)-&gt;setWidth(8);$worksheet-&gt;getColumnDimension(&#x27;A&#x27;)-&gt;setWidth(8);


注意，设置列宽并不是绝对准确的，excel 会适当缩放

Style


函数
描述
应用



getAlignment()
获得对齐方式



getFont()
获得字体



getBorders()
获得边框



// 设置边框$worksheet-&gt;getStyleByColumnAndRow($col, $row)-&gt;getBorders()-&gt;getAllBorders()-&gt;setBorderStyle(Border::BORDER_THIN);

Borders设置全部边框
$worksheet-&gt;getStyle(	&#x27;A1:&#x27; .	$worksheet-&gt;getHighestColumn() .	$worksheet-&gt;getHighestRow())-&gt;getBorders()-&gt;getAllBorders()-&gt;setBorderStyle(Border::BORDER_THIN);
Alignment


函数
描述
应用



setWrapText()
设置对齐方式



setHorizontal()
设置自动换行



// 设置 A 列垂直居中，自动换行$worksheet-&gt;getStyle(&#x27;A&#x27;)-&gt;getAlignment()-&gt;setVertical(Alignment::VERTICAL_CENTER)-&gt;setWrapText(true);// 设置 A 列水平居中，自动换行$worksheet-&gt;getStyle(&#x27;A&#x27;)-&gt;getAlignment()-&gt;setHorizontal(Alignment::HORIZONTAL_CENTER)-&gt;setWrapText(true);


Font


函数
描述
应用



setName()
设置字体



setSize()
设置字体大小



应用// 级联设置字体以及大小$worksheet-&gt;getStyleByColumnAndRow(1, $row)-&gt;getFont()-&gt;setName(&#x27;Arial&#x27;)-&gt;setSize(10);

Fill


函数
描述



setFillType()
设置填充类型


getStartColor()
获得起始颜色


应用// 填充背景色$worksheet-&gt;getStyleByColumnAndRow($col, $row)-&gt;getFill()-&gt;setFillType(Fill::FILL_SOLID)-&gt;getStartColor()-&gt;setRGB(&#x27;D6E9AD&#x27;);

ColorDataValidation


函数
描述
应用



setType()
设置数据格式



setShowErrorMessage()
设置是否显示错误信息



setErrorTitle()
设置错误提示框标题



setError()
设置错误信息



setErrorStyle()
设置错误样式



setPromptTitle()
设置提示标题。需要与 setPrompt 搭配使用，否则无效果。



setPrompt()
设置提示文字



setAllowBlank()
设置是否允许为空



setShowInputMessage()
设置是否展示输入信息



setShowDropDown()
设置是否展示下拉



setFormula1()
设置公式
查看


应用
设置下拉菜单
$worksheet-&gt;getDataValidation(&#x27;E3&#x27;)	-&gt;setType(DataValidation::TYPE_LIST)	-&gt;setShowDropDown(true)	-&gt;setFormula1(&#x27;&quot;小学,初中,高中&quot;&#x27;);


如果不设置 type 或者 showDropDown 则不会生效

setFormula1 一般有这样几种用法：

序列设置。这种适用于选项比较少的情况，因为 Excel 的序列长度是有限的。$data_validation-&gt;setFormula1(&#x27;&quot;选项1,选项2&quot;&#x27;);
单元格引用。使用广泛，可以支持更多选项。$data_validation-&gt;setFormula1(&#x27;教师列表!$A$1:$A&#x27; . sizeof($teacher_title_list)); // 教师列表是 sheet 的名字

下载 Excel


后缀名
MIME



xlsx
application&#x2F;vnd.openxmlformats-officedocument.spreadsheetml.sheet


xls
application&#x2F;vnd.ms-excel


$writer = new Xlsx($spreadsheet);$filename = rawurlencode(&quot;文件名称&quot;);header(&#x27;Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&#x27;);header(&quot;Content-Disposition: attachment;filename=\&quot;&#123;$filename&#125;\&quot;;filename*=UTF-8&#x27;&#x27;&#123;$filename&#125;&quot;);header(&#x27;Cache-Control: max-age=0&#x27;);$writer-&gt;save(&#x27;php://output&#x27;);

]]></content>
      <tags>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK 8 Stream API</title>
    <url>/2022/10/24/Language/Java/JDK-8-Stream-API/</url>
    <content><![CDATA[Streamstream 是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。
注意：
Stream 自己不会存储元素。Stream 不改变源对象。相反，它们回返回一个持有结果的新 Stream。Stream 操作时延迟进行的。这意味着它们会等到需要结果的时候才执行。
map
List&lt;A&gt; &#x3D;&gt; List&lt;B&gt;

public class FileDTO &#123;	private String name;	private Long lastModified;	private Long size;	public FileDTO(File file) &#123;		this.name = file.getName();		this.lastModified = file.lastModified();		this.size = file.length();	&#125;	&#125;
Arrays.stream(files).map(file -&gt; new FileDTO(file)).collect(Collectors.toList());
// List&lt;Integer&gt; =&gt; List&lt;String&gt;List&lt;String&gt; stringList = intList.stream().map(String::valueOf).collect(Collectors.toList());

distinct去重，依据 Object.equals() 方法
sorted排序

自定义比较器


Comparator，Returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second.

List&lt;Map&lt;String, Object&gt;&gt; sortedWorkerLogList = workerLogList.stream().sorted((workerLog1, workerLog2) -&gt; &#123;    Date createTime1 = (Date) workerLog1.get(&quot;create_time&quot;);    Date createTime2 = (Date) workerLog2.get(&quot;create_time&quot;);    if (createTime1.after(createTime2)) &#123;        return 1;    &#125; else if (createTime1.before(createTime2)) &#123;        return -1;    &#125;    return 0;&#125;).collect(Collectors.toList());

collect
分隔字符串

idList.stream().map(String::valueOf).collect(Collectors.joining(&quot;,&quot;));]]></content>
  </entry>
  <entry>
    <title>Java BigDecimal 方法记录</title>
    <url>/2022/09/29/Language/Java/Java-BigDecimal-%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[使用字符串构造一个 BigDecimalBigDecimal big = new BigDecimal(&quot;2.3513&quot;);


将字符串与 0 进行比较new BigDecimal(reportFormListItem.getApplyCostRadio()).compareTo(BigDecimal.ZERO) == 0)

如果使用 equals 方法比较 &quot;0.0&quot; 和 &quot;0&quot;，将返回 false
保留小数一般比较建议使用枚举类型传参:
// 5 进 1，如：2.65 得到 2.7big.setScale(1, RoundingMode.HALF_UP);// 5 不进位, 如: 2.65 得到 2.6big.setScale(1, RoundingMode.HALF_DOWN);// 截断多余小数位，如: 2.678 得到 2.6; -5.5 得到 -5big.setScale(1, RoundingMode.DOWN);

下面这种方式，第二个参数为 int
// 默认 java.math.BigDecimal#ROUND_UNNECESSARY// 这种方法如果小数位大于 1，那么就会抛出异常big.setScale(1);// 5 进 1，如：2.65 得到 2.7big.setScale(1, BigDecimal.ROUND_HALE_UP);// 5 不进位, 如: 2.65 得到 2.6big.setScale(1, BigDecimal.ROUND_HALF_DOWN);// 截断多余小数位，如: 2.678 得到 2.6big.setScale(1, BigDecimal.ROUND_DOWN);


判断符号如果返回 -1，表示负数；如果返回 0，表示 0；如果返回 1，表示正数；
big.signum();


相反数 negate()new BigDecimal(10).negate();

输出字符串不使用科学计数法输出
bigDecimal.toPlainString();]]></content>
  </entry>
  <entry>
    <title>Java Collection</title>
    <url>/2022/07/19/Language/Java/Java-Collection/</url>
    <content><![CDATA[Java Collection容器底层数据结构List
ArrayList: Object[] 数组
Vector: Object[] 数组
LinkedList: JDK 1.7 之前，双向循环链表；JDK 1.7 之后，双向链表

Map
HashMap：JDK 1.8 之前，数组 + 链表；JDK 1.8 之后，数组 + 链表&#x2F;红黑树

LinkedHashMap：双向链表 + 数组 + 链表

Hashtable: 数组 + 链表

TreeMap：红黑树


SetHashSet: 基于 HashMap 实现
LinkedHashSet: 基于 LinkedHashMap 实现
TreeSet: 红黑树

思考：为什么 HashSet 底层 HashMap 的 value 不存储 null，反而是一个 Object?

QueuePriorityQueue: Object[] 数组二叉堆
ArrayQueue: Object[] 数组 + 双指针
集合选择场景Map
一些签名计算要求传入的参数按照 ascii 排序可以使用 TreeMap

多线程场合 ConcurrentHashMap

其余场合 HashMap


Set保证元素唯一 TreeSet、HashSet，做一些统计
List没有特别要求就选择 ArrayList、LinkedList
]]></content>
      <tags>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O 笔记</title>
    <url>/2022/07/20/Language/Java/Java-I-O-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[I&#x2F;O当应用程序发起 I&#x2F;O 调用后，会经历两个步骤：

内核等待 I&#x2F;O 设备准备好数据
内核将数据从内核空间拷贝到用户空间。

Java 中 3 种常见 IO 模型
BIO (Blocking I&#x2F;O)

同步阻塞 I&#x2F;O 模型，应用程序（线程）发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。

NIO (Non-blocking&#x2F;New I&#x2F;O)

I&#x2F;O 多路复用模型。属于同步非阻塞 I&#x2F;O 模型。应用程序会一直发起 read 调用，检查是否有数据。数据从内核空间拷贝到用户空间的这段时间，线程依然是阻塞。
相比于同步阻塞 I&#x2F;O，同步非阻塞 I&#x2F;O 避免了无数据阻塞。但是轮询十分消耗 CPU。
I&#x2F;O 多路复用模型。线程发起 select 调用，询问内核数据是否准备就绪，等内核数据准备好了，用户线程再发起 read 调用。
Java 中的 NIO ，有一个非常重要的选择器 ( Selector ) 的概念，也可以被称为 多路复用器。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。
一般 IO
InputStream 所有字节输入流的超类
FileInputStream 用于操作文件的读取
ByteArrayInputStream
FilterInputStream
BufferedInputStream
DataInputStream





&amp;nbsp;

OutputStream
FilterOutputStream
DataOutputStream
PrintStream
BufferedOutputStream





&amp;nbsp;Java 1.1 对基本 I&#x2F;O 流类库进行了重大改写。Reader 和 Writer 属于其中的新产物，不过它们的出现并不是取代 InputStream 和 OutputStream，因为 InputStream 和 OutputStream 在面向字节的 I&#x2F;O 仍然具有价值，Reader 和 Writer 则提供了兼容 Unicode 与面向字符的 I&#x2F;O。

Reader
InputStreamReader
FileReader




Writer
OutputStreamWriter
FileWriter


PrintWriter



案例 1
public static String getFileContent(String path) &#123;    StringBuilder result = new StringBuilder();    try (FileInputStream fileInputStream = new FileInputStream(path);         InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream, StandardCharsets.UTF_8);         BufferedReader bufferedReader = new BufferedReader(inputStreamReader);) &#123;        String readLine = null;        while ((readLine = bufferedReader.readLine()) != null) &#123;            result.append(readLine);        &#125;    &#125; catch (IOException e) &#123;        e.printStackTrace();        return null;    &#125;    return result.toString();&#125;

案例 2
public static void putFileContent(String content, String path) &#123;    try (PrintWriter printWriter = new PrintWriter(new File(path), &quot;GBK&quot;);         BufferedWriter bufferedWriter = new BufferedWriter(printWriter);) &#123;        bufferedWriter.write(content);    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;&#125;

BIOBlocking IO 的缩写，意思是阻塞型 IO
ServerSocket.accept() 方法会一直阻塞到一个连接建立，返回一个新的 Socket 用于客户端和服务器之间的通信。
如果为每个客户端创建一个新的 Thread，有以下问题: 

任何时候都可能有大量的线程处于休眠状态，只是等待输入或输出数据，造成资源浪费

需要为每个线程的调用栈都分配内存，内存消耗问题

即使忽略内存消耗问题，上下文的切换开销也很大


NIOChannelFileChannel、DatagramChannel、ServerSocketChannel、SocketChannel
Buffer
关于以下属性的解释可以参考：https://docs.oracle.com/javase/7/docs/api/java/nio/Buffer.html

mark: 缓冲区的 mark 是在调用 reset 方法时将其位置重置到的索引。
position: 缓冲区的 position 是下一个要读或写的元素的索引。缓冲区的位置永远不会为负，也永远不会大于其 limit。
limit: 缓冲区的 limit 是不应该读取或写入的第一个元素的索引。缓冲区的 limit 永远不会是负的，也永远不会超过它的 capacity 。
capacity: 缓冲区的 capacity 就是它包含的元素的数量。缓冲区的容量永远不会是负的，也永远不会改变。
具有 0 &lt;&#x3D; mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity 
clear(): 使 buffer 为新的读取或者相对 put 操作做好准备，它将设置 limit 为 capacity，并且 position 设置为 0
flip(): 使 buffer 为新的序列写入或者相对 get 操作做好准备，他将设置 limit 为当前的位置，并且设置 position 为 0
rewind(): 使 buffer 为重新读取已经包含的数据做好准备，它将保持 limit 不变，设置 position 为 0
只读 BufferbyteBuffer.asReadOnlyBuffer();

MappedByteBuffer文件的修改在堆外内存进行

https://docs.oracle.com/javase/8/docs/api/java/nio/MappedByteBuffer.html

Selectorselect() 方法是阻塞操作。但可以设置超时时间。
SelectionKey包含以下 int 类型常量 OP_READ、OP_WRITE、OP_CONNECT、OP_ACCEPT
]]></content>
  </entry>
  <entry>
    <title>Java Map 数据结构</title>
    <url>/2022/11/09/Language/Java/Java-Map-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[HashMap数据结构底层数据结构：数组 + 单向链表
Node&lt;K,V&gt;[] table;

static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;    // 该 Node 的 hash 值    final int hash;    final K key;    V value;    // 下一个节点    Node&lt;K,V&gt; next;    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;        this.hash = hash;        this.key = key;        this.value = value;        this.next = next;    &#125;    public final K getKey()        &#123; return key; &#125;    public final V getValue()      &#123; return value; &#125;    public final String toString() &#123; return key + &quot;=&quot; + value; &#125;    public final int hashCode() &#123;        return Objects.hashCode(key) ^ Objects.hashCode(value);    &#125;    public final V setValue(V newValue) &#123;        V oldValue = value;        value = newValue;        return oldValue;    &#125;    public final boolean equals(Object o) &#123;        if (o == this)            return true;        if (o instanceof Map.Entry) &#123;            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;            if (Objects.equals(key, e.getKey()) &amp;&amp;                Objects.equals(value, e.getValue()))                return true;        &#125;        return false;    &#125;&#125;



解决哈希冲突的方法: 开放定址法、再哈希法、链地址法等。参见这里

如何计算 Node.hash将 key.hashCode() 的返回值经过特定的扰动得到 hash 值。
JDK 7 的 hash 计算:
static int hash(int h) &#123;    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125;
JDK 8 的 hash 计算: 
static final int hash(Object key) &#123;    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;


如何得到元素位置(n - 1) &amp; hash

扩容的时机
构造之后，第一次 put。由于 table 是 null 所以会进行第一次 resize()

if ((tab = table) == null || (n = tab.length) == 0)    n = (tab = resize()).length;


put 之后如果当前 size 大于 threshold，进行 resize()

调用 treeifyBin()，如果 table 的长度小于 MIN_TREEIFY_CAPACITY，即 64，则放弃



tips: bin 表示大容器。

HashMap 的 table 长度为什么是 2 的幂次方一般考虑要用 hash 值做对 table.size 的取模运算得到余数，该余数才是存放的索引。
取余(%)运算，如果除数是 2 的幂次方，等价于其除数减一的与(&amp;)运算。也就是:
$hash % length &#x3D;&#x3D; hash&amp;(length-1)$
考虑到采用 &amp; 运算，相对于 % 效率更高，因此 HashMap 的长度是 2 的幂次方。
]]></content>
  </entry>
  <entry>
    <title>Java 日期操作问题汇总</title>
    <url>/2022/09/20/Language/Java/Java-%E6%97%A5%E6%9C%9F%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[Date获得本月第一天
Calendar calendar = Calendar.getInstance();calendar.set(Calendar.DAY_OF_MONTH, 1);Date date = calendar.getTime();

获得本月最后一天
Calendar calendar = Calendar.getInstance();calendar.add(Calendar.MONTH, 1);calendar.set(Calendar.DAY_OF_MONTH, 1);calendar.add(Calendar.DAY_OF_MONTH, -1);Date date = calendar.getTime();

]]></content>
  </entry>
  <entry>
    <title>Java 类(接口)的种类</title>
    <url>/2022/11/25/Language/Java/Java-%E7%B1%BB(%E6%8E%A5%E5%8F%A3)%E7%9A%84%E7%A7%8D%E7%B1%BB/</url>
    <content><![CDATA[0. 参考引用https://www.jianshu.com/p/107c05b29290
在 java.lang.Class#getEnclosingClass 的注释中有这么一段:
// There are five kinds of classes (or interfaces):// a) Top level classes// b) Nested classes (static member classes)// c) Inner classes (non-static member classes)// d) Local classes (named classes declared within a method)// e) Anonymous classes]]></content>
  </entry>
  <entry>
    <title>List Array String 转换操作注意</title>
    <url>/2022/10/26/Language/Java/List-Array-String%20%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E6%B3%A8%E6%84%8F/</url>
    <content><![CDATA[String: 通常使用 String 类型表示多元素，一般可能考虑界定符分隔元素。如: “1,2,3”，其中, “,” 表示界定符。

界定符字符串 &gt; Array

假设有一个字符串标识一组 ID，名称为 ids，
String[] idArray = ids.split(&quot;,&quot;);


注意，ids 如果为空字符串，会得到一个包含空字符的数组。因此可能需要判断是否为空。

String[] idArray = ids != null &amp;&amp; ids.trim().length() &gt; 0 ? ids.split(&quot;,&quot;) : new String[0];

如果还希望转换为 Integer[] 或者 Long[] 等:l
Arrays.stream(idArray).map(Integer::parseInt).toArray(Integer[]::new)]]></content>
  </entry>
  <entry>
    <title>PHPStorm XDebug 调试笔记</title>
    <url>/2022/09/23/Language/PHP/PHPStorm-XDebug-%E8%B0%83%E8%AF%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[PHPStorm1. 配置准备
tips 可能你的 php 已经下载了 XDebug，并且在 php.ini 有所配置，但是版本可能并不是恰当的。建议按照下面的步骤重新下载。

下载 Xdebug 插件, 访问XDebug 下载地址将控制台命令 php -i 输入进去就能提供适合的 XDebug 版本:

除了控制台输出，其他输出也可以，具体看官网的指引





补充 怎么快速粘贴 php -i 的输出内容, 可以考虑重定向输出到文件，比如:
C:\Users\94508&gt;php -i &gt; Desktop\phpinfo.txt
然后全选文本复制即可

将下载的文件放到特定目录，比如: D:\wamp64\bin\php\php7.1.33\zend_ext
配置 php.ini 的 XDebug 路径，需要找到 [xdebug] 节点:
[xdebug]zend_extension =&quot;d:/wamp64/bin/php/php7.1.33/zend_ext/php_xdebug-2.9.8-7.1-vc14-x86_64.dll&quot;xdebug.remote_enable = onxdebug.profiler_enable = offxdebug.profiler_enable_trigger = Offxdebug.profiler_output_name = cachegrind.out.%t.%pxdebug.profiler_output_dir =&quot;d:/wamp64/tmp&quot;xdebug.show_local_vars=0

2. PHP 脚本调试这种调试一般不用配置就可以进行脚本调试
之后就可以在 PHPStorm 通过 debug 按钮启动调试了



这种脚本调试与是否 Start Listening for PHP Debug Connections 无关（就是那个📞按钮）

3. 客户端调试这种调试方法也就是用 Postman 此类工具配合 PHPStorm 调试
在 phpForApache.ini 文件配置端口号 xdebug.remote_port:


注意别改错了，不是改 php.ini
注意不要选错 php 版本了，需要修改 wampserver 使用的版本
这个端口随便配置，只要没有被占用即可


[xdebug]zend_extension =&quot;d:/wamp64/bin/php/php7.1.33/zend_ext/php_xdebug-2.9.8-7.1-vc14-x86_64.dll&quot;xdebug.remote_enable = onxdebug.profiler_enable = offxdebug.profiler_enable_trigger = Offxdebug.profiler_output_name = cachegrind.out.%t.%pxdebug.profiler_output_dir =&quot;d:/wamp64/tmp&quot;xdebug.show_local_vars=0xdebug.remote_port = 9696

在 PHPStorm 配置 Xdebug 的端口, 此处的端口必须与 xdebug.remote_port 一致:



之后就可以调试了，注意开启📞按钮，PHPStorm 才可以监听

调试接口的时候必须添加 XDEBUG_SESSION_START 参数才可以，参数值是什么无所谓

]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 爬虫学习笔记</title>
    <url>/2022/06/29/Language/Python/Python-%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[Python 爬虫1. urllib1.1. 参考文档https://docs.python.org/3/howto/urllib2.html
1.2. 抓取 urlimport urllib.requestwith urllib.request.urlopen(&#x27;http://www.baidu.com/&#x27;) as response:    html = response.read()

如果你想抓取 url 并存储到临时文件夹下：
import shutilimport tempfileimport urllib.requestwith urllib.request.urlopen(&#x27;http://python.org/&#x27;) as response:    with tempfile.NamedTemporaryFile(delete=False) as tmp_file:        shutil.copyfileobj(response, tmp_file)with open(tmp_file.name) as html:    pass

定制化 Request
import urllib.requestreq = urllib.request.Request(&#x27;http://www.voidspace.org.uk&#x27;)with urllib.request.urlopen(req) as response:   the_page = response.read()

Dataimport urllib.parseimport urllib.requesturl = &#x27;http://www.someserver.com/cgi-bin/register.cgi&#x27;values = &#123;&#x27;name&#x27; : &#x27;Michael Foord&#x27;,          &#x27;location&#x27; : &#x27;Northampton&#x27;,          &#x27;language&#x27; : &#x27;Python&#x27; &#125;data = urllib.parse.urlencode(values)data = data.encode(&#x27;ascii&#x27;) # data should be bytesreq = urllib.request.Request(url, data)with urllib.request.urlopen(req) as response:   the_page = response.read()
2. requestshttps://requests.readthedocs.io/en/latest/
快速开始import requestsr = requests.get(&#x27;https://api.github.com/events&#x27;)r = requests.post(&#x27;https://httpbin.org/post&#x27;, data=&#123;&#x27;key&#x27;: &#x27;value&#x27;&#125;)r = requests.put(&#x27;https://httpbin.org/put&#x27;, data=&#123;&#x27;key&#x27;: &#x27;value&#x27;&#125;)r = requests.delete(&#x27;https://httpbin.org/delete&#x27;)r = requests.head(&#x27;https://httpbin.org/get&#x27;)r = requests.options(&#x27;https://httpbin.org/get&#x27;)# 设置编码格式r.encoding = &#x27;UTF-8&#x27;# 返回响应字符串r.text# 返回 url 地址r.url# 返回响应字节r.content# 响应状态码r.status_code# 响应头r.headers

GET 请求url = &#x27;https://www.baidu.com/s&#x27;headers = &#123;    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36&#x27;&#125;params = &#123;    &#x27;wd&#x27;: &#x27;北京&#x27;&#125;response = requests.get(url=url, params=params, headers=headers)

BS4# 返回数组soup.select(&#x27;#haha&#x27;)

seleniumheadlessfrom selenium import webdriverfrom selenium.webdriver.chrome.options import Optionsdef share_browser():    chrome_options = Options()    chrome_options.add_argument(&#x27;--headless&#x27;)    chrome_options.add_argument(&#x27;--disable-gpu&#x27;)    path = &#x27;C:\Program Files\Google\Chrome\Application\chrome.exe&#x27;    chrome_options.binary_location = path    return webdriver.Chrome(chrome_options=chrome_options)


requestspip install requests

Get 请求import requestsurl = &#x27;https://www.baidu.com/s&#x27;headers = &#123;    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36&#x27;&#125;params = &#123;    &#x27;wd&#x27;: &#x27;北京&#x27;&#125;response = requests.get(url=url, params=params, headers=headers)content = response.text


scrapy以下这段话来自 https://scrapy.org/

An open source and collaborative framework for extracting the data you need from websites.In a fast, simple, yet extensible way.

scrapy 是一个开源和协作框架，用于从网站上提取所需的数据。以快速，简单但可扩展的方式。
安装错误总结
来自于尚硅谷 Python 视频


缺少 twisted.test.raiser 扩展

http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted

升级 pip

python -m pip install --upgrade pip



快速开始
创建爬虫项目

scrapy startproject myproject

myproject 为自定义项目名称。项目名称必须以字母开头，并且只包含字母、数字、下划线。

命令执行完毕会得到如下目录：
├─myproject│  │  scrapy.cfg│  ││  └─myproject│      │  items.py│      │  middlewares.py│      │  pipelines.py│      │  settings.py│      │  __init__.py│      ││      └─spiders│              __init__.py



创建爬虫文件

scrapy genspider 爬虫名 爬取网页



运行爬虫代码

scrapy crawl 爬虫名


response获取响应字符串
response.text


获取响应二进制数据
response.body


获取
]]></content>
  </entry>
  <entry>
    <title>FastJSON 框架</title>
    <url>/2022/10/16/Framework/Java/JSON/FastJSON-%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[参考引用https://github.com/alibaba/fastjson
常见转换JSON &gt;&gt; Java BeanString json = &quot;&quot;;JSONObject.parseObject(json, SubtaskDurationOpenApiQuery.class);


Java Bean 字段名称转换
类注解




enum 类型
说明
Java属性名
JSON属性名



CamelCase
驼峰命名,首字母小写
UserName
userName


PascalCase
帕斯卡命名,首字母大写
userName
UserName


SnakeCase
蛇形命名,大写转小写并以下划线连接
userName
user_name


KebabCase
短横线命名,大写转小写并以短横线连接
userName
user-name


@JSONType(naming = PropertyNamingStrategy.SnakeCase)


字段注解

@JSONField(name = &quot;student_id&quot;)

]]></content>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON-lib 框架</title>
    <url>/2022/11/21/Framework/Java/JSON/JSON-lib-%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[参考引用https://json-lib.sourceforge.net/
maven 依赖&lt;dependency&gt;    &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt;    &lt;artifactId&gt;json-lib&lt;/artifactId&gt;    &lt;version&gt;2.2.3&lt;/version&gt;&lt;/dependency&gt;


使用方式JSON &gt;&gt; Java Beanpublic class Bean &#123;    private Integer id;    private String name;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;&#125;

String json = &quot;&#123;\&quot;id\&quot;:1, \&quot;name\&quot;: \&quot;jcb\&quot;&#125;&quot;;JSONObject jsonObject = JSONObject.fromObject(json);Bean bean = (Bean) JSONObject.toBean(jsonObject, Bean.class);System.out.println(bean);


使用时需要注意，该 Bean 不可以是：

不能是处于同一 java 文件下声明的类。因为必须具有 public 修饰符
不能是私有内部类。因为必须具有 public 修饰符

]]></content>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>Jackson 框架</title>
    <url>/2022/10/16/Framework/Java/JSON/Jackson-%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[参考引用Java Bean 字段名称转换
类注解




Class
说明
Java属性名
JSON属性名



CamelCase
驼峰命名,首字母小写
personId
persionId


PascalCase
帕斯卡命名,首字母大写
personId
PersonId


SnakeCase
蛇形命名,大写转小写并以下划线连接
personId
person_id


KebabCase
短横线命名,大写转小写并以短横线连接
personId
person-id


@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)


字段注解

@JSONField(name = &quot;student_id&quot;)
]]></content>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis BoundSql 记录</title>
    <url>/2022/11/22/Framework/Java/MyBatis/MyBatis-BoundSql-%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[0. 参考引用由谁创建BoundSql 是由 SqlSource 创建。更准确地说，是由 StaticSqlSource
public interface SqlSource &#123;  BoundSql getBoundSql(Object parameterObject);&#125;



杂项问题关于 additionalParametersadditionalParameters 是 BoundSql 中的一个属性，类型是 HashMap。
其中存储的属性可能有:

_parameter
_databaseId
一些 __frch_ 前缀的 index 或者 item

public BoundSql getBoundSql(Object parameterObject) &#123;    DynamicContext context = new DynamicContext(configuration, parameterObject);    rootSqlNode.apply(context);    SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration);    Class&lt;?&gt; parameterType = parameterObject == null ? Object.class : parameterObject.getClass();    SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());    BoundSql boundSql = sqlSource.getBoundSql(parameterObject);    context.getBindings().forEach(boundSql::setAdditionalParameter);    return boundSql;&#125;

以下是各个版本不同的判断存在的方法: 
// 3.3.0public boolean hasAdditionalParameter(String name) &#123;	return this.metaParameters.hasGetter(name);&#125;

// 3.4.1public boolean hasAdditionalParameter(String name) &#123;    PropertyTokenizer prop = new PropertyTokenizer(name);    String indexedName = prop.getIndexedName();    return additionalParameters.containsKey(indexedName);&#125;


// 3.4.2 ~ 3.5.6public boolean hasAdditionalParameter(String name) &#123;    String paramName = (new PropertyTokenizer(name)).getName();        return this.additionalParameters.containsKey(paramName);&#125;


public Object getAdditionalParameter(String name) &#123;    return metaParameters.getValue(name);&#125;]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis Mapper 方法参数处理流程</title>
    <url>/2022/11/17/Framework/Java/MyBatis/MyBatis-Mapper-%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[参考引用org.apache.ibatis.reflection.ParamNameResolver#wrapToMapIfCollection
结论
如果传入的是单个参数
参数类型是 Collection，可以使用 collection 参数名
参数类型是 List，可以使用 list 参数名
参数类型是数组，可以使用 array 参数名




为了较好的语义性，在单个参数是集合或者数组时，可以使用 @Param 进行命名。

分析应当知道，当程序调用 Mapper 接口的方法时，将会调用 MapperProxy 的 invoke 方法，其中会对方法进行解析并缓存，缓存的数据结构是一个 Map，位于 MapperProxy 。
private final Map&lt;Method, MapperMethodInvoker&gt; methodCache;// 之前版本private final Map&lt;Method, MapperMethod&gt; methodCache;

methodCache 的 key 是 Java 反射的 Method，value 是 MapperMethodInvoker。


在之前的版本中，value 是 MapperMethod，其实新版是为了兼容 default 方法做出的扩展。只需要记住 MapperMethodInvoker 是用于执行方法的。


MapperMethodInvoker 有 2 个实现类，PlainMethodInvoker 和 DefaultMethodInvoker。这里我们只需要了解 PlainMethodInvoker，因为它是 SQL Statement 的执行入口。PlainMethodInvoker 将 MapperMethod 包装起来，在构造 PlainMethodInvoker 时需要传入一个 MapperMethod 对象。
MapperMethod 的构造器如下：
public MapperMethod(Class&lt;?&gt; mapperInterface, Method method, Configuration config) &#123;	this.command = new SqlCommand(config, mapperInterface, method);	this.method = new MethodSignature(config, mapperInterface, method);&#125;

其中的 MethodSignature 跟参数处理密切相关，观察 MethodSignature 构造方法：
public MethodSignature(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method) &#123;	Type resolvedReturnType = TypeParameterResolver.resolveReturnType(method, mapperInterface);	if (resolvedReturnType instanceof Class&lt;?&gt;) &#123;		this.returnType = (Class&lt;?&gt;) resolvedReturnType;	&#125; else if (resolvedReturnType instanceof ParameterizedType) &#123;		this.returnType = (Class&lt;?&gt;) ((ParameterizedType) resolvedReturnType).getRawType();	&#125; else &#123;		this.returnType = method.getReturnType();	&#125;	this.returnsVoid = void.class.equals(this.returnType);	this.returnsMany = configuration.getObjectFactory().isCollection(this.returnType) || this.returnType.isArray();	this.returnsCursor = Cursor.class.equals(this.returnType);	this.returnsOptional = Optional.class.equals(this.returnType);	this.mapKey = getMapKey(method);	this.returnsMap = this.mapKey != null;	this.rowBoundsIndex = getUniqueParamIndex(method, RowBounds.class);	this.resultHandlerIndex = getUniqueParamIndex(method, ResultHandler.class);	// 创建参数名解析器	this.paramNameResolver = new ParamNameResolver(configuration, method);&#125;

主要关注其中一个组件 ParamNameResolver，ParamNameResolver 构造方法如下，它接收一个 Configuration，以及一个反射的 Method。
public ParamNameResolver(Configuration config, Method method) &#123;	// configuration 就是为了获得一些全局的配置	this.useActualParamName = config.isUseActualParamName();	final Class&lt;?&gt;[] paramTypes = method.getParameterTypes();	final Annotation[][] paramAnnotations = method.getParameterAnnotations();	final SortedMap&lt;Integer, String&gt; map = new TreeMap&lt;&gt;();	int paramCount = paramAnnotations.length;	// get names from @Param annotations	for (int paramIndex = 0; paramIndex &lt; paramCount; paramIndex++) &#123;		if (isSpecialParameter(paramTypes[paramIndex])) &#123;			// skip special parameters			continue;		&#125;		// 寻找该参数是否有 @Param 注解		String name = null;		for (Annotation annotation : paramAnnotations[paramIndex]) &#123;			if (annotation instanceof Param) &#123;				// 该属性记录整个方法有没有任何一个参数被 @Param 注解，便于后面针对 1 个参数时的处理				this.hasParamAnnotation = true;				name = ((Param) annotation).value();				break;			&#125;		&#125;		if (name == null) &#123;			// 未找到			if (useActualParamName) &#123;				// 使用实际的参数名				name = getActualParamName(method, paramIndex);			&#125;			if (name == null) &#123;				// use the parameter index as the name (&quot;0&quot;, &quot;1&quot;, ...)				// gcode issue #71				name = String.valueOf(map.size());			&#125;		&#125;		map.put(paramIndex, name);	&#125;	this.names = Collections.unmodifiableSortedMap(map);&#125;

经过初步的参数准备之后，会得到一个名称为 names 的 Map 结构，其 key 为 paramIndex，value 为 参数名。


我比较疑惑的一点是 names 既然索引从 0 开始，为什么不设计成一个 List。


这些工作准备好之后，当调用 MapperMethod 的 execute 方法时，将会派上用场。因为我们需要传递一个 MyBatis 可以识别的参数数据结构来给 SqlSession，便于它将 #&#123;&#125; 替换为准确的参数类型。所以，在传递给 SqlSession 参数的时候，会对参数再次进行处理。
// MethodSignature.javapublic Object convertArgsToSqlCommandParam(Object[] args) &#123;	return paramNameResolver.getNamedParams(args);&#125;
这里，我们再次使用 ParamNameResolver，调用其 getNamedParams 方法获得参数：
// ParamNameResolver.javcapublic Object getNamedParams(Object[] args) &#123;	// 获得之前准备的 names	final int paramCount = this.names.size();	if (args == null || paramCount == 0) &#123;		return null;	&#125; else if (!hasParamAnnotation &amp;&amp; paramCount == 1) &#123;		// 如果只有一个参数，而且没有被 @Param 注解		Object value = args[names.firstKey()];		// 包装		return wrapToMapIfCollection(value, useActualParamName ? names.get(0) : null);	&#125; else &#123;		final Map&lt;String, Object&gt; param = new ParamMap&lt;&gt;();		int i = 0;		for (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) &#123;			param.put(entry.getValue(), args[entry.getKey()]);			// add generic param names (param1, param2, ...)			// 添加通用的名称			final String genericParamName = GENERIC_NAME_PREFIX + (i + 1);			// ensure not to overwrite parameter named with @Param			// 保证 @Param 的高优先级，不能被覆盖了			if (!names.containsValue(genericParamName)) &#123;				param.put(genericParamName, args[entry.getKey()]);			&#125;			i++;		&#125;		return param;	&#125;&#125;public static Object wrapToMapIfCollection(Object object, String actualParamName) &#123;	if (object instanceof Collection) &#123;		ParamMap&lt;Object&gt; map = new ParamMap&lt;&gt;();		map.put(&quot;collection&quot;, object);		if (object instanceof List) &#123;			map.put(&quot;list&quot;, object);		&#125;		Optional.ofNullable(actualParamName).ifPresent(name -&gt; map.put(name, object));		return map;	&#125; else if (object != null &amp;&amp; object.getClass().isArray()) &#123;		ParamMap&lt;Object&gt; map = new ParamMap&lt;&gt;();		map.put(&quot;array&quot;, object);		Optional.ofNullable(actualParamName).ifPresent(name -&gt; map.put(name, object));		return map;	&#125;	return object;&#125;

在经过 getNamedParams 处理过后，将会得到传递给 sqlSession 的 parameter 参数，这个参数有以下取值：

可以是 null
可以是一个 Java Bean
可以是一个 ParamMap

parameter 传递给 SqlSession 之后，不管是 query，还是 update，最终都会将参数传递给 MappedStatement 的 getBoundSql 方法获取 BoundSql。
// MappedStatement.javapublic BoundSql getBoundSql(Object parameterObject) &#123;	BoundSql boundSql = sqlSource.getBoundSql(parameterObject);	List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();	if (parameterMappings == null || parameterMappings.isEmpty()) &#123;		boundSql = new BoundSql(configuration, boundSql.getSql(), parameterMap.getParameterMappings(),				parameterObject);	&#125;	// check for nested result maps in parameter mappings (issue #30)	for (ParameterMapping pm : boundSql.getParameterMappings()) &#123;		String rmId = pm.getResultMapId();		if (rmId != null) &#123;			ResultMap rm = configuration.getResultMap(rmId);			if (rm != null) &#123;				hasNestedResultMaps |= rm.hasNestedResultMaps();			&#125;		&#125;	&#125;	return boundSql;&#125;

由 MappedStatement.getBoundSql 方法可知，它又将 parameter 传递给 SqlSource.getBoundSql，SqlSource 一般分为 RawSqlSource 和 DynamicSqlSource。RawSqlSource 表示那些没有动态标签（如：&lt;if/&gt;）的 SQL，DynamicSqlSource 则表示动态 SQL。
RawSqlSource 的 getBoundSql 非常简单，将实现细节委托给了其内部的 sqlSource。
// RawSqlSource.javapublic BoundSql getBoundSql(Object parameterObject) &#123;	return sqlSource.getBoundSql(parameterObject);&#125;

RawSqlSource 内部的 SqlSource 是在其实例化的时候构建的，通过构造一个 SqlSourceBuilder，调用其 parse 方法返回一个 sqlSource。
public RawSqlSource(Configuration configuration, String sql, Class&lt;?&gt; parameterType) &#123;	SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration);	Class&lt;?&gt; clazz = parameterType == null ? Object.class : parameterType;	this.sqlSource = sqlSourceParser.parse(sql, clazz, new HashMap&lt;&gt;());&#125;

SqlSourceBuilder.parse 方法返回的其实是一个 StaticSqlSource
public SqlSource parse(String originalSql, Class&lt;?&gt; parameterType, Map&lt;String, Object&gt; additionalParameters) &#123;	// 创建一个参数映射token的处理器，传入下面的 GenericTokenParser, 可以将 #&#123;&#125; 以及中间的部分转换为 ?	ParameterMappingTokenHandler handler = new ParameterMappingTokenHandler(configuration, parameterType,			additionalParameters);	GenericTokenParser parser = new GenericTokenParser(&quot;#&#123;&quot;, &quot;&#125;&quot;, handler);	String sql;	if (configuration.isShrinkWhitespacesInSql()) &#123;		sql = parser.parse(removeExtraWhitespaces(originalSql));	&#125; else &#123;		sql = parser.parse(originalSql);	&#125;	return new StaticSqlSource(configuration, sql, handler.getParameterMappings());&#125;

经过 GenericTokenParser 和 ParameterMappingTokenHandler 配合解析，原始 Sql 中的 #&#123;&#125; 将全部替换为 ?，并且在解析过程 中，ParameterMappingTokenHandler 会得到一份 List&lt;ParameterMapping&gt; 参数映射列表，保存着每个占位符所需要的参数详细信息。
得到 StaticSqlSource 之后，便可以由它创建一个 BoundSql。
public BoundSql getBoundSql(Object parameterObject) &#123;	return new BoundSql(configuration, sql, parameterMappings, parameterObject);&#125;


BoudSql 的在对 Statement 进行预处理的时候发挥作用。
private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException &#123;	Statement stmt;	Connection connection = getConnection(statementLog);	stmt = handler.prepare(connection, transaction.getTimeout());	handler.parameterize(stmt);	return stmt;&#125;

主要观察 StatementHandler 的参数化方法 parameterize。
// PreparedStatementHandler.javapublic void parameterize(Statement statement) throws SQLException &#123;	parameterHandler.setParameters((PreparedStatement) statement);&#125;

public void setParameters(PreparedStatement ps) &#123;	ErrorContext.instance().activity(&quot;setting parameters&quot;).object(mappedStatement.getParameterMap().getId());	// 获得 BoundSql 中存储的参数映射列表	List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();	if (parameterMappings != null) &#123;		for (int i = 0; i &lt; parameterMappings.size(); i++) &#123;			ParameterMapping parameterMapping = parameterMappings.get(i);			if (parameterMapping.getMode() != ParameterMode.OUT) &#123;				Object value;				String propertyName = parameterMapping.getProperty();				if (boundSql.hasAdditionalParameter(propertyName)) &#123; // issue #448 ask first for additional params					value = boundSql.getAdditionalParameter(propertyName);				&#125; else if (parameterObject == null) &#123;					value = null;				&#125; else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;					value = parameterObject;				&#125; else &#123;					MetaObject metaObject = configuration.newMetaObject(parameterObject);					value = metaObject.getValue(propertyName);				&#125;				TypeHandler typeHandler = parameterMapping.getTypeHandler();				JdbcType jdbcType = parameterMapping.getJdbcType();				if (value == null &amp;&amp; jdbcType == null) &#123;					jdbcType = configuration.getJdbcTypeForNull();				&#125;				try &#123;					typeHandler.setParameter(ps, i + 1, value, jdbcType);				&#125; catch (TypeException | SQLException e) &#123;					throw new TypeException(							&quot;Could not set parameters for mapping: &quot; + parameterMapping + &quot;. Cause: &quot; + e, e);				&#125;			&#125;		&#125;	&#125;&#125;

]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis ParameterHandler 记录</title>
    <url>/2022/11/22/Framework/Java/MyBatis/MyBatis-ParameterHandler-%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[作用区域当 MyBatis 在 PreparedStatement 设置参数时。
默认实现DefaultParameterHandler
关键方法public void setParameters(PreparedStatement ps) &#123;    ErrorContext.instance().activity(&quot;setting parameters&quot;).object(mappedStatement.getParameterMap().getId());    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();    if (parameterMappings != null) &#123;        for (int i = 0; i &lt; parameterMappings.size(); i++) &#123;            ParameterMapping parameterMapping = parameterMappings.get(i);            if (parameterMapping.getMode() != ParameterMode.OUT) &#123;                Object value;                String propertyName = parameterMapping.getProperty();                if (boundSql.hasAdditionalParameter(propertyName)) &#123; // issue #448 ask first for additional params                    value = boundSql.getAdditionalParameter(propertyName);                &#125; else if (parameterObject == null) &#123;                    value = null;                &#125; else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;                    value = parameterObject;                &#125; else &#123;                    MetaObject metaObject = configuration.newMetaObject(parameterObject);                    value = metaObject.getValue(propertyName);                &#125;                TypeHandler typeHandler = parameterMapping.getTypeHandler();                JdbcType jdbcType = parameterMapping.getJdbcType();                if (value == null &amp;&amp; jdbcType == null) &#123;                    jdbcType = configuration.getJdbcTypeForNull();                &#125;                try &#123;                    typeHandler.setParameter(ps, i + 1, value, jdbcType);                &#125; catch (TypeException | SQLException e) &#123;                    throw new TypeException(                            &quot;Could not set parameters for mapping: &quot; + parameterMapping + &quot;. Cause: &quot; + e, e);                &#125;            &#125;        &#125;    &#125;&#125;


]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis Transaction</title>
    <url>/2022/11/24/Framework/Java/MyBatis/MyBatis-Transaction/</url>
    <content><![CDATA[Transaction何时构建 Transaction答案是，在 openSession 的时候构建了 Transaction 对象。
private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level,        boolean autoCommit) &#123;    Transaction tx = null;    try &#123;        final Environment environment = configuration.getEnvironment();        final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);        tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);        final Executor executor = configuration.newExecutor(tx, execType);        return new DefaultSqlSession(configuration, executor, autoCommit);    &#125; catch (Exception e) &#123;        closeTransaction(tx); // may have fetched a connection so lets call close()        throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);    &#125; finally &#123;        ErrorContext.instance().reset();    &#125;&#125;

第 6 行显示，从 TransactionFactory 构造了一个 Transaction 对象。
在 openConnection 的时候并没有获取连接，更没有开启事务，只是根据配置文件构建了事务对象，更关键的点是执行器的构造方法，构建出来的事务对象通过构造方法被注入到了执行器当中，这一点对后续mybatis的事务体系相当重要。
MyBatis 默认提供两种事务:JdbcTransaction 和 ManagedTransaction；如果将 MyBatis 和 Spring 一起使用，则提供了一个 SpringManagedTransaction
mybatis-spring
注意 如果你打算将 MyBatis 与 Spring 一起使用，则不需要配置任何 TransactionManager，因为 Spring 模块将设置自己的 TransactionManager，覆盖之前设置的任何配置。原因参见MyBatis Spring 覆盖自定义 Environment

Transactions使用 MyBatis-Spring 的一个主要原因是它允许 MyBatis 参与 Spring 事务。MyBatis-Spring 没有创建一个特定于 MyBatis 的新事务管理器，而是利用了 Spring 现有的 DataSourceTransactionManager。
一旦配置了 Spring 事务管理器，你就可以像往常一样在 Spring 中配置事务。@Transactional 注解和 AOP 样式的配置都支持。将创建一个 SqlSession 对象，并在事务持续期间使用它。当事务完成时，将根据情况提交或回滚此会话。
一旦设置了事务，MyBatis-Spring 将透明地管理它们。在 DAO 类中不需要额外的代码。
Standard Configuration要启用 Spring 事务处理，只需在 Spring 配置文件中创建一个 DataSourceTransactionManager:
&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;  &lt;constructor-arg ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt;

@Configurationpublic class DataSourceConfig &#123;    @Bean    public DataSourceTransactionManager transactionManager() &#123;      return new DataSourceTransactionManager(dataSource());    &#125;&#125;

指定的 DataSource 可以是 Spring 通常使用的任何 JDBC 数据源。折包括连接池以及通过 JNDI 查找获得的数据源 DataSource。
注意，为事务管理器指定的数据源必须与用于创建 SqlSessionFactoryBean 的数据源相同，否则事务管理将无法工作。
Container Managed Transactions如果你正在使用 JEE 容器，并且希望 Spring 参与容器管理事务（CMT），那么应该用 JtaTransactionManager 或折它的一个特定于容器的子类来配置 Spring。最简单的方法是使用 Spring 事务名称空间或 JtaTransactionManagerFactoryBean:
&lt;tx:jta-transaction-manager /&gt;

@Configurationpublic class DataSourceConfig &#123;  @Bean  public JtaTransactionManager transactionManager() &#123;    return new JtaTransactionManagerFactoryBean().getObject();  &#125;&#125;

Programmatic Transaction ManagementMyBatis SqlSession 提供特定的方法以编程方式处理事务。但是，当你使用 MyBatis-Spring 时，你的 Bean 将会以 Spring 管理的 SqlSession 或者是一个 Spring 管理的 mapper 注入。这意味着 Spring 将始终处理你的事务。
不能在 Spring 管理的 SqlSession 上调用 SqlSession.commit()，SqlSession.rollback()或者是 SqlSession.close()。如果尝试这样做，则会抛出 UnsupportedOperationException 异常。注意，这些方法不会在注入的 mapper 类中公开。
无论你的 JDBC 连接的 autocommit 设置无论，SqlSession 数据方法的任何执行或者对 Spring 事务之外的 mapper 方法的任何调用都是自动提交。
这段代码展示了如何使用 PlatformTransactionManager 手动处理事务。
public class UserService &#123;  private final PlatformTransactionManager transactionManager;  public UserService(PlatformTransactionManager transactionManager) &#123;    this.transactionManager = transactionManager;  &#125;  public void createUser() &#123;    TransactionStatus txStatus =        transactionManager.getTransaction(new DefaultTransactionDefinition());    try &#123;      userMapper.insertUser(user);    &#125; catch (Exception e) &#123;      transactionManager.rollback(txStatus);      throw e;    &#125;    transactionManager.commit(txStatus);  &#125;&#125;

你可以使用 TransactionTemplate 忽略调用提交和回滚方法。
public class UserService &#123;  private final PlatformTransactionManager transactionManager;  public UserService(PlatformTransactionManager transactionManager) &#123;    this.transactionManager = transactionManager;  &#125;  public void createUser() &#123;    TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager);    transactionTemplate.execute(txStatus -&gt; &#123;      userMapper.insertUser(user);      return null;    &#125;);  &#125;&#125;

注意，这段代码使用了一个 mapper，但是它还是会以一个 SqlSession 来工作。
Spring 将会以 SqlSessionTemplate 取代原来的 DefaultSqlSession。
SqlSessionTemplate 是一种代理模式的设计思想，其所有的方法全部由内部属性 sqlSessionProxy 执行。
sqlSessionProxy 本质上也是一个 JDK 动态代理对象。其真正的执行者是 SqlSessionInterceptor。
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis XMLConfigBuilder parse 过程</title>
    <url>/2022/11/25/Framework/Java/MyBatis/MyBatis-XMLConfigBuilder-parse-%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[Configuration 是 MyBatis 的全局配置类，保存了各种对象：

Enviroment：数据源环境对象
MapperRegistry：Mapper 注册表
TypeHandlerRegistry：TypeHandler 注册表
TypeAliasRegistry：Class 别名注册表
Map&lt;String, MappedStatement&gt;：MappedStatement 注册表
Map&lt;String, ResultMap&gt;：ResultMap 注册表
Map&lt;String, ParameterMap&gt;：ParameterMap 注册表

1. XMLConfigBuilder.parse为了得到 SqlSessionFactory，我们需要通过调用 SqlSessionFactoryBuilder 的 build 方法，该方法有很多重载方法：
public SqlSessionFactory build(Reader reader);public SqlSessionFactory build(Reader reader, String environment);public SqlSessionFactory build(Reader reader, Properties properties);public SqlSessionFactory build(Reader reader, String environment, Properties properties);public SqlSessionFactory build(InputStream inputStream);public SqlSessionFactory build(InputStream inputStream, String environment);public SqlSessionFactory build(InputStream inputStream, Properties properties);public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties);public SqlSessionFactory build(Configuration config);

这些方法殊途同归，最终都是调用 build(Configuration) 传入一个 Configuration 对象，你可以直接在代码中构造 Configuration，也可以通过传入 XML 资源，解析构造。当前，比较通用的应该是通过传入 XML 资源构建 Configuration。


你也可以直接通过 new 的方法创建 SqlSessionFactory，不过你需要准备一个 Configuration 对象。其实，SqlSessionFactoryBuilder 的 build(Configuration) 也就是传入 Configuration 创建并返回了一个 SqlSessionFactory。但是，应该没有人这么做吧，大多数还是选择使用配置文件的方式创建 Configuration。


以下是一个典型的构建方法：
// SqlSessionFactoryBuilder.javapublic SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123;	try &#123;		XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);		return build(parser.parse());	&#125; catch (Exception e) &#123;		throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);	&#125; finally &#123;		// 收尾操作，如：关闭 inputStream 等，略	&#125;&#125;

build 方法中创建了一个 XMLConfigBuilder 用于解析配置文件，解析完成之后会返回一个 Configuration 对象。
// XMLConfigBuilder.javapublic Configuration parse() &#123;	if (parsed) &#123;		throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);	&#125;	parsed = true;	parseConfiguration(parser.evalNode(&quot;/configuration&quot;));	return configuration;&#125;



MyBatis 源码包含许多以 Builder 为后缀的类，它们很多时候往往都充当一种解析器的角色，并且它们往往都有 parse 之类的方法。
顾名思义，XMLConfigBuilder 是用于解析 mybatis-config.xml 文件的，与之类似的还有 XMLMapperBuilder 用于解析 mapper.xml


XMLConfigBuilder.parse() 会调用其内部的 XPathParser 进行 DOM 节点分析，比如首先执行 parser.evalNode(&quot;/configuration&quot;) 解析 &lt;configuration&gt; 根节点。字面量 /configuration 是一种 XPath 语法解析，这里只需要知道返回的是一个 MyBatis 自定义的 XNode 节点，而且该节点表示根节点 &lt;configuration&gt;。
// XPathParser.java// 通过传入 XPath 表达式，得到节点 XNodepublic XNode evalNode(String expression) &#123;  return evalNode(document, expression);&#125;

这里引入了 XPathParser 用于 DOM 解析，底层是使用了 DOM 包以及 XPath 语法。

得到代表 &lt;configuration&gt; 的 XNode 对象之后，将其传递给 XMLConfigurationBuilder.parseConfiguration 方法 ，该方法如下：
// XMLConfigBuilder.javaprivate void parseConfiguration(XNode root) &#123;  try &#123;    // issue #117 read properties first    // # 2. propertiesElement    propertiesElement(root.evalNode(&quot;properties&quot;));    Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));    loadCustomVfs(settings);    loadCustomLogImpl(settings);    // # 3. typeAliasesElement    typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));    // # 4. pluginElement    pluginElement(root.evalNode(&quot;plugins&quot;));    // # 5. objectFactoryElement    objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));    // # 6. objectWrapperFactoryElement    objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));    // # 7. reflectorFactoryElement    reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));    // # 8. settingsElement    settingsElement(settings);    // read it after objectFactory and objectWrapperFactory issue #631    // # 9. environmentsElement    environmentsElement(root.evalNode(&quot;environments&quot;));    // # 10. databaseIdProviderElement    databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));    // # 11. typeHandlerElement    typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));    // # 12. mapperElement    mapperElement(root.evalNode(&quot;mappers&quot;));  &#125; catch (Exception e) &#123;    throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);  &#125;&#125;


parseConfiguration 方法依次解析 &lt;configuration&gt; 的子元素
解析 &lt;configuration&gt; 子元素的方法都是类似 xxxElement 为方法名的，其中 xxx 表示子元素的元素名称，如：解析 &lt;properties&gt; 元素的方法则是 ropertiesElement()


2. propertiesElement解析属性元素
private void propertiesElement(XNode context) throws Exception &#123;	if (context != null) &#123;		return;	&#125;	// 1. 获得 &lt;properties&gt; 子元素的属性	Properties defaults = context.getChildrenAsProperties();	// 2. 获得 resource 和 url 指向的资源	String resource = context.getStringAttribute(&quot;resource&quot;);	String url = context.getStringAttribute(&quot;url&quot;);	// 不允许同时存在 resource 和 url	if (resource != null &amp;&amp; url != null) &#123;	  throw new BuilderException(&quot;The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.&quot;);	&#125;	if (resource != null) &#123;	  defaults.putAll(Resources.getResourceAsProperties(resource));	&#125; else if (url != null) &#123;	  defaults.putAll(Resources.getUrlAsProperties(url));	&#125;	Properties vars = configuration.getVariables(); // Flag1	if (vars != null) &#123;	  defaults.putAll(vars);	&#125;	parser.setVariables(defaults);	configuration.setVariables(defaults);&#125;


由上面代码的逻辑可以得到一些结论：
结论一 resource 和 url 只能使用其中一个，否则会抛出异常。
结论二 属性优先级由高到低：build传参 &gt; resource 或者 url &gt; 子元素
Flag1语句是从 configuration 中取出原有的 variables，如果不等于 null，则将其属性添加并覆盖到 defaults，而原来的属性是由 SqlSessionFactory.build 传递进来的，然后交给 XMLConfigBuilder，最终设置到 configuration 的 variables 中。
private XMLConfigBuilder(XPathParser parser, String environment, Properties props) &#123;	super(new Configuration());	ErrorContext.instance().resource(&quot;SQL Mapper Configuration&quot;);	this.configuration.setVariables(props);	this.parsed = false;	this.environment = environment;	this.parser = parser;&#125;


3. typeAliasesElement主要是获取所有的子节点，根据是否是 package 执行不同的逻辑。
private void typeAliasesElement(XNode parent) &#123;	if (parent != null) &#123;		return ;	&#125;	for (XNode child : parent.getChildren()) &#123;		if (&quot;package&quot;.equals(child.getName())) &#123;			String typeAliasPackage = child.getStringAttribute(&quot;name&quot;);			configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);		&#125; else &#123;			String alias = child.getStringAttribute(&quot;alias&quot;);			String type = child.getStringAttribute(&quot;type&quot;);			try &#123;				Class&lt;?&gt; clazz = Resources.classForName(type);				if (alias == null) &#123;					// xml 没有配置 alias 属性，会寻找 @Alias 注解					typeAliasRegistry.registerAlias(clazz);				&#125; else &#123;					typeAliasRegistry.registerAlias(alias, clazz);				&#125;			&#125; catch (ClassNotFoundException e) &#123;				throw new BuilderException(&quot;Error registering typeAlias for &#x27;&quot; + alias + &quot;&#x27;. Cause: &quot; + e, e);			&#125;		&#125;	&#125;&#125;


尽管代码中并没有规定子元素非 package 即 typeAlias，但 XML 的 schema 文件声明规定，必须是这两种。

8. settingsElement读取 settings 配置，这里比较简单，读取属性文件，进行赋值。
private void settingsElement(Properties props) &#123;	configuration.setAutoMappingBehavior(			AutoMappingBehavior.valueOf(props.getProperty(&quot;autoMappingBehavior&quot;, &quot;PARTIAL&quot;)));	configuration.setAutoMappingUnknownColumnBehavior(AutoMappingUnknownColumnBehavior			.valueOf(props.getProperty(&quot;autoMappingUnknownColumnBehavior&quot;, &quot;NONE&quot;)));	configuration.setCacheEnabled(booleanValueOf(props.getProperty(&quot;cacheEnabled&quot;), true));	configuration.setProxyFactory((ProxyFactory) createInstance(props.getProperty(&quot;proxyFactory&quot;)));	configuration.setLazyLoadingEnabled(booleanValueOf(props.getProperty(&quot;lazyLoadingEnabled&quot;), false));	configuration.setAggressiveLazyLoading(booleanValueOf(props.getProperty(&quot;aggressiveLazyLoading&quot;), false));	configuration			.setMultipleResultSetsEnabled(booleanValueOf(props.getProperty(&quot;multipleResultSetsEnabled&quot;), true));	configuration.setUseColumnLabel(booleanValueOf(props.getProperty(&quot;useColumnLabel&quot;), true));	configuration.setUseGeneratedKeys(booleanValueOf(props.getProperty(&quot;useGeneratedKeys&quot;), false));	configuration.setDefaultExecutorType(ExecutorType.valueOf(props.getProperty(&quot;defaultExecutorType&quot;, &quot;SIMPLE&quot;)));	configuration.setDefaultStatementTimeout(integerValueOf(props.getProperty(&quot;defaultStatementTimeout&quot;), null));	configuration.setDefaultFetchSize(integerValueOf(props.getProperty(&quot;defaultFetchSize&quot;), null));	configuration.setDefaultResultSetType(resolveResultSetType(props.getProperty(&quot;defaultResultSetType&quot;)));	configuration.setMapUnderscoreToCamelCase(booleanValueOf(props.getProperty(&quot;mapUnderscoreToCamelCase&quot;), false));	configuration.setSafeRowBoundsEnabled(booleanValueOf(props.getProperty(&quot;safeRowBoundsEnabled&quot;), false));	configuration.setLocalCacheScope(LocalCacheScope.valueOf(props.getProperty(&quot;localCacheScope&quot;, &quot;SESSION&quot;)));	configuration.setJdbcTypeForNull(JdbcType.valueOf(props.getProperty(&quot;jdbcTypeForNull&quot;, &quot;OTHER&quot;)));	configuration.setLazyLoadTriggerMethods(			stringSetValueOf(props.getProperty(&quot;lazyLoadTriggerMethods&quot;), &quot;equals,clone,hashCode,toString&quot;));	configuration.setSafeResultHandlerEnabled(booleanValueOf(props.getProperty(&quot;safeResultHandlerEnabled&quot;), true));	configuration.setDefaultScriptingLanguage(resolveClass(props.getProperty(&quot;defaultScriptingLanguage&quot;)));	configuration.setDefaultEnumTypeHandler(resolveClass(props.getProperty(&quot;defaultEnumTypeHandler&quot;)));	configuration.setCallSettersOnNulls(booleanValueOf(props.getProperty(&quot;callSettersOnNulls&quot;), false));	configuration.setUseActualParamName(booleanValueOf(props.getProperty(&quot;useActualParamName&quot;), true));	configuration			.setReturnInstanceForEmptyRow(booleanValueOf(props.getProperty(&quot;returnInstanceForEmptyRow&quot;), false));	configuration.setLogPrefix(props.getProperty(&quot;logPrefix&quot;));	configuration.setConfigurationFactory(resolveClass(props.getProperty(&quot;configurationFactory&quot;)));	configuration.setShrinkWhitespacesInSql(booleanValueOf(props.getProperty(&quot;shrinkWhitespacesInSql&quot;), false));	configuration.setDefaultSqlProviderType(resolveClass(props.getProperty(&quot;defaultSqlProviderType&quot;)));&#125;

9. environmentsElement扫描配置的环境。
private void environmentsElement(XNode context) throws Exception &#123;	if (context != null) &#123;		// 获取到配置的默认环境		if (environment == null) &#123;			environment = context.getStringAttribute(&quot;default&quot;);		&#125;		for (XNode child : context.getChildren()) &#123;			String id = child.getStringAttribute(&quot;id&quot;);			// 判断是否是默认的环境			if (isSpecifiedEnvironment(id)) &#123;				TransactionFactory txFactory = transactionManagerElement(child.evalNode(&quot;transactionManager&quot;));				DataSourceFactory dsFactory = dataSourceElement(child.evalNode(&quot;dataSource&quot;));				DataSource dataSource = dsFactory.getDataSource();				Environment.Builder environmentBuilder = new Environment.Builder(id).transactionFactory(txFactory)						.dataSource(dataSource);				configuration.setEnvironment(environmentBuilder.build());				break;			&#125;		&#125;	&#125;&#125;

11. typeHandlerElement12. mapperElement因为配置 mapper 总的来说有两种方式，可以配置 package 扫描，也可以配置特定的资源或类，所以，解析 mapper 的逻辑也分为两个分支。通过访问每个子元素，根据是否是 package 进行不同的逻辑处理。
private void mapperElement(XNode parent) throws Exception &#123;	if (parent != null) &#123;		return;	&#125;	for (XNode child : parent.getChildren()) &#123;		if (&quot;package&quot;.equals(child.getName())) &#123;			String mapperPackage = child.getStringAttribute(&quot;name&quot;);			// 这里方法名叫 addMappers，注意末尾的 s			configuration.addMappers(mapperPackage);		&#125; else &#123;			String resource = child.getStringAttribute(&quot;resource&quot;);			String url = child.getStringAttribute(&quot;url&quot;);			String mapperClass = child.getStringAttribute(&quot;class&quot;);			if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) &#123;				ErrorContext.instance().resource(resource);				try (InputStream inputStream = Resources.getResourceAsStream(resource)) &#123;					XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource,							configuration.getSqlFragments());					mapperParser.parse();				&#125;			&#125; else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) &#123;				ErrorContext.instance().resource(url);				try (InputStream inputStream = Resources.getUrlAsStream(url)) &#123;					XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url,							configuration.getSqlFragments());					mapperParser.parse();				&#125;			&#125; else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) &#123;				Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);				configuration.addMapper(mapperInterface);			&#125; else &#123;				throw new BuilderException(						&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;);			&#125;		&#125;	&#125;&#125;

12.1. package如果是使用 package 解析，那么将会执行如下逻辑：
String mapperPackage = child.getStringAttribute(&quot;name&quot;);configuration.addMappers(mapperPackage);
获取 name 属性值，传递参数，将实现细节交给 configuration.addMappers
// Configuration.javapublic void addMappers(String packageName) &#123;	mapperRegistry.addMappers(packageName);&#125;
mapperRegistry 是一个 MapperRegistry 对象，configuration 将处理职责交给它：
// MapperRegistry.javapublic void addMappers(String packageName) &#123;	addMappers(packageName, Object.class);&#125;public void addMappers(String packageName, Class&lt;?&gt; superType) &#123;	ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;&gt;();	resolverUtil.find(new ResolverUtil.IsA(superType), packageName);	// 获得解析到的 Class 集合	Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; mapperSet = resolverUtil.getClasses();	for (Class&lt;?&gt; mapperClass : mapperSet) &#123;		// 调用 addMapper 添加		addMapper(mapperClass);	&#125;&#125;

package 和 class 解析，最终都会使用 Configuration 下的一个组件 MapperRegistry，然后调用其 addMapper 方法，只不过 package 会进行一次扫描，将扫描到的所有 Class 传递作为参数调用 addMapper
以下是 addMapper 方法：
public &lt;T&gt; void addMapper(Class&lt;T&gt; type) &#123;  if (type.isInterface()) &#123;    if (hasMapper(type)) &#123;      throw new BindingException(&quot;Type &quot; + type + &quot; is already known to the MapperRegistry.&quot;);    &#125;    boolean loadCompleted = false;    try &#123;      knownMappers.put(type, new MapperProxyFactory&lt;&gt;(type));      // It&#x27;s important that the type is added before the parser is run      // otherwise the binding may automatically be attempted by the      // mapper parser. If the type is already known, it won&#x27;t try.      MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);      parser.parse();      loadCompleted = true;    &#125; finally &#123;      if (!loadCompleted) &#123;        knownMappers.remove(type);      &#125;    &#125;  &#125;&#125;

从源码中可以看到，真正进行解析的是另一个组件 MapperAnnotationBuilder，这是它的构造器，注意到，它创建了一个 MapperBuilderAssistant，该组件是用于解析 Statement 时进行语句缓存的，下面会提及。
public MapperAnnotationBuilder(Configuration configuration, Class&lt;?&gt; type) &#123;	String resource = type.getName().replace(&#x27;.&#x27;, &#x27;/&#x27;) + &quot;.java (best guess)&quot;;	this.assistant = new MapperBuilderAssistant(configuration, resource);	this.configuration = configuration;	this.type = type;&#125;

// MapperAnnotationBuilder.javapublic void parse() &#123;	String resource = type.toString();	// 判断资源是否是首次加载	if (!configuration.isResourceLoaded(resource)) &#123;		// 加载同名的 xml resource		loadXmlResource();		// 缓存到已经加载的资源中		configuration.addLoadedResource(resource);		assistant.setCurrentNamespace(type.getName());		// 解析缓存 @CacheNamespace		parseCache();		// 解析缓存引用 @CacheNamespaceRef		parseCacheRef();		for (Method method : type.getMethods()) &#123;			if (!canHaveStatement(method)) &#123;				continue;			&#125;			if (getAnnotationWrapper(method, false, Select.class, SelectProvider.class).isPresent()			    &amp;&amp; method.getAnnotation(ResultMap.class) == null) &#123;				parseResultMap(method);			&#125;			try &#123;				// 见下面				parseStatement(method);			&#125; catch (IncompleteElementException e) &#123;				configuration.addIncompleteMethod(new MethodResolver(this, method));			&#125;		&#125;	&#125;	parsePendingMethods();&#125;

以下是 MapperAnnotationBuilder 解析语句的方法：
void parseStatement(Method method) &#123;    final Class&lt;?&gt; parameterTypeClass = getParameterType(method);    final LanguageDriver languageDriver = getLanguageDriver(method);    getAnnotationWrapper(method, true, statementAnnotationTypes).ifPresent(statementAnnotation -&gt; &#123;        final SqlSource sqlSource = buildSqlSource(statementAnnotation.getAnnotation(), parameterTypeClass, languageDriver, method);        final SqlCommandType sqlCommandType = statementAnnotation.getSqlCommandType();        final Options options = getAnnotationWrapper(method, false, Options.class).map(x -&gt; (Options) x.getAnnotation()).orElse(null);        final String mappedStatementId = type.getName() + &quot;.&quot; + method.getName();        final KeyGenerator keyGenerator;        String keyProperty = null;        String keyColumn = null;        if (SqlCommandType.INSERT.equals(sqlCommandType) || SqlCommandType.UPDATE.equals(sqlCommandType)) &#123;            // first check for SelectKey annotation - that overrides everything else            SelectKey selectKey = getAnnotationWrapper(method, false, SelectKey.class).map(x -&gt; (SelectKey) x.getAnnotation()).orElse(null);            if (selectKey != null) &#123;                keyGenerator = handleSelectKeyAnnotation(selectKey, mappedStatementId, getParameterType(method), languageDriver);                keyProperty = selectKey.keyProperty();            &#125; else if (options == null) &#123;                keyGenerator = configuration.isUseGeneratedKeys() ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;            &#125; else &#123;                keyGenerator = options.useGeneratedKeys() ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;                keyProperty = options.keyProperty();                keyColumn = options.keyColumn();            &#125;        &#125; else &#123;            keyGenerator = NoKeyGenerator.INSTANCE;        &#125;        Integer fetchSize = null;        Integer timeout = null;        StatementType statementType = StatementType.PREPARED;        ResultSetType resultSetType = configuration.getDefaultResultSetType();        boolean isSelect = sqlCommandType == SqlCommandType.SELECT;        boolean flushCache = !isSelect;        boolean useCache = isSelect;        if (options != null) &#123;            if (FlushCachePolicy.TRUE.equals(options.flushCache())) &#123;                flushCache = true;            &#125; else if (FlushCachePolicy.FALSE.equals(options.flushCache())) &#123;                flushCache = false;            &#125;            useCache = options.useCache();            fetchSize = options.fetchSize() &gt; -1 || options.fetchSize() == Integer.MIN_VALUE ? options.fetchSize() : null; //issue #348            timeout = options.timeout() &gt; -1 ? options.timeout() : null;            statementType = options.statementType();            if (options.resultSetType() != ResultSetType.DEFAULT) &#123;                resultSetType = options.resultSetType();            &#125;        &#125;        String resultMapId = null;        if (isSelect) &#123;            ResultMap resultMapAnnotation = method.getAnnotation(ResultMap.class);            if (resultMapAnnotation != null) &#123;                resultMapId = String.join(&quot;,&quot;, resultMapAnnotation.value());            &#125; else &#123;                resultMapId = generateResultMapName(method);            &#125;        &#125;        assistant.addMappedStatement(                mappedStatementId,                sqlSource,                statementType,                sqlCommandType,                fetchSize,                timeout,                // ParameterMapID                null,                parameterTypeClass,                resultMapId,                getReturnType(method),                resultSetType,                flushCache,                useCache,                // TODO gcode issue #577                false,                keyGenerator,                keyProperty,                keyColumn,                statementAnnotation.getDatabaseId(),                languageDriver,                // ResultSets                options != null ? nullOrEmpty(options.resultSets()) : null);    &#125;);&#125;

源码中最后调用 assistant 进行了 MappedStatement 的添加操作，当然，MappedStatement 最终一定是添加到 Configuration 中。
思考1. 关于 loadXmlResource() 加载同名 xml 资源分析
在 MapperAnnotationBuilder 的 parse() 过程中，会调用一个方法 loadXmlResource() 解析同名 xml 资源
private void loadXmlResource() &#123;    // Spring may not know the real resource name so we check a flag    // to prevent loading again a resource twice    // this flag is set at XMLMapperBuilder#bindMapperForNamespace    if (!configuration.isResourceLoaded(&quot;namespace:&quot; + type.getName())) &#123;        String xmlResource = type.getName().replace(&#x27;.&#x27;, &#x27;/&#x27;) + &quot;.xml&quot;;        // #1347        InputStream inputStream = type.getResourceAsStream(&quot;/&quot; + xmlResource);        if (inputStream == null) &#123;            // Search XML mapper that is not in the module but in the classpath.            try &#123;                inputStream = Resources.getResourceAsStream(type.getClassLoader(), xmlResource);            &#125; catch (IOException e2) &#123;                // ignore, resource is not required            &#125;        &#125;        if (inputStream != null) &#123;            XMLMapperBuilder xmlParser = new XMLMapperBuilder(inputStream, assistant.getConfiguration(), xmlResource, configuration.getSqlFragments(), type.getName());            xmlParser.parse();        &#125;    &#125;&#125;
有关于获取 InputStream 那一句个人觉得有些多此一举，可以看到，MyBatis 通过 Class 的 getResourceAsStream() 方法获取流，该方法如下。
public InputStream getResourceAsStream(String name) &#123;   name = resolveName(name);   ClassLoader cl = getClassLoader0();   if (cl==null) &#123;       // A system class.       return ClassLoader.getSystemResourceAsStream(name);   &#125;   return cl.getResourceAsStream(name);&#125;
首先进行名称解析，解析方法如下：
private String resolveName(String name) &#123;    if (name == null) &#123;        return name;    &#125;    if (!name.startsWith(&quot;/&quot;)) &#123;        Class&lt;?&gt; c = this;        while (c.isArray()) &#123;            c = c.getComponentType();        &#125;        String baseName = c.getName();        int index = baseName.lastIndexOf(&#x27;.&#x27;);        if (index != -1) &#123;            name = baseName.substring(0, index).replace(&#x27;.&#x27;, &#x27;/&#x27;)                +&quot;/&quot;+name;        &#125;    &#125; else &#123;        name = name.substring(1);    &#125;    return name;&#125;
如果名称以 / 开始，则会进行一个 substring 操作，所以说多此一举。
另外，自动加载的 xml 资源必须与接口在同一路径中。
2. 问题 为什么这里需要构建一个 MapperBuilderAssistant 解析，而不是直接在 MapperAnnotationBuilder 的方法逻辑中执行添加操作?.
我们先观察一下 MapperBuilderAssistant 方法逻辑：
public MappedStatement addMappedStatement(        String id,        SqlSource sqlSource,        StatementType statementType,        SqlCommandType sqlCommandType,        Integer fetchSize,        Integer timeout,        String parameterMap,        Class&lt;?&gt; parameterType,        String resultMap,        Class&lt;?&gt; resultType,        ResultSetType resultSetType,        boolean flushCache,        boolean useCache,        boolean resultOrdered,        KeyGenerator keyGenerator,        String keyProperty,        String keyColumn,        String databaseId,        LanguageDriver lang,        String resultSets) &#123;    if (unresolvedCacheRef) &#123;        throw new IncompleteElementException(&quot;Cache-ref not yet resolved&quot;);    &#125;    id = applyCurrentNamespace(id, false);    boolean isSelect = sqlCommandType == SqlCommandType.SELECT;    MappedStatement.Builder statementBuilder = new MappedStatement.Builder(configuration, id, sqlSource, sqlCommandType)            .resource(resource)            .fetchSize(fetchSize)            .timeout(timeout)            .statementType(statementType)            .keyGenerator(keyGenerator)            .keyProperty(keyProperty)            .keyColumn(keyColumn)            .databaseId(databaseId)            .lang(lang)            .resultOrdered(resultOrdered)            .resultSets(resultSets)            .resultMaps(getStatementResultMaps(resultMap, resultType, id))            .resultSetType(resultSetType)            .flushCacheRequired(valueOrDefault(flushCache, !isSelect))            .useCache(valueOrDefault(useCache, isSelect))            .cache(currentCache); // currentCache 是 MapperBuilderAssistant 的属性    ParameterMap statementParameterMap = getStatementParameterMap(parameterMap, parameterType, id);    if (statementParameterMap != null) &#123;        statementBuilder.parameterMap(statementParameterMap);    &#125;    MappedStatement statement = statementBuilder.build();    configuration.addMappedStatement(statement);    return statement;&#125;

注意到，MappedStatement.Builder 在构建 MappedStatement 的时候需要传入一个参数 currentCache，而如果你有印象，该参数是之前方法 parseCache() 得到的对象，暂时缓存到了 MapperBuilderAssistant 中。假设没有 MapperBuilderAssistant，那么该对象就需要存放到 MapperAnnotationBuilder 的属性中，略显混乱。
12.2. mapper在解析 mapper 元素的时候，会根据 resource, url, class 不同的取值进行不同的处理逻辑
12.2.1. resourceresource 和 url 类似，两者都是通过提供 XML 文件资源构造 MapperStatement，均通过 MyBatis 提供的工具类 Resources 获得 InputStream，进行解析。
try(InputStream inputStream = Resources.getResourceAsStream(resource)) &#123;	XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());	mapperParser.parse();&#125;

XMLMapperBuilder 是用于解析 Mapper XML 资源的，在传入必要的参数之后，调用 parse() 方法解析。
public void parse() &#123;	if (!configuration.isResourceLoaded(resource)) &#123;		// 这里是解析		configurationElement(parser.evalNode(&quot;/mapper&quot;));		configuration.addLoadedResource(resource);		bindMapperForNamespace();	&#125;	parsePendingResultMaps();	parsePendingCacheRefs();	parsePendingStatements();&#125;
解析节点的具体逻辑在 configurationElement，其中传入表示 &lt;mapper&gt; 的 XNode 对象。
configurationElementprivate void configurationElement(XNode context) &#123;	try &#123;		String namespace = context.getStringAttribute(&quot;namespace&quot;);		if (namespace == null || namespace.isEmpty()) &#123;			throw new BuilderException(&quot;Mapper&#x27;s namespace cannot be empty&quot;);		&#125;		builderAssistant.setCurrentNamespace(namespace);		// 解析缓存引用		cacheRefElement(context.evalNode(&quot;cache-ref&quot;));		// 解析缓存		cacheElement(context.evalNode(&quot;cache&quot;));		parameterMapElement(context.evalNodes(&quot;/mapper/parameterMap&quot;));		resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;));		sqlElement(context.evalNodes(&quot;/mapper/sql&quot;));		// 解析语句		buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));	&#125; catch (Exception e) &#123;		throw new BuilderException(&quot;Error parsing Mapper XML. The XML location is &#x27;&quot; + resource + &quot;&#x27;. Cause: &quot; + e,				e);	&#125;&#125;

解析 Statement 的逻辑如下：
private void buildStatementFromContext(List&lt;XNode&gt; list) &#123;	if (configuration.getDatabaseId() != null) &#123;		buildStatementFromContext(list, configuration.getDatabaseId());	&#125;	buildStatementFromContext(list, null);&#125;private void buildStatementFromContext(List&lt;XNode&gt; list, String requiredDatabaseId) &#123;	for (XNode context : list) &#123;		final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant,				context, requiredDatabaseId);		try &#123;			statementParser.parseStatementNode();		&#125; catch (IncompleteElementException e) &#123;			configuration.addIncompleteStatement(statementParser);		&#125;	&#125;&#125;

注意到，为了进行语句解析，构造了一个 XMLStatementBuilder 专门用于解析语句节点，并调用其方法 parseStatementNode 进行解析。
public void parseStatementNode() &#123;	String id = context.getStringAttribute(&quot;id&quot;);	String databaseId = context.getStringAttribute(&quot;databaseId&quot;);	if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) &#123;		return;	&#125;	String nodeName = context.getNode().getNodeName();	SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));	boolean isSelect = sqlCommandType == SqlCommandType.SELECT;	boolean flushCache = context.getBooleanAttribute(&quot;flushCache&quot;, !isSelect);	boolean useCache = context.getBooleanAttribute(&quot;useCache&quot;, isSelect);	boolean resultOrdered = context.getBooleanAttribute(&quot;resultOrdered&quot;, false);	// Include Fragments before parsing	XMLIncludeTransformer includeParser = new XMLIncludeTransformer(configuration, builderAssistant);	includeParser.applyIncludes(context.getNode());	String parameterType = context.getStringAttribute(&quot;parameterType&quot;);	Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);	String lang = context.getStringAttribute(&quot;lang&quot;);	LanguageDriver langDriver = getLanguageDriver(lang);	// Parse selectKey after includes and remove them.	processSelectKeyNodes(id, parameterTypeClass, langDriver);	// Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed)	KeyGenerator keyGenerator;	String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;	keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, true);	if (configuration.hasKeyGenerator(keyStatementId)) &#123;		keyGenerator = configuration.getKeyGenerator(keyStatementId);	&#125; else &#123;		keyGenerator = context.getBooleanAttribute(&quot;useGeneratedKeys&quot;,				configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))						? Jdbc3KeyGenerator.INSTANCE						: NoKeyGenerator.INSTANCE;	&#125;	// 构造 SqlSource	SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);	StatementType statementType = StatementType			.valueOf(context.getStringAttribute(&quot;statementType&quot;, StatementType.PREPARED.toString()));	Integer fetchSize = context.getIntAttribute(&quot;fetchSize&quot;);	Integer timeout = context.getIntAttribute(&quot;timeout&quot;);	String parameterMap = context.getStringAttribute(&quot;parameterMap&quot;);	String resultType = context.getStringAttribute(&quot;resultType&quot;);	Class&lt;?&gt; resultTypeClass = resolveClass(resultType);	String resultMap = context.getStringAttribute(&quot;resultMap&quot;);	String resultSetType = context.getStringAttribute(&quot;resultSetType&quot;);	ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);	if (resultSetTypeEnum == null) &#123;		resultSetTypeEnum = configuration.getDefaultResultSetType();	&#125;	String keyProperty = context.getStringAttribute(&quot;keyProperty&quot;);	String keyColumn = context.getStringAttribute(&quot;keyColumn&quot;);	String resultSets = context.getStringAttribute(&quot;resultSets&quot;);	builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType, fetchSize, timeout,			parameterMap, parameterTypeClass, resultMap, resultTypeClass, resultSetTypeEnum, flushCache, useCache,			resultOrdered, keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);&#125;

解析过程中，涉及到构造 SqlSource，这是一个比较重要的参数。
bindMapperForNamespace解析 mapper 的过程中会调用 bindMapperForNamespace() 进行绑定：
private void bindMapperForNamespace() &#123;	String namespace = builderAssistant.getCurrentNamespace();	if (namespace != null) &#123;		Class&lt;?&gt; boundType = null;		try &#123;			// 基于 namespace 尝试加载该类			boundType = Resources.classForName(namespace);		&#125; catch (ClassNotFoundException e) &#123;			// ignore, bound type is not required		&#125;		if (boundType != null &amp;&amp; !configuration.hasMapper(boundType)) &#123;			// Spring may not know the real resource name so we set a flag			// to prevent loading again this resource from the mapper interface			// look at MapperAnnotationBuilder#loadXmlResource			configuration.addLoadedResource(&quot;namespace:&quot; + namespace);			configuration.addMapper(boundType);		&#125;	&#125;&#125;

这里需要注意的是，通过 namespace 尝试加载 Mapper 接口，如果该接口未被添加过，则调用 addMapper 进行解析，上面已经描述过过程了。
12.2.2. url类似 resource 的方式，最终都会得到一个 InputStream，进行解析
ErrorContext.instance().resource(url);try(InputStream inputStream = Resources.getUrlAsStream(url))&#123;	XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());	mapperParser.parse();&#125;

public void parse() &#123;	if (!configuration.isResourceLoaded(resource)) &#123;	  configurationElement(parser.evalNode(&quot;/mapper&quot;));	  configuration.addLoadedResource(resource);	  bindMapperForNamespace();	&#125;	parsePendingResultMaps();	parsePendingCacheRefs();	parsePendingStatements();&#125;



加载之后的资源一级 Mapper 类都会缓存到 configuration，防止重复加载
12.2.3. class解析过程参考 package
]]></content>
  </entry>
  <entry>
    <title>MyBatis 构造 Mapper Proxy 原理</title>
    <url>/2022/07/16/Framework/Java/MyBatis/MyBatis-%E6%9E%84%E9%80%A0-Mapper-Proxy-%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[在 MyBatis 应用中，我们定义的 Mapper 接口，最终都会转换为 JDK 动态代理对象 Proxy。
假设有 UserMapper.xml：
SqlSession sqlSession = sqlSessionFactory.openSession();UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
在 MyBatis 的框架中，提供了 SqlSession 的默认实现类 DefaultSqlSession，关注其实现方法 getMapper()：
// DefaultSqlSession.javapublic &lt;T&gt; T getMapper(Class&lt;T&gt; type) &#123;    return configuration.getMapper(type, this);&#125;

方法 getMapper 内部调用了属性 Configuration 的 getMapper 方法，将代码细节委托给 Configuration 实现。
// Configuration.javapublic &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;    return mapperRegistry.getMapper(type, sqlSession);&#125;

Configuration 内部的实现是将 getMapper 的细节委托给 MapperRegistry 实现，顾名思义，Mapper 注册表。
// MapperRegistry.javapublic &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;    // 确保该类型被识别    final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);    if (mapperProxyFactory == null) &#123;        throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);    &#125;    try &#123;        return mapperProxyFactory.newInstance(sqlSession);    &#125; catch (Exception e) &#123;        throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);    &#125;&#125;
由 MapperRegistry 的实现可以知道，其内部维护了一个 knownMappers 结构，用于进行 Mapper 接口到 MapperProxyFactory 的映射：
private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap&lt;&gt;();

MapperProxyFactory，由类名可以知道这是一个批量生产 MapperProxy 的工厂类，关注其如何生产 MapperProxy
// MapperProxyFactory.javapublic T newInstance(SqlSession sqlSession) &#123;    // 创建一个 InvocationHandler    final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);    return newInstance(mapperProxy);&#125;protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123;    // 调用 JDK 动态代理的方法创建代理类    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy);&#125;
首先，创建了一个 MapperProxy，这是一个由 MyBatis 提供的 InvocationHandler 的实现类，然后将其传递给 Proxy.newProxyInstance 方法创建 Proxy 并返回。

从名字上看，MapperProxyFactory 似乎是生产 MapperProxy 的工厂，但在过程中，MapperProxy 只是扮演了代理类的 Handler 角色，MapperProxyFactory 真正生产的应该是代理类。

]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Logback 框架</title>
    <url>/2022/10/27/Framework/Java/Log/Logback-%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[Configuring loggers, or the &lt;logger&gt; elementConfiguring the root logger, or the &lt;root&gt; element&lt;root&gt; 元素用于配置根 logger。它支持一个属性，即 level 属性。它不允许任何其他属性，因为可相加性标志不应用于根记录器。此外，由于根记录器已经被命名为“root”，它也不允许名称属性。level属性的值可以是不区分大小写的字符串TRACE、DEBUG、INFO、WARN、ERROR、ALL或OFF之一。注意，根记录器的级别不能设置为INHERITED或NULL。
]]></content>
  </entry>
  <entry>
    <title>MyBatis 官方文档翻译笔记</title>
    <url>/2022/07/15/Framework/Java/MyBatis/MyBatis-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[MyBatis
1. Getting started1.1. Installation进行最基本的 MyBatis 应用开发需要导入的依赖，最新版本可以参考github
&lt;dependency&gt;  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;  &lt;version&gt;3.5.8&lt;/version&gt;&lt;/dependency&gt;


1.2. Building SqlSessionFactory from XML从 XML 构建 SqlSessionFactory。所有 mybatis 应用程序围绕 SqlSessionFactory 实例。可以通过 SqlSessionFactoryBuilder 获取到 SqlSessionFactory 实例。SqlSessionFactoryBuilder 可以从以下几个来源进行构建：

Mybatis configuration xml
Configuration object

从 XML 文件构建 SqlSessionFactory 实例，建议使用类路径资源，但实际上也可以使用 InputStream。
mybatis-config.xml 可以参考官网
1.3. Building SqlSessionFactory without XML可以参考官网的案例。但是，并不支持这种做法，因为高级映射仍然需要 XML 的支持。
1.4. Acquiring a SqlSession from SqlSessionFactory通过以下代码可以创建一个 Session（注意关闭）：
SqlSession session = sqlSessionFactory.openSession();


1.5. Exploring Mapped SQL Statements语句可以由 XML 或者 Annotation 定义。
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt;  &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt;    select * from Blog where id = #&#123;id&#125;  &lt;/select&gt;&lt;/mapper&gt;
上述例子，在命名空间 org.mybatis.example.BlogMapper 中，定义了名为 selectBlog 的映射语句，允许你通过完全限定名称 org.mybatis.example.BlogMapper.selectBlog 来调用：
Blog blog = session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);

这与在完全限定的 Java 类上调用一个方法是非常类似的，这也是如此设计的原因。使用与映射的 select 语句在名称，参数，返回类型相匹配的方法，可以直接映射到与命名空间名称相同的 Mapper 类。这允许你简单地将方法调用在映射器接口上：
BlogMapper mapper = session.getMapper(BlogMapper.class);Blog blog = mapper.selectBlog(101);
第二种方法有很多优势。首先，它不依赖字符串，更安全。其次，如果你的 IDE 由代码补全，可以利用它跳转到你映射的 SQL 语句。
Namespaces以前版本的 MyBatis 命名空间是可选的，现在强制需要命名空间，具有隔离语句的目的。
命名空间让接口进行绑定，并且，即使你现在并不认为你会使用，你也应该遵循这种实践，防止你改变想法。一旦使用命名空间，把它放到正确的 Java 包命名空间下能清理你的代码，并且长期内提高 MyBatis 的可用性
对于简单的语句，可以使用注解方式定义：
public interface BlogMapper &#123;  @Select(&quot;SELECT * FROM blog WHERE id = #&#123;id&#125;&quot;)  Blog selectBlog(int id);&#125;

不过，对于复杂的语句，建议使用 XML 方式定义，否则显得混乱。

2. Configuration XML2.1. properties&lt;properties&gt; 除了支持嵌入内置属性，还支持引入外部 Java 属性文件，只需通过 resource 或者 url 属性设置即可。resource 是以类路径为基础路径的相对路径，url 为标准的路径位置，如 file:&#x2F;&#x2F;&#x2F;。
&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;  &lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&gt;  &lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&gt;&lt;/properties&gt;
注意点 

resource 和 url 不可以同时设置，否则抛出异常。
如果配置了相同的属性，则后面的会覆盖前面的；如果是分散在属性文件和子元素属性中，那么由于属性文件后加载，因此属性文件会覆盖子元素属性。
&lt;properties&gt; 标签必需位于 configuration 子元素第一个

属性配置完，可以在配置文件中使用属性，以替代需要动态配置的值。例如：
&lt;dataSource type=&quot;POOLED&quot;&gt;  &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;  &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;  &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;  &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;&lt;/dataSource&gt;

属性的来源也可以是由程序传递给 SqlSessionFactoryBuilder.build() 方法：
SqlSessionFactory factory = sqlSessionFactoryBuilder.build(reader, props);// ... or ...SqlSessionFactory factory = new SqlSessionFactoryBuilder.build(reader, environment, props);



2.2. settings


参数
描述
有效值
默认值



cacheEnabled
全局启用或禁用此配置下任何映射器中的任何缓存




lazyLoadingEnabled
全局懒加载。该值可以被 fetchType 取代。




aggressiveLazyLoading
启用后，任何方法调用都会加载对象的延迟属性。否则，每个属性按需加载。具体见 lazyLoadTriggerMethods

false (true in ≤3.4.1)


useColumnLabel
使用列标签而不是列名。不同的驱动表现不同。




mapUnderscoreToCamelCase
下划线到驼峰转换




autoMappingBehavior
是否自动映射，Spring MyBatis 默认为 PARTIAL，注意。




defaultExecutorType
配置默认的执行器。SIMPLE REUSE BATCH




localCacheScope
本地缓存的作用域
SESSION | STATEMENT
SESSION


logImpl
指定 MyBatis 应该使用的日志实现。如果未设置，则自动发现。
SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING
Not set


2.3. typeAliases别名是 Java 类型的短名称，可以简单地减少完全限定类名的冗余输入。支持 &lt;typeAlias&gt; 和 &lt;package&gt; 配置
&lt;typeAliases&gt;  &lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&gt;&lt;/typeAliases&gt;
指定 MyBatis 搜索 bean 的包，例如：
&lt;typeAliases&gt;  &lt;package name=&quot;domain.blog&quot;/&gt;&lt;/typeAliases&gt;
在包中的所有 bean，都会使用 bean 的小写非限定类名作为别名。其中，domain.blog.Author 将被注册为 author。特殊地，如果发现 @Alias 注解，则其值将用作别名：
@Alias(&quot;author&quot;)public class Author &#123;    ...&#125;

有许多内置的 Java 类型的别名。它们都是大小写不敏感的。具体参见类 TypeAliasRegistry
2.4. typeHandlerstypeHandler 用于两个地方：

当 MyBatis 在 PreparedStatement 设置参数时。参见 DefaultParameterHandler
从 ResultSet 检索值。参见 DefaultResultSetHandler


自从  3.4.5, MyBatis 默认支持 JSR-310 (Date and Time API)

在 MyBatis 中，存在一个 TypeHandlerRegistry 组件，其维护了一个 Map 结构：
private final Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; typeHandlerMap = new ConcurrentHashMap&lt;&gt;();
该 Map 的 key 是 java.lang.reflect.Type 类型对象，value 又是一个 Map（称为 sub map），通常用于传入一个 Class 对象，得到 Jdbc 类型支持的类型处理器，sub map 通常还会存储一个 key 为 null 的键值对，用于匹配默认的处理器。

typeHandlers 几乎很少自己定义扩展，但少部分情况还是比较有效的，例如：不涉及查询的一对多关系、setString 的乱码问题。

2.5. Handling Enums2.6. objectFactory每次 MyBatis 创建结果对象新实例时，它都会使用 ObjectFactory 实例来完成此操作。默认的 ObjectFactory 只是使用默认构造函数实例化目标类，如果存在参数映射，则使用参数化构造函数。如果你想覆盖 ObjectFactory 的默认行为，你可以创建自己的 ObjectFactory。例如:
// ExampleObjectFactory.javapublic class ExampleObjectFactory extends DefaultObjectFactory &#123;  @Override  public &lt;T&gt; T create(Class&lt;T&gt; type) &#123;    return super.create(type);  &#125;  @Override  public &lt;T&gt; T create(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs) &#123;    return super.create(type, constructorArgTypes, constructorArgs);  &#125;  @Override  public void setProperties(Properties properties) &#123;    super.setProperties(properties);  &#125;  @Override  public &lt;T&gt; boolean isCollection(Class&lt;T&gt; type) &#123;    return Collection.class.isAssignableFrom(type);  &#125;&#125;



  



2.7. pluginsMyBatis 允许你在映射语句的执行中拦截对某些点的调用。默认地，MyBatis 允许插件拦截方法调用有:

Executor(update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)
ParameterHandler (getParameterObject, setParameters)
ResultSetHandler (handleResultSets, handleOutputParameters)
StatementHandler (prepare, parameterize, batch, update, query)

通过查看每个类方法地完整方法签名和每个 MyBatis 发行版提供的源代码，可以找到这些类方法的详细信息。你应该理解正在重写的方法的行为，假设你正在做的不仅仅是监视调用。如果你试图修改或覆盖给定方法的行为，则很可能破坏 MyBatis 的核心。这些都是底层的类和方法，所以使用插件时要谨慎。
考虑到插件提供的功能，使用插件非常简单。只需实现拦截器接口，确保指定要拦截的签名。
// ExamplePlugin.java@Intercepts(&#123;@Signature(  type= Executor.class,  method = &quot;update&quot;,  args = &#123;MappedStatement.class,Object.class&#125;)&#125;)public class ExamplePlugin implements Interceptor &#123;  private Properties properties = new Properties();  @Override  public Object intercept(Invocation invocation) throws Throwable &#123;    // implement pre-processing if needed    Object returnObject = invocation.proceed();    // implement post-processing if needed    return returnObject;  &#125;  @Override  public void setProperties(Properties properties) &#123;    this.properties = properties;  &#125;&#125;

&lt;!-- mybatis-config.xml --&gt;&lt;plugins&gt;  &lt;plugin interceptor=&quot;org.mybatis.example.ExamplePlugin&quot;&gt;    &lt;property name=&quot;someProperty&quot; value=&quot;100&quot;/&gt;  &lt;/plugin&gt;&lt;/plugins&gt;

2.8. environmentsMyBatis 可以配置多个环境。这有助于你以任何原因将 SQL 映射到不同的数据库。例如，你可能对于开发，测试和生产环境由不同的配置。或者，你可能有多个表结构相同的生产数据库，并且你希望为两者使用相同的 SQL 映射。
注意 尽管你可以配置多个环境，但是你只可以为每个 SqlSessionFactory 选择一个。因此，如果要连接到多个数据库，则需要为每个数据库创建一个 SqlSessionFactory。

每个数据库一个 SqlSessionFactory 实例

传递给 build() 方法参数 environment 可以指定环境，否则使用 default 环境。
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties);


transactionManager
MyBatis 包含了两种事务管理器，JDBC | MANAGED

JDBC —— 此配置只是直接使用 JDBC 提交和回滚工具。它依赖于从数据源获取的连接来管理事务的范围。默认情况下，它在关闭连接时启用自动提交功能，以便与某些驱动程序兼容。然而，对于一些驱动程序来说，启用自动提交不仅没有必要，而且是一个昂贵的操作。因此，从 3.5.10 版本开始，你可以通过将 “skipSetAutoCommitOnClose” 属性设置为 true 来跳过这一步。例如:

&lt;transactionManager type=&quot;JDBC&quot;&gt;  &lt;property name=&quot;skipSetAutoCommitOnClose&quot; value=&quot;true&quot;/&gt;&lt;/transactionManager&gt;


MANAGED —— 这种配置几乎什么也不做。它不提交或回滚连接。相反，它让容器管理事务的整个生命周期（例如 JEE 应用服务器上下文）。默认情况下，它会关闭连接。但是，有些容器并不期望这样，因此，如果你需要组织它关闭连接，请将 “closeConnection” 属性设置为 false。例如:

&lt;transactionManager type=&quot;MANAGED&quot;&gt;  &lt;property name=&quot;closeConnection&quot; value=&quot;false&quot;/&gt;&lt;/transactionManager&gt;


注意 如果你打算将 MyBatis 与 Spring 一起使用，则不需要配置任何 TransactionManager，因为 Spring 模块将设置自己的 TransactionManager，覆盖之前设置的任何配置。

dataSource
dataSource 元素使用标准 JDBC DataSource 接口配置 JDBC Connection 对象。
大多数 MyBatis 应用程序将根据示例中配置 dataSource。但是，它不是必需的。但是，要促进懒加载，数据源是需要的。
有三种内置的数据源类型，UNPOOLED | POOLED | JNDI
UNPOOLED 每次请求时，数据源都是简单地打开和关闭一个链接。虽然它有点慢，但是对于不需要立即可用连接地简单应用来说，是个不错地选择。不同的数据库也不同，因此对于一些池化不太重要的数据库，该配置会是比较理想的。UNPOOLED 数据源具有以下属性需要配置：

driver 
url
username
password
defaultTransactionIsolationLevel 连接的默认事务隔离级别
defaultNetworkTimeout 默认网络超时值，以等待数据库操作完成，单位毫秒

POOLED DataSource 池化 JDBC Connection 对象，以避免创建新连接实例所需要的初始化和认证时间。这是一种当前 web 应用中流行的方式，可以获得最快的响应。
除了上面的（UNPOOLED）属性之外，还有许多属性可用于配置 POOLED 数据源：

poolMaximumActiveConnections
poolMaximumIdleConnections
poolMaximumCheckoutTime
poolTimeToWait
poolMaximumLocalBadConnectionTolerance
poolPingQuery ping 查询被发送到数据库以验证连接处于良好的工作状态，并且已准备好接受请求。默认值：”NO PING QUERY SET”，这回引起大多数数据库驱动以错误信息产生失败。
poolPingEnabled 开启或禁用 ping 查询。如果开启，你必须用一个有效的 SQL 语句（最好很快）设置 poolPingQuery 属性。默认：false
poolPingConnectionsNotUsedFor

JNDI 此 DataSource 的实现旨在与容器（如 EJB 或者应用服务器）一起使用，该数据源可以配置内部或外部数据源，并且在 JNDI 上下文中对其进行引用。该数据源配置只需要两个属性：

initial_context
data_source

2.9. databaseIdProvider2.10. mappers定义映射的 SQL 语句，首先，我们需要告诉 MyBatis 在哪里找到他们，你可以使用：

类路径相对资源引用
完全限定 url 引用，包括 file:///
类名
包名

方式1 类路径相对资源引用&lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt;

方式2 完全限定 url 引用&lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;

方式3 类名注册的配置结构如下：
&lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;

注册源码分析
依靠组件 MapperRegistry 进行注册。不需要尝试配置两个一样的类，否则你会得到异常。
依靠 MapperAnnotationBuilder 解析注解。注解解析部分，通过反射 Class.getMethod() 获取到接口所有的方法。
MapperAnnotationBuilder 会委派内部的 MapperBuilderAssistant 进行语句添加，还会缓存到 MapperBuilderAssistant  中
方式4 包名注册该包下所有接口为 mapper
&lt;package name=&quot;org.mybatis.builder&quot;/&gt;
你在指定非 package 的配置时，只能配置 url，name，resource 之一的属性，否则你会得到异常。
3. Mapper XML Files3.1. select对于形如 #&#123;id&#125; 这样的标记，这告诉 MyBatis 需要创建一个 PreparedStatement 的参数。使用 JDBC，这样的参数会在 SQL 中识别为 “?”，传递给 PreparedStatement。



属性
描述



id
在该 namesapce 下的唯一标识符，可以用于引用该语句，即 Statement ID。


parameterType
将传递到此语句的参数的完全限定类名或别名。可选，因为 MyBatis 可以通过传递给语句的实际参数得到 TypeHandler


resultType
从此语句返回的预期类型的完全限定类名或别名。在集合的情况下，这应该是集合包含的类型，而不是集合类型。使用 resultType 或者 resultMap，不可以都用。


resultMap
外部 resultMap 的引用。使用 resultMap 或者 resultType，不可以都用。


flushCache
设置为 true 将导致当调用此语句时会刷新 Local 和 2 级缓存。对于 select 默认是 false


useCache
设置为 true 将导致该语句的结果缓存在 2 级缓存。对于 select 语句默认为: true


timeout
驱动等待数据库返回数据，在抛出异常之前的超时时间，默认 unset（驱动决定）


fetchSize



statementType
可选值：STATEMENT, PREPARED, CALLABLE。默认值：PREPARED


resultSetType



databaseId



resultOrdered



resultSets



3.2. insert, update and deleteMyBatis 加载 Mapper 的时候会将读取到的语句信息都存储到 Configuration 的属性 mappedStatements 中：
public Map&lt;String, MappedStatement&gt; mappedStatements;

其中，MappedStatement 又能够获取 BoundSql
一对多关联
collection

支持分步查询和关联查询
&lt;resultMap type=&quot;com.cannedbread.dictionary.pojo.domain.DictionaryTypeDO&quot; id=&quot;doctionaryType&quot;&gt;	&lt;id column=&quot;t_id&quot; property=&quot;id&quot; javaType=&quot;java.lang.String&quot;/&gt;	&lt;result column=&quot;t_type&quot; property=&quot;type&quot;/&gt;	&lt;result column=&quot;t_description&quot; property=&quot;description&quot;/&gt;	&lt;collection property=&quot;dictionaryTypeList&quot; ofType=&quot;com.cannedbread.dictionary.pojo.domain.DictionaryValueDO&quot;&gt;		&lt;id column=&quot;v_id&quot; property=&quot;id&quot; javaType=&quot;java.lang.String&quot;/&gt;		&lt;result column=&quot;v_label&quot; property=&quot;label&quot;/&gt;		&lt;result column=&quot;v_value&quot; property=&quot;value&quot;/&gt;	&lt;/collection&gt;&lt;/resultMap&gt;


3.3. Parameters参数，指传递给语句的参数。参数可以认为有 2 种：

简易（原始）数据类型。 Integer、String 等没有属性的值。

复合数据类型。可以理解为是由简易数据类型组合而成的类。


通常，我们使用 #&#123;id&#125; 这种方式引用参数。但是，参数可以更具体地引用：
#&#123;property,javaType=int,jdbcType:NUMBERIC&#125;
javaType 基本可以总是从参数对象中确定，除非该对象是 HashMap，那么需要显式指定 javaType 确保使用正确的 TypeHandler。

传入 List

引用名称必须为 list，获取长度：list.size，获取第 n 个元素：list[n]
&lt;if test=&quot;list != null and list.size != 0&quot;&gt;&lt;/if&gt;&lt;foreach collection=&quot;list&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot; item=&quot;item&quot;&gt;#&#123;item&#125;&lt;/foreach&gt;


传入多个值

多个参数会封装成 Map，key 为 param1, param2, …
引用方式：#&#123;param1&#125;、#&#123;param2.password&#125;

传入 Map

对 XML 中映射的语句进行解析之后，能够得到一个 List&lt;ParameterMapping&gt;，其中收集所有 #&#123;&#125; 占位符。
这些结构之后会传递给 StatementHandler，通常是 PreparedStatementHandler，之后通过 handler 进行参数设置。
3.4. Result Maps对于如下映射语句例子：
&lt;select id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt;  select id, username, hashedPassword  from some_table  where id = #&#123;id&#125;&lt;/select&gt;

根据 resultType 属性所指定的，这样的语句会简单地将所有地列自动映射到 HashMap 的 key 上。但是，在大多数场景下，HashMap并不是一个好的领域模型。应用程序更有可能使用 Java Bean 或者 POJO。考虑如下的 Java Bean：
public class User &#123;  private int id;  private String username;  private String hashedPassword;  // Getter Setter&#125;
基于 Java Bean 规范，上面的类有 3 个属性：id, username, hashedPassword。这些与 SELECT 语句中的列名完全匹配。这样，Java Bean 可以像 HashMap 一样，简单地映射到 ResultSet。
在这些情况下，MyBatis 自动在幕后创建 ResultMap 以将列名基于名称地自动映射到 Java Bean 的属性。
列名与属性名不匹配的情况如何处理 ?

标准 SQL 语法，SELECT 语句别名
使用自定义 &lt;Result Map&gt;

3.4.1. Advanced Result MapsResult Map 是 MyBatis 强大的工具，可以自由映射结果。
3.4.2. resultMap&lt;resultMap&gt; 元素的概览：

&lt;constructor&gt; 用于在实例化时将结果注入类的构造函数
idArg ID 参数，标识 ID 将有助于提升整体性能
arg 普通结果参数注入


&lt;id&gt; 一个 ID 结果，标识 ID 将会提高整体性能
&lt;result&gt; 普通结果参数
&lt;association&gt; 复合类型关联，许多结果会汇总到该类型
嵌套结果映射 - association 本身就是 resultMap，或者可以引用其他的 resultMap


&lt;collection&gt; 复合类型的集合
嵌套结果映射 - collection 本身就是 resultMap，或者可以引用其他的 resultMap


&lt;discriminator&gt; 使用结果的值来确定要使用的 resultMap




属性
描述



id
当前命名空间下引用此 result map 的唯一标识符


type
Java 的完全限定名，或者别名


autoMapping
如果存在该属性，MyBatis 会为该 result map 启用或禁用自动映射


3.4.3. id &amp; resultid 和 result 都可以映射一个列的值到一个简单数据类型的字段（String,int,double,Date,…）
associationassociation 元素处理 “has-one” 类型关系。例如，一个博客有一个作者。&lt;association&gt; 映射像其他 &lt;result&gt; 一样工作。你可以指定 property, javaType, jdbcType, typeHandler。
association 不同之处在于，你需要告诉 MyBatis 如何加载关联数据，支持 2 种方式：

Nested Select：嵌套查询，或者嵌套子查询。通过执行另一个映射 SQL 语句返回所需的复合类型。
Nested Results：嵌套结果。通过使用嵌套的结果映射来处理 join 结果的重复子集。




属性
描述



property
字段或属性。如果给定名称存在 Java Bean 匹配的属性，则会使用。否则，MyBatis 会寻找给定名称的字段。


javaType
完全限定的 Java 类名（或者 alias）。如果你映射到 Java Bean，MyBatis 会弄清楚类型。如果你映射到 HashMap，你需要指定 javaType 以确保所需的行为。


jdbcType



typeHandler



Nested Select for Association


属性
描述



column
将要传递给嵌套语句的列名或者别名。可以确定唯一一条记录。注意：为了处理复合键，可以使用语法 column=&quot;prop1=col1,prop2=col2&quot; 指定多个列名传递给嵌套的 select 语句


select
映射语句的 ID，将会加载需要的复杂类型


fetchType
可选。有效值是 lazy 和 eager。如果存在，它会覆盖全局配置参数 lazyLoadingEnabled



嵌套 SELECT 必须确保结果集的数量小于等于 1 个，否则你会得到异常：org.apache.ibatis.executor.ExecutorException: Statement returned more than one row, where no more than one was expected.

官方提示 虽然这种方式比较简单，但是，对于大量数据集或者列表性能并不好。这种问题也被称之为 “N + 1 Select 问题”。简而言之，N + 1 Select 问题是由类似如下引起的：

你执行单个 SQL 检索出一个记录列表（+1）
对于每个返回的记录，你执行 select 语句来加载每个的细节（N）

该问题会导致大量 SQL 执行，并不是可取的。MyBatis 可以拦截在这些查询语句，因此你可能会忽略这些语句的开销。但是，如果你加载这样的列表，然后立即迭代它访问嵌套数据，则会调用所有延迟加载，因此性能可能非常糟糕。

这也是在开发过程中比较忌讳的，在循环体中发起 SQL 查询

Nested Results for Association


属性
描述



resultMap
ID


columnPrefix
当 join 多张表时，你往往会使用别名来避免结果重复列名。指定 columnPrefix 允许你在映射时添加统一的前缀


notNullColumn



autoMapping
如果该属性存在，MyBatis 在映射该属性时，将会启用或者禁用自动映射


Multiple ResultSets for Associationcollection
嵌套 select
使用 join + 嵌套结果

Nested Select for Collection&lt;collection&gt; 元素将会使用新的属性 ofType，该属性适用于区分 Java Bean 属性类型和 collection 包含的类型。
Nested Results for Collection需要注意 collection 子元素 id 的重要性。
Multiple ResultSets for CollectiondiscriminatorAuto-mappingMyBatis 可以自动映射结果，你也可以自己构建 result map，你甚至可以结合两种。
通常，数据库列使用大写字母且单词之间用下划线，而 Java 属性通常遵循驼峰命名约定。可以设置 mapUnderscoreToCamelCase  为 true 完成自动映射。
即使存在 resultMap，自动映射也会发生。对于每个结果映射，在结果集中但没有进行手工映射的列，将会被自动映射，之后进行手工映射。
有 3 个映射级别：

NONE 禁用自动映射。即，只会赋值手动映射属性。
PARTIAL 除了其中定义的嵌套结果映射，其他都会自动映射
FULL 自动映射所有

3.6. cache默认地，只有 Local Cache 是启用的，用于缓存会话的数据。要启用全局二级缓存，你只需添加一行文字到你的 SQL Mapper 文件：
&lt;cache/&gt;


二级缓存需要配置 cacheEnabled 为 true 才会开启，一般默认是开启的，但建议显式设置。另外，使用二级缓存，还需要实体类实现 Serializable 接口，否则将会抛出异常。

这个简单的语句效果如下：

缓存所有映射语句文件中 SELECT 语句的结果
所有 insert, update, delete 语句将刷新缓存
缓存将使用最近最少使用（LRU）算法进行驱逐
缓存不会以基于计划的时间顺序刷新
缓存将存储 1024 个列表或对象的引用（无论方法返回什么）
缓存会被视为读&#x2F;写缓存，这意味，被检索的对象不会被共享，可以被调用者安全的修改，不会干扰其他线程可能的修改

Using a Custom Cache实现 Cache 接口，并在 Mapper 文件中指定 type：
&lt;cache type=&quot;com.domain.something.MyCustomCache&quot;/&gt;

cache-ref在不同 namespace 之间共享相同的缓存配置和实例：
&lt;cache-ref namespace=&quot;com.someone.application.data.SomeMapper&quot;/&gt;


5. Java API5.2. SqlSessions通过 SqlSession，你可以执行命令，获得 Mapper，管理事务。SqlSession 由 SqlSessionFactory 创建。
5.2.1. SqlSessionFactoryBuilderSqlSessionFactoryBuilder 有 5 个 build() 方法，每个方法允许你从不同来源构建 SqlSessionFactory。
SqlSessionFactory build(InputStream inputStream)SqlSessionFactory build(InputStream inputStream, String environment)SqlSessionFactory build(InputStream inputStream, Properties properties)SqlSessionFactory build(InputStream inputStream, String env, Properties props)SqlSessionFactory build(Configuration config)

environment MyBatis 将会使用的环境，如果没有调用包含 environment 参数的方法，则使用默认环境。
properties MyBatis 将会加载的属性，可使用 $&#123;propName&#125; 进行配置
关于 properties 加载的顺序 

首先，读取 properties 元素主体中指定的属性
其次，加载于 properties 元素的 resource 类路径资源或者 url 属性指定的资源将会被读取
最后，作为方法参数传递的 properties 最后读取

后加载的属性会覆盖前者
5.2.2. SqlSessionFactorySqlSessionFactory 有 6 种方法用于创建 SqlSession 实例。一般地，当你选择用哪个方法时，需要考虑以下事情：

Transaction：你是否希望为 session 使用事务范围，或者使用 auto-commit（这通常意味着数据库或 JDBC 没有事务）？
Connection：从 MyBatis 配置好的数据源获取还是自己提供
Execution：重用 PreparedStatement 还是批处理

SqlSession openSession()SqlSession openSession(boolean autoCommit)SqlSession openSession(Connection connection)SqlSession openSession(TransactionIsolationLevel level)SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level)SqlSession openSession(ExecutorType execType)SqlSession openSession(ExecutorType execType, boolean autoCommit)SqlSession openSession(ExecutorType execType, Connection connection)Configuration getConfiguration();
默认地，无参的 openSession() 将会创建具有如下特征的 SqlSession：

启动事务，即不会 auto commit
Connection 对象从 DataSource 中获取
事务隔离级别是驱动或者数据源使用的默认值
不会重用 PreparedStatements，不会批量更新

ExecutorType 参数定义了 3 个可选值：

ExecutorType.SIMPLE：朴素的执行器。为每个执行语句创建一个 PreparedStatement。
ExecutorType.REUSE：这种类型会重用 PreparedStatement。
ExecutorType.BATCH：批量更新，同时，如果执行语句之间有 SELECT 语句，也会在必要的地方划清。

5.2.3. SqlSession5.2.3.1. Statement Execution MethodsSqlSession 具有许多方法，用于执行 SQL 映射文件中定义的 SELECT, INSERT, UPDATE, DELETE 语句。每个方法都有一个 statement 参数（Statement ID），并且可以有 parameter 参数，参数可以是原始类型（自动装箱），或者 Java Bean，POJO，Map。
&lt;T&gt; T selectOne(String statement);&lt;T&gt; T selectOne(String statement, Object parameter);&lt;E&gt; List&lt;E&gt; selectList(String statement);&lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter);&lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds);&lt;T&gt; Cursor&lt;T&gt; selectCursor(String statement);&lt;T&gt; Cursor&lt;T&gt; selectCursor(String statement, Object parameter);&lt;T&gt; Cursor&lt;T&gt; selectCursor(String statement, Object parameter, RowBounds rowBounds);&lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, String mapKey);&lt;K,V&gt; Map&lt;K,V&gt; selectMap(String statement, Object parameter, String mapKey);&lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, Object parameter, String mapKey, RowBounds rowBounds);void select(String statement, ResultHandler handler);void select(String statement, Object parameter, ResultHandler handler);void select(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler);int insert(String statement);int insert(String statement, Object parameter);int update(String statement);int update(String statement, Object parameter);int delete(String statement);int delete(String statement, Object parameter)



selectOne 和 selectList 不同点在于， selectOne 必须返回一个对象或者 null（没有对象）。如果超过一个对象，则抛出异常。


如果你不知道有多少对象，使用 selectList 总是安全的。
如果你想检查对象是否存在，你最好返回一个计数值（0 或 1）。
selectMap 是一个特殊的情况，它会基于结果中的某个属性，将结果列表转换为一个 Map。
因为不是所有方法都需要参数，因此这些方法都有一个无参数的重载方法。
insert, update, delete 的返回值表示的是影响行数。
有几种高级的 select 方法，它们允许你限制要返回的行范围，或者提供自定义的结果处理逻辑（ResultHandler），通常用于非常大的数据集（MySQL 几乎不使用）。
&lt;E&gt; List&lt;E&gt; selectList (String statement, Object parameter, RowBounds rowBounds)&lt;T&gt; Cursor&lt;T&gt; selectCursor(String statement, Object parameter, RowBounds rowBounds)&lt;K,V&gt; Map&lt;K,V&gt; selectMap(String statement, Object parameter, String mapKey, RowBounds rowbounds)void select (String statement, Object parameter, ResultHandler&lt;T&gt; handler)void select (String statement, Object parameter, RowBounds rowBounds, ResultHandler&lt;T&gt; handler)
RowBounds 参数会让 MyBatis 跳过指定的记录数，同时限制要返回的记录数。


在这里，不同的驱动能够获得不同的效率。为了最佳性能，需要使用结果集类型为 SCROLL_SENSITIVE  或者 SCROLL_INSENSITIVE 


ResultHandler 参数允许你按照你的方式处理每一行。你可以把它添加到 List，创建一个 Map，Set，或者抛出买个结果，而只保留计算的计算的总数。你可以使用 ResultHandler 做任何事情，这就是 MyBatis 内部使用来构造结果集列表的。
ResultHandler 接口定义：
public interface ResultHandler&lt;T&gt; &#123;  void handleResult(ResultContext&lt;? extends T&gt; context);&#125;
ResultContext 参数用于访问结果对象本身，这是被创建的结果对象的数量计数，以及你可以使用 stop() 方法停止 MyBatis 加载更多结果。
使用 ResultHandler 有两点你应该了解：

使用 ResultHandler 调用的方法种的数据不会被缓存
当使用高级 resultMap 时，MyBatis 有可能需要多行来构建 1 个对象。如果使用 ResultHandler，可能会给你一个关联或者集合未被填充的对象。

Local CacheMyBatis 使用了 2 个缓存，Local Cache 和 二级缓存。
每次 MyBatis 创建新的会话时，也会创建一个 Local Cache 附加到会话中。在本次会话中执行的任何查询都将存储在本地缓存中，因此具有相同输入参数的相同查询，以后都不会查询数据库。当 update, commit, rollback 和 close 时，Local Cache 会清除。
1. Local Cache 原理 👇一般地，执行查询方法的时候都是调用 BaseExecutor 的 query() 方法，其方法内部会先考虑是否从 Local Cache 中获取数据，如果不从缓存中获取，则调用内部的 doQuery() 方法
Local Cache 的 Key 🐱org.apache.ibatis.cache.CacheKey 是 Local Cache 的 key
何时可能会失效 Local Cache（失效）？ 🐌
不同的会话

不同的 Session 本身不共享 Local Cache。我并不认为这是失效的原因。这反而是一种使用错误的方式。

执行 update 操作

如果执行了更新操作会清空 Local Cache
public int update(MappedStatement ms, Object parameter) throws SQLException &#123;    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing an update&quot;).object(ms.getId());    if (closed) &#123;        throw new ExecutorException(&quot;Executor was closed.&quot;);    &#125;    clearLocalCache();    return doUpdate(ms, parameter);&#125;


手动调用 DefaultSqlSession.clearCache()

底层会调用 executor 的 clearLocalCache() 方法

设置了语句属性 flushCache 为 true，缓存全清

设置 flushCacheRequired

配置 localCacheScope 为 STATEMENT

commit 和 rollback


Ensuring that SqlSession is Closed你必须确保关闭所有你打开的会话。推荐方式是使用 try 包裹资源。
Using MappersMapper Annotations


注解
目标
XML 等价物
描述



@CacheNamespace
Class
&lt;cache&gt;
为给定的命名空间配置缓存


@CacheNamespaceRef
Class
&lt;cacheRef&gt;
引用其他命名空间的缓存。注意：xml mapper 文件声明的缓存是隔离的


@MapKey
Method

用于返回类型是 Map 的方法。基于对象的属性将结果 List 转换为 Map。注解的属性 value 作为 Map 的 key


MyBatisPlus
Spring&lt;dependency&gt;	&lt;groupId&gt;com.baomidou&lt;/groupId&gt;	&lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;

@Configuration@MapperScan(basePackages = &#123;&quot;com.cannedbread.dictionary.mapper&quot;&#125;)public class MybatisPlusConfiguration &#123;    @Bean    public PaginationInterceptor paginationInterceptor() &#123;        return new PaginationInterceptor();    &#125;&#125;



分页插件

PageHelper

&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.2.12&lt;/version&gt;&lt;/dependency&gt;

使用方法：(1) PageHelper.start()，传入 pageNum 当前页码，pageSize 每页显示数目。(2) 调用 Mapper 方法查询(3) 使用 pageInfo 构造器传入查询结果集
public PageInfo&lt;ProjectArea&gt; listPageByExample(int pageNum, int pageSize, ProjectArea example) &#123;	PageHelper.startPage(pageNum, pageSize);	List&lt;ProjectArea&gt; result = projectAreaMapper.selectList(example);	PageInfo&lt;ProjectArea&gt; pageInfo = new PageInfo&lt;&gt;(result);	return pageInfo;&#125;


源码分析各种 Logger
PreparedStatementLogger
ConnectionLogger

StatementHandlerPreparedStatementHandler执行 SQL 的时候会将 statement 强制转换为 PreparedStatement 类型，并进行执行。
public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123;	PreparedStatement ps = (PreparedStatement) statement;	ps.execute();	return resultSetHandler.handleResultSets(ps);&#125;



SqlSource
RawSqlSource
DynamicSqlSource
StaticSqlSource，生成 BoundSQL

RawSqlSourceRawSqlSource 拥有一个 SqlSource 的属性，它是 StaticSqlSource：
public class RawSqlSource implements SqlSource &#123;	private final SqlSource sqlSource;&#125;



如何判断一个 SqlNode 是否是动态的 ?

如果是纯文本节点，且存在 $&#123;&#125;，认为是动态
如果是元素节点，则一定是动态

具体代码见 XMLScriptBuilder.parseDynamicTags &gt; TextSqlNode.isDynamic
为什么 RawSqlSource、DynamicSqlSource 不直接生成 BoundSQL，反而通过   StaticSqlSource 生成?
设计的问题
DynamicSqlSource 解析是对 SqlNode 的解析，其中会存储根节点 rootSqlNode，节点可以认为是类似 DOM 的节点。
rootSqlNode.apply(context); 即遍历 SqlNode 树进行解析，最终生成 context。
SqlNode
MixedSqlNode

SQL 语法树从结构来看是树形，但是 MyBatis 会将同一层的所有节点用 MixedSqlNode 包装，因此，从节点的角度看，是一个链表。
public boolean apply(DynamicContext context) &#123;    contents.forEach(node -&gt; node.apply(context));    return true;&#125;


StaticTextSqlNode 静态文本

TextSqlNode 包含了表达式的文本，如：select * from ${table}

IfSqlNode


计算表达式的值，如果为 true，则继续解析，一般 if 表达式下面就是静态文本了，所以大部分情况则是直接追加 SQL
public boolean apply(DynamicContext context) &#123;    if (evaluator.evaluateBoolean(test, context.getBindings())) &#123;        contents.apply(context);        return true;    &#125;    return false;&#125;


ForEachNode

解析完毕之后会生成特定的序列，其中每个每个
该解析一定会添加 open 与 close，所以如果在拼接 in 语句的时候没有元素，可能导致 SQL 错误

TrimSqlNode

从进入该节点开始，将会使用 FilteredDynamicContext 包装原来的 context，之后的结果会缓存在 FilteredDynamicContext 的 sqlBuffer 中，直至该节点解析完毕，最后使用 filteredDynamicContext.applyAll() 真正进行应用。
public boolean apply(DynamicContext context) &#123;    TrimSqlNode.FilteredDynamicContext filteredDynamicContext = new TrimSqlNode.FilteredDynamicContext(context);    boolean result = contents.apply(filteredDynamicContext);    filteredDynamicContext.applyAll();    return result;&#125;

为什么加这一个缓存 ?
如果直接追加 SQL 到最终的结果上，最后还需要做一步 trim，此时已经不方便 trim 了。

WhereSqlNode

将会删除特定的前缀，并追加前缀 WHERE
private static List&lt;String&gt; prefixList = Arrays.asList(&quot;AND &quot;,&quot;OR &quot;,&quot;AND\n&quot;, &quot;OR\n&quot;, &quot;AND\r&quot;, &quot;OR\r&quot;, &quot;AND\t&quot;, &quot;OR\t&quot;);

public class WhereSqlNode extends TrimSqlNode &#123;	public WhereSqlNode(Configuration configuration, SqlNode contents) &#123;		super(configuration, contents, &quot;WHERE&quot;, prefixList, null, null);	&#125;&#125;


rootSqlNode.apply(context)MapperProxyMapperProxy 是 MyBatis 中 InvacationHandler 的实现类。其中，包含一个 SqlSessionTemplate，SqlSessionTemplate 内部又包含一个 DefaultSqlSession 
为什么 SqlSessionTemplate 又使用代理对象 sqlSessionProxy 去执行方法？
为了实现拦截操作：
this.sqlSessionProxy = (SqlSession) newProxyInstance(SqlSessionFactory.class.getClassLoader(),    new Class[] &#123; SqlSession.class &#125;, new SqlSessionInterceptor());




CachingExecutor 的执行query(1) 获得 BoundSql
BoundSql 
(2) 创建缓存 key
创建是由 BaseExecutor 完成的，其中影响因素有：

MappedStatement.id，即方法全限定名
rowBounds.offset
rowBounds.limit
boundSql.sql
parameterMappings 的参数值
parameterMappings.environment.id

(3) flushCacheIfRequired(4) 使用代理 Executor 执行查询
SimpleExecutorqueryFromDatabase(1) 获取 Configuration(2) 创建 StatementHandler(3) prepareStatement(4) StatementHandler.query
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis Generator Eclipse 插件使用</title>
    <url>/2022/11/18/Framework/Java/MyBatis%20Generator/MyBatis-Generator-Eclipse-%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[参考http://mybatis.org/generator/generatedobjects/javamodel.html
http://mybatis.org/generator/generatedobjects/javaclient.html
Eclipse 插件
对于 java model 和 java client，在不使用 Eclipse MBG 插件的时候，不会合并这些 Java 文件。 这也是官方所告知的。

Eclipse Market 下载 MyBatis Generator，一般版本跟随 MyBatis Generator。
安装完插件之后：

你可以右键新建 MyBatis Generator Configuration File。
你可以右键 generatorConfig.xml &gt; Run As &gt; 1 Run MyBatis Generator 执行

注意点Classpath 配置问题如果你使用了 &lt;properties&gt; 配置，如下所示:
&lt;properties resource=&quot;generatorConfig.properties&quot; /&gt;

那么你要确保类路径存在 generatorConfig.properties，否则会提示找不到。此时，你需要将相关的类路径项目引入 Run As &gt; Run Configurations...
配置了 JDBC，那么也要在 Run As &gt; Run Configurations... 将 JDBC 的 jar 包添加到 classpath。
targetProject 问题使用 Eclipse 插件时，targetProject 不能配置成绝对路径，否则会报路径找不到。
]]></content>
  </entry>
  <entry>
    <title>MyBatis Generator Plugin</title>
    <url>/2022/11/23/Framework/Java/MyBatis%20Generator/MyBatis-Generator-Plugin/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>MyBatis Generator XmlFormatter</title>
    <url>/2022/11/23/Framework/Java/MyBatis%20Generator/MyBatis-Generator-XmlFormatter/</url>
    <content><![CDATA[0. 参考引用http://mybatis.org/generator/configreference/context.html
CustomXmlFormatter.java
说明默认情况下，MyBatis Generator 的 XML 文件缩进 2 格。这是硬编码的，如果需要修改缩进到 4 格，需要改写默认的 XmlFormatter。官方的参考请查阅这里。
具体来说，需要自定义 XmlFormatter，然后配置 &lt;context&gt; 元素下面的 &lt;property&gt; 属性，例如:
&lt;property name=&quot;xmlFormatter&quot; value=&quot;com.jiangchunbo.mybatis.generator.ext.CustomXmlFormatter&quot;/&gt;
]]></content>
      <tags>
        <tag>MyBatis Generator</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis Generator 官方翻译笔记</title>
    <url>/2022/08/16/Framework/Java/MyBatis%20Generator/MyBatis-Generator-%E5%AE%98%E6%96%B9%E7%BF%BB%E8%AF%91%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[参考引用http://mybatis.org/generator/
依赖&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;1.3.7&lt;/version&gt;        &lt;/plugin&gt;    &lt;plugins&gt;    &lt;/build&gt;

XML 配置参考&lt;context&gt;&lt;context&gt; 元素用于指定生成一组对象的环境。可以在 &lt;generatorConfiguration&gt; 元素中列出多个 &lt;context&gt; 元素，以允许在同一次运行 MyBatis Generator（MBG）中从不同的数据库或使用不同的生成参数生成对象。
Required Attributes
id

该上下文的唯一标识符。该值将会在一些错误信息中使用到。
Optional Attributes
defaultModelType

如果 targer runtime 是 MyBatis3Simple, MyBatis3DynamicSql, 或者 MyBatis3Kotlin，该属性会被忽略。

targetRuntime

该属性用于生成代码的运行时目标。
MyBatisDynamicSql
MyBatis3 使用该值，MBG 将生成与 MyBatis 3.0+，JSE 5.0+ 兼容的对象。这些生成的对象中的 “by example” 方法实际上支持无限制的动态 where 字句。此外，这些生成器生成的 Java 对象支持许多 JSE 5.0 特性，包括参数化类型和注解。
MyBatis3Simple 使用该值，MBG 将生成与 MyBatis 3.0+，JSE 5.0+ 兼容的对象。这个目标运行时生成的映射程序时非常基本的 CRUD 操作，只不过没有 “by example” 以及没有动态 SQL。这些生成器生成的 Java 对象支持许多 JSE 5.0 特性，包括参数化类型和注解。
Supported Properties
beginningDelimiter

endingDelimiter


&lt;commentGenerator&gt;
suppressAllComments此属性用于指定 MBG 是否在生成的代码中包含任何注释。

suppressDate此属性用于指定 MBG 是否将生成的时间戳在生成的注释中包括。

addRemarkComments此属性用于指定 MBG 是否将在生成的注释中包含来自 db 表的表备注和列备注。



警告: 如果 suppressAllComments 选项为 true，那么该选项会被忽略。即，该选项优先级比较低。

&lt;javaClientGenerator&gt;&lt;javaClientGenerator&gt; 元素用于定义 Java 客户端生成器的属性。
Required Attributes
type

该属性用来选择预定义的 Java 客户端生成器之一，或者指定一个用户提供的 Java 客户端生成器。
XMLMAPPER
生成的对象是 MyBatis 3.x mapper 基础设施的 Java 接口。接口将依赖于生成的 XML mapper 文件。

targetPackage

这是生成的接口和实现类所在的包。

targetProject

这用于为生成的接口和类指定目标项目。
Supported Properties
enableSubPackages该属性用于选择 MyBatis Generator 是否将基于内置表的 catelog 和 schema 为对象生成不同的 Java 包。

&lt;javaModelGenerator&gt;&lt;javaModelGenerator&gt; 元素用于定义 Java 模型生成器的属性。Java 模型生成器构建主键类，记录类，以及与自省表匹配的按照 Example 类查询。该元素是 &lt;context&gt; 元素必须的子元素。
必需的属性
targetPackage

这是生成的类将被放置的包。在默认的生成器中，属性 “enableSubPackages” 控制如何计算实际的包。如果为 true，则计算出的包是 targetPackage 加上表的 catalog 和 schema 的子包（如果存在）。

targetProject

这用于为生成的对象指定目标项目。在 Eclipse 环境中运行时，这将会指定保存对象的项目和源文件夹。在其他环境中，该值应该是本地文件系统上的已经存在的目录。如果此目录不存在， MyBatis Generator 将不会创建此目录。
可选
enableSubPackages

该属性用于选择 MyBatis Generator 是否将基于内置表的 catelog 和 schema 为对象生成不同的 Java 包。

建议: false


trimStrings该属性用于选择 MyBatis Generator 是否添加代码以修剪从数据库返回的字符字段的空白。


建议: true。尽管说数据库设计出现空白字符应该是一种设计失误。

&lt;jdbcConnection&gt;&lt;jdbcConnection&gt; 元素用于指定
&lt;properties&gt;&lt;properties&gt; 元素用于指定用于解析配置的外部属性文件。配置中的任何属性都将接受以 $&#123;property&#125; 格式的属性。
&lt;properties&gt; 元素是 &lt;generatorConfiguration&gt; 元素的子元素。
必须的属性
resource属性文件的完全限定名称

url用于属性文件的 URL 值


]]></content>
  </entry>
  <entry>
    <title>MyBatis PageHelper 记录</title>
    <url>/2022/11/23/Framework/Java/MyBatis%20PageHelper/MyBatis-PageHelper-%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[0. 参考引用https://github.com/pagehelper/Mybatis-PageHelperhttps://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md
如何使用?配置插件&lt;plugins&gt;    &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;    &lt;/plugin&gt;&lt;/plugins&gt;

代码使用官方推荐的方式:
PageHelper.startPage(1, 10);List&lt;User&gt; list = userMapper.selectIf(1);PageHelper.offsetPage(1, 10);List&lt;User&gt; list = userMapper.selectIf(1);
]]></content>
  </entry>
  <entry>
    <title>MyBatis Generator 实践笔记</title>
    <url>/2022/10/11/Framework/Java/MyBatis%20Generator/MyBatis-Generator-%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[参考引用https://developer.aliyun.com/article/828451
Maven 使用方式Maven 插件配置&lt;plugin&gt;    &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;    &lt;version&gt;1.4.1&lt;/version&gt;&lt;/plugin&gt;

在连续构建环境中，你可能希望自动执行 MBG 作为 Maven 构建的一部分。这可以通过将 goal 配置为自动执行来实现。
&lt;plugin&gt;    &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;    &lt;version&gt;1.4.1&lt;/version&gt;    &lt;executions&gt;        &lt;execution&gt;            &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt;            &lt;goals&gt;                &lt;goal&gt;generate&lt;/goal&gt;            &lt;/goals&gt;        &lt;/execution&gt;    &lt;/executions&gt;&lt;/plugin&gt;

如果你需要向插件的类路径添加一些东西（例如，JDBC 驱动程序），你可以通过向插件配置中添加依赖项来完成：
&lt;plugin&gt;    &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;    &lt;version&gt;1.3.7&lt;/version&gt;    &lt;configuration&gt;        &lt;overwrite&gt;true&lt;/overwrite&gt;        &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt;    &lt;/configuration&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.20&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/plugin&gt;



&lt;properties&gt;使用 &lt;properties&gt; 可以将属性定义在外部文件.
# 实体类的配置java-model-generator.target-package=java-model-generator.target-project=# XML Mapper 配置sql-map-generator.target-package=sql-map-generator.target-project=# DAO 配置java-client-generator.target-package=java-client-generator.target-project=# 数据库相关配置driver-class=connection-url=user-id=password=


&lt;context&gt;&lt;context id=&quot;myContext&quot; targetRuntime=&quot;MyBatis3&quot;&gt;    &lt;!-- PostgreSQL 界定符，不需要双引号就注释掉 --&gt;    &lt;property name=&quot;beginningDelimiter&quot; value=&quot;&amp;quot;&quot; /&gt;    &lt;property name=&quot;endingDelimiter&quot; value=&quot;&amp;quot;&quot; /&gt;    &lt;!-- 关于注解的时间格式化格式，给 SimpleDateFormat 用 --&gt;    &lt;property name=&quot;dateFormat&quot; value=&quot;yyyy-MM-dd HH:mm:ss&quot; /&gt;    &lt;!-- 指定编码。不指定可能会使用默认的 GBK --&gt;    &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot; /&gt;    &lt;!-- &lt;plugin type=&quot;org.mybatis.generator.plugins.UnmergeableXmlMappersPlugin&quot;/&gt; --&gt;    &lt;!-- &lt;plugin type=&quot;com.jiangchunbo.mybatis.generator.plugins.BasePlugin&quot;/&gt; --&gt;    &lt;plugin        type=&quot;com.jiangchunbo.mybatis.generator.plugins.RenameXmlMapperPlugin&quot; /&gt;    &lt;!-- &lt;plugin        type=&quot;com.jiangchunbo.mybatis.generator.plugins.LombokModelPlugin&quot; /&gt; --&gt;    &lt;commentGenerator type=&quot;com.jiangchunbo.mybatis.generator.plugins.CustomCommentGenerator&quot;&gt;        &lt;!-- 压制日期。如果为 true，则注释部分不显示日期 --&gt;        &lt;property name=&quot;suppressDate&quot; value=&quot;false&quot; /&gt;        &lt;!-- 压制所有注释。如果为 true，则注释不显示，将会导致合并代码失效 --&gt;        &lt;property name=&quot;suppressAllComments&quot; value=&quot;false&quot; /&gt;        &lt;property name=&quot;addRemarkComments&quot; value=&quot;true&quot; /&gt;        &lt;property name=&quot;dateFormat&quot;            value=&quot;yyyy-MM-dd HH:mm:ss&quot; /&gt;    &lt;/commentGenerator&gt;    &lt;!-- 数据库配置 --&gt;    &lt;jdbcConnection driverClass=&quot;$&#123;driver-class&#125;&quot;        connectionURL=&quot;$&#123;connection-url&#125;&quot; userId=&quot;$&#123;user-id&#125;&quot;        password=&quot;$&#123;password&#125;&quot;&gt;        &lt;property name=&quot;useInformationSchema&quot; value=&quot;true&quot; /&gt;    &lt;/jdbcConnection&gt;    &lt;!--         Java 类型处理器        处理 DB 类型到 Java 类型，默认使用 JavaTypeResolverDefaultImpl        注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型     --&gt;    &lt;javaTypeResolver&gt;        &lt;!--             true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型            false：默认,                scale&gt;0;length&gt;18：使用BigDecimal;                scale=0;length[10,18]：使用Long；                scale=0;length[5,9]：使用Integer；                scale=0;length&lt;5：使用Short；         --&gt;        &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;    &lt;/javaTypeResolver&gt;    &lt;!--         java模型创建器，是必须要的元素        负责：1，key类（见context的defaultModelType）；2，java类；3，查询类        targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制；        targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录     --&gt;    &lt;javaModelGenerator        targetPackage=&quot;$&#123;java-model-generator.target-package&#125;&quot;        targetProject=&quot;$&#123;java-model-generator.target-project&#125;&quot;&gt;        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;        &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;    &lt;/javaModelGenerator&gt;    &lt;sqlMapGenerator        targetPackage=&quot;$&#123;sql-map-generator.target-package&#125;&quot;        targetProject=&quot;$&#123;sql-map-generator.target-project&#125;&quot;&gt;        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;    &lt;/sqlMapGenerator&gt;    &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;        targetPackage=&quot;$&#123;java-client-generator.target-package&#125;&quot;        targetProject=&quot;$&#123;java-client-generator.target-project&#125;&quot;&gt;        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;    &lt;/javaClientGenerator&gt;    &lt;table tableName=&quot;abnormalstock_subtask_duration&quot;        domainObjectName=&quot;JnjSubtaskDuration&quot; enableInsert=&quot;true&quot;        enableSelectByPrimaryKey=&quot;true&quot;        enableUpdateByPrimaryKey=&quot;true&quot;        enableDeleteByPrimaryKey=&quot;false&quot;        enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;        enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;        selectByExampleQueryId=&quot;false&quot; /&gt;&lt;/context&gt;









自定义插件XmlMapperpublic class RenameXmlMapperPlugin extends PluginAdapter &#123;    private final String searchString = &quot;[A-Z][a-z]*&quot;;    private Pattern pattern;    @Override    public boolean validate(List&lt;String&gt; warnings) &#123;        pattern = Pattern.compile(searchString);        return true;    &#125;    @Override    public void initialized(IntrospectedTable introspectedTable) &#123;        String oldType = introspectedTable.getMyBatis3XmlMapperFileName();        Matcher matcher = pattern.matcher(oldType);        StringBuffer stringBuffer = new StringBuffer();        while(matcher.find()) &#123;            if (matcher.start() == 0) &#123;                matcher.appendReplacement(stringBuffer, matcher.group(0).toLowerCase());            &#125; else &#123;                matcher.appendReplacement(stringBuffer, &quot;_&quot; + matcher.group(0).toLowerCase());            &#125;        &#125;        stringBuffer.append(&quot;_mapping.xml&quot;);        introspectedTable.setMyBatis3XmlMapperFileName(stringBuffer.toString());    &#125;&#125;


基于 Lombok 的 DO 对象
如果你的数据库字段名为单字母开头，如: e_sales，那么 MBG 生成的 Getter Setter 将会是 geteSales 和 seteSales，这比较奇怪，用 Lombok 替换可以替换为 getESales 和 setESales

public class LombokModelPlugin extends PluginAdapter &#123;    @Override    public boolean validate(List&lt;String&gt; warnings) &#123;        return true;    &#125;    @Override    public boolean modelBaseRecordClassGenerated(TopLevelClass topLevelClass, IntrospectedTable introspectedTable) &#123;        //该代码表示在生成class的时候，向topLevelClass添加一个@Setter和@Getter注解        topLevelClass.addImportedType(&quot;lombok.Data&quot;);        topLevelClass.addAnnotation(&quot;@Data&quot;);        return super.modelBaseRecordClassGenerated(topLevelClass, introspectedTable);    &#125;    @Override    public boolean modelGetterMethodGenerated(Method method, TopLevelClass topLevelClass, IntrospectedColumn introspectedColumn, IntrospectedTable introspectedTable, ModelClassType modelClassType) &#123;        return false;    &#125;    @Override    public boolean modelSetterMethodGenerated(Method method, TopLevelClass topLevelClass, IntrospectedColumn introspectedColumn, IntrospectedTable introspectedTable, ModelClassType modelClassType) &#123;        return false;    &#125;&#125;

一些问题汇总
字段名和关键字冲突问题

配置界定符，MySQL 的界定符是 `
&lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;&gt;&lt;/property &gt;&lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;&gt;&lt;/property &gt;

在 table 节点添加属性 delimitAllColumns=&quot;true&quot;

UnmergeableXmlMappersPlugin

如果配置了该插件，MBG 的合并将会失效。如果 overwrite 为 true，那么会覆盖源文件！如果为 false，将会生成新文件（不包含原来自定义的节点）。

根据一些特定的注解识别是否需要覆盖。

&lt;plugin type=&quot;org.mybatis.generator.plugins.UnmergeableXmlMappersPlugin&quot;/&gt;



overwrite 和 mergeable

是否合并 XML 文件，通过属性 org.mybatis.generator.api.GeneratedXmlFile#isMergeable 表示。是否合并也可以理解为是否使用同一个文件。
当配置了 &lt;overwrite&gt;false&lt;/overwrite&gt;

如果 mergeable=true 合并，那么不会起作用
如果 mergeable=false 不合并，那么会生成新文件。之前的文件保留，但是后续需要自己做合并与删除。

当配置了 &lt;overwrite&gt;true&lt;/overwrite&gt;

如果 mergeable=true 合并，那么会追加 XML 节点，保留原来的节点。这样会产生许多重复 id 的节点。
如果 mergeable=false 不合并，那么会覆盖已经存在的 XML 文件。导致原来的内容覆盖丢失。

如果配置了 overwrite=true，那么在不合并模式下，会覆盖 XML Mapper 文件。
]]></content>
  </entry>
  <entry>
    <title>MyBatis Spring Mapper</title>
    <url>/2022/11/25/Framework/Java/MyBatis%20Spring/MyBatis-Spring-Mapper/</url>
    <content><![CDATA[Injecting Mappers无需使用 SqlSessionDaoSupport 或者 SqlSessionTemplate 手动编写数据访问对象（DAO），MyBatis-Spring 可以创建一个线程安全的 mapper，你可以直接将它注入到其他 Bean 中:
&lt;bean id=&quot;fooService&quot; class=&quot;org.mybatis.spring.sample.service.FooServiceImpl&quot;&gt;  &lt;constructor-arg ref=&quot;userMapper&quot; /&gt;&lt;/bean&gt;

注入之后，mapper 就可以在应用程序逻辑中使用了:
public class FooServiceImpl implements FooService &#123;  private final UserMapper userMapper;  public FooServiceImpl(UserMapper userMapper) &#123;    this.userMapper = userMapper;  &#125;  public User doSomeBusinessStuff(String userId) &#123;    return this.userMapper.getUser(userId);  &#125;&#125;


注意 这段代码中没有 SqlSession 或者 MyBatis 引用。也不需要创建，打开，关闭会话，MyBatis-Spring 会处理这些。

Registering a mapper注册 mapper 的方式取决于你使用的是经典的 XML 配置，还是新的 3.0+ Java Config（又名 @Configuration）。
With XML Config通过在你的 XML 配置文件中包含 MapperFactoryBean 注册一个 mapper，像下面这样:
&lt;bean id=&quot;userMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;  &lt;property name=&quot;mapperInterface&quot; value=&quot;org.mybatis.spring.sample.mapper.UserMapper&quot; /&gt;  &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt;

如果 UserMapper 在与 mapper 接口相同的类路径位置有一个相应的 MyBatis XML mapper 文件，那么它将由 MapperFactoryBean 自动解析。无需在 MyBatis 配置文件中指定 mapper，除非映射器 XML 文件位于不同的类路径位置。有关更多信息，请参见 SqlSessionFactoryBean 的 configLocation 属性。
注意，MapperFactoryBean 需要一个 SqlSessionFactory 或者一个 SqlSessionTemplate。这些可以通过各自的 sqlSessionFactory 以及 sqlSessionTemplate 属性进行设置。如果设置了这两个属性，SqlSessionFactory 将被忽略。由于 SqlSessionTemplate 需要设置 session factory，所以 MapperFactoryBean 将使用这个工厂。
With Java Config@Configurationpublic class MyBatisConfig &#123;  @Bean  public MapperFactoryBean&lt;UserMapper&gt; userMapper() throws Exception &#123;    MapperFactoryBean&lt;UserMapper&gt; factoryBean = new MapperFactoryBean&lt;&gt;(UserMapper.class);    factoryBean.setSqlSessionFactory(sqlSessionFactory());    return factoryBean;  &#125;&#125;


Scanning for mappers没有必要一个一个地注册所有的 mapper。相反，你可以让 MyBatis-Spring 为它们扫描你的类路径。
有三种不同的方式:

使用 &lt;mybatis:scan&gt; 元素
使用注解 @MapperScan
使用一个经典的 Spring xml 文件，并注册 MapperScannerConfigurer

&lt;mybatis:scan/&gt; 和 @MapperScan 都是 MyBatis-Spring 1.2.0 引入的特性。@MapperScan 需要 Spring 3.1+。
自 2.0.2 开始，mapper 扫描特性支持一个选项（lazy-initialization），其控制 mapper Bean 的延迟初始化启用&#x2F;禁用。添加这个选项的因素是由于 Spring Boot 2.2 支持的延迟初始化控制特性。该选项的默认值是 false（&#x3D; 不使用延迟初始化）。如果开发人员想对 mapper Bean 使用延迟初始化，它应该被显式地设置为 true。
@MapperScan如果你正在使用 Spring Java 配置（也就是 @Configuration），你会更愿意使用 @MapperScan 而不是 &lt;mybatis:scan/&gt;。
@MapperScan 注解使用如下:
@Configuration@MapperScan(&quot;org.mybatis.spring.sample.mapper&quot;)public class AppConfig &#123;  // ...&#125;

这个注解相较于上一章我们看到的 &lt;mybatis:scan/&gt;，以相同、精确的方式工作。它还允许你通过其属性 markerInterface 和 annotaionClass 指定标记接口。你还可以通过其属性 SqlSessionFactory 和 SqlSessionTemplate 来提供特定的 SqlSessionFactory 或 SqlSessionTemplate。

注意 如果 basePackageClasses 或者 basePackages 没有定义，则将从声明此注解的类的包中进行扫描。

MapperScannerConfigurerMapperScannerConfigurer 是一个 BeanDefinitionRegistryPostProcessor，它可以作为一个普通 Bean 包含在一个经典的 XML 应用程序上下文中。要设置 MapperScannerConfigurer，请将以下内容添加到 Spring 配置中:
&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;  &lt;property name=&quot;basePackage&quot; value=&quot;org.mybatis.spring.sample.mapper&quot; /&gt;&lt;/bean&gt;

如果你需要指定一个特定的 sqlSessionFactory 或 sqlSessionTemplate，请注意，需要的是 bean 名称，而不是 bean 引用，因此使用 value 属性而不是通常的 ref:
&lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt;


注意 sqlSessionFactoryBean 和 sqlSessionTemplateBean 属性是 MyBatis-Spring 1.0.2 之前唯一可用的选项，但鉴于 MapperScannerConfigurer 在启动过程中较早运行，PropertyPlaceholderConfigurer 经常出现错误。为此，已弃用该属性，建议使用新属性 sqlSessionFactoryBeanName 和 sqlSessionTemplateBeanName。

]]></content>
  </entry>
  <entry>
    <title>MyBatis Spring MapperScannerConfigurer</title>
    <url>/2022/11/25/Framework/Java/MyBatis%20Spring/MyBatis-Spring-MapperScannerConfigurer/</url>
    <content><![CDATA[MapperScannerConfigurer 是一个  BeanDefinitionRegistryPostProcessor。BeanDefinitionRegistryPostProcessor 的调用时机是 refresh() 方法中 postProcessBeanFactory 之后。其实现方法 postProcessBeanDefinitionRegistry 如下:
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123;    if (this.processPropertyPlaceHolders) &#123;        processPropertyPlaceHolders();    &#125;    ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);    scanner.setAddToConfig(this.addToConfig);    scanner.setAnnotationClass(this.annotationClass);    scanner.setMarkerInterface(this.markerInterface);    scanner.setSqlSessionFactory(this.sqlSessionFactory);    scanner.setSqlSessionTemplate(this.sqlSessionTemplate);    scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName);    scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName);    scanner.setResourceLoader(this.applicationContext);    scanner.setBeanNameGenerator(this.nameGenerator);    scanner.registerFilters();    scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage,            ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));&#125;

可以看到，MapperScannerConfigurer 构造了一个 org.mybatis.spring.mapper.ClassPathMapperScanner，并调用了它的 scan 方法。
ClassPathMapperScanner 继承自 org.springframework.context.annotation.ClassPathBeanDefinitionScanner，因此具有一些扫描类路径资源的能力。
问题MyBatis-Spring 的扫描默认扫描哪些接口?
先看 MapperScannerConfigurer 调用链：
org.mybatis.spring.mapper.MapperScannerConfigurer#postProcessBeanDefinitionRegistry
👉org.springframework.context.annotation.ClassPathBeanDefinitionScanner#scan
👉org.mybatis.spring.mapper.ClassPathMapperScanner#doScan
👉org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#findCandidateComponents
👉org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#isCandidateComponent
isCandidateComponent 是对父类 org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider 方法的重写: 
protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) &#123;    return beanDefinition.getMetadata().isInterface() &amp;&amp; beanDefinition.getMetadata().isIndependent();&#125;

只需要判断该类是不是接口，并且是”独立”的即可。

什么是"独立"的类?
注释文档是这样描述: Determine whether the underlying class is independent, i.e. whether it is a top-level class or a nested class (static inner class) that can be constructed independently from an enclosing class.

也就是顶级类或者嵌套类（静态内部类），相关信息参考Java 类(接口)的种类

]]></content>
      <tags>
        <tag>MyBatis Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis Spring SqlSession</title>
    <url>/2022/11/24/Framework/Java/MyBatis%20Spring/MyBatis-Spring-SqlSession/</url>
    <content><![CDATA[Using an SqlSession在 MyBatis 中，你使用 SqlSessionFactory 创建 SqlSession。一旦你有了会话，就可以使用它来执行映射语句，提交连接，或者回滚连接，最后，当不再需要它时，就关闭会话。
使用 MyBatis-Spring，你不必直接使用 SqlSessionFactory，因为你的 Bean 可以被注入一个线程安全的 SqlSession，该 SqlSession 可以根据 Spring 的事务配置自动提交、回滚以及关闭会话。
SqlSessionTemplateSqlSessionTemplate 是 MyBatis-Spring 的核心。它实现了 SqlSession，这意味着，可以替代代码中任何 SqlSession 的现有使用。SqlSessionTemplate 是线程安全的，可以由多个 DAO 或者映射器共享。

就是说，只需要一个 SqlSessionTemplate 就可以服务多个 SqlSession。

当调用 SQL 方法时，包括从 mapper 通过 getMapper() 返回的任何方法，SqlSessionTemplate 将确保使用的 SqlSession 是与当前 Spring 事务相关联的 SqlSession。此外，它还管理会话的生命周期，包括必要时关闭，提交，或者回滚会话。它还会将 MyBatis 的异常转换为 Spring 的 DataAccessException。
应该总是使用 SqlSessionTemplate 而不是默认的 MyBatis 实现 DefaultSqlSession，因为该 template 可以参与 Spring 事务，并且对于通过注入的多个 mapper 类是线程安全的。在同一个应用程序中的两个类之间切换可能会导致数据完整性问题。
SqlSessionTemplate 可以使用 SqlSessionFactory 作为构造函数参数来构造: 
&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;  &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt;

@Configurationpublic class MyBatisConfig &#123;  @Bean  public SqlSessionTemplate sqlSession() throws Exception &#123;    return new SqlSessionTemplate(sqlSessionFactory());  &#125;&#125;

该 Bean 现在可以直接注入到你的 DAO Bean 中。你在 Bean 中需要一个 SqlSession 属性，只要像下面这样:
public class UserDaoImpl implements UserDao &#123;  private SqlSession sqlSession;  public void setSqlSession(SqlSession sqlSession) &#123;    this.sqlSession = sqlSession;  &#125;  public User getUser(String userId) &#123;    return sqlSession.selectOne(&quot;org.mybatis.spring.sample.mapper.UserMapper.getUser&quot;, userId);  &#125;&#125;

然后，按如下方法注入 SqlSessionTemplate:
&lt;bean id=&quot;userDao&quot; class=&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;&gt;  &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot; /&gt;&lt;/bean&gt;

SqlSessionTemplate 还有一个构造函数，它接受 ExecutorType 作为参数。例如，这允许你在 Spring 的配置文件中使用以下内容来构造一个批处理 SqlSession: 
&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;  &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;  &lt;constructor-arg index=&quot;1&quot; value=&quot;BATCH&quot; /&gt;&lt;/bean&gt;

@Configurationpublic class MyBatisConfig &#123;  @Bean  public SqlSessionTemplate sqlSession() throws Exception &#123;    return new SqlSessionTemplate(sqlSessionFactory(), ExecutorType.BATCH);  &#125;&#125;

SqlSessionDaoSupportSqlSessionDaoSupport 是一个抽象支持类，它为你提供一个 SqlSession。调用 getSqlSession() 将得到一个 SqlSessionTemplate，然后可以使用它来执行 SQL 方法，如下所示:
public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao &#123;  public User getUser(String userId) &#123;    return getSqlSession().selectOne(&quot;org.mybatis.spring.sample.mapper.UserMapper.getUser&quot;, userId);  &#125;&#125;

通常 MapperFactoryBean 比这个类更受欢迎，因为它不需要额外的代码。但是，如果你需要在你的 DAO 中执行其他非 Mybatis 的工作，并且需要具体的类，那么这个类是有用的。
SqlSessionDaoSupport 要求设置一个 sqlSessionFactory 或者一个 sqlSessionTemplate 属性。如果两个属性都设置了，那么会忽略 sqlSessionFactory。
假设有一个 UserDaoImpl 类，它是 SqlSessionDaoSupport 的子类，它可以像下面这样在 Spring 中配置:
&lt;bean id=&quot;userDao&quot; class=&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;&gt;  &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt;]]></content>
      <tags>
        <tag>MyBatis Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis Spring 关于 TransactionSynchronizationManager 的使用</title>
    <url>/2022/11/24/Framework/Java/MyBatis%20Spring/MyBatis-Spring-%E5%85%B3%E4%BA%8E-TransactionSynchronizationManager-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[结论MyBatis 使用 TransactionSynchronizationManager 在事务中保存 SqlSession。
分析org.mybatis.spring.SqlSessionUtils 提供了一个获取 SqlSession 的方法 getSqlSession():
public static SqlSession getSqlSession(    SqlSessionFactory sessionFactory,     ExecutorType executorType,    PersistenceExceptionTranslator exceptionTranslator) &#123;    notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED);    notNull(executorType, NO_EXECUTOR_TYPE_SPECIFIED);    SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);    SqlSession session = sessionHolder(executorType, holder);    if (session != null) &#123;        return session;    &#125;    LOGGER.debug(() -&gt; &quot;Creating a new SqlSession&quot;);    session = sessionFactory.openSession(executorType);    registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session);    return session;&#125;

第9~11行通过 TransactionSynchronizationManager 尝试（从 ThreadLocal）获得一个 SqlSession。
首次运行，一定是无法获取到 SqlSession 的，因为 ThreadLocal 还没有注册 SqlSession。
执行到第17行才会执行注册 SqlSession 的逻辑:
private static void registerSessionHolder(SqlSessionFactory sessionFactory, ExecutorType executorType,        PersistenceExceptionTranslator exceptionTranslator, SqlSession session) &#123;    SqlSessionHolder holder;    if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;        Environment environment = sessionFactory.getConfiguration().getEnvironment();        if (environment.getTransactionFactory() instanceof SpringManagedTransactionFactory) &#123;            LOGGER.debug(() -&gt; &quot;Registering transaction synchronization for SqlSession [&quot; + session + &quot;]&quot;);            holder = new SqlSessionHolder(session, executorType, exceptionTranslator);            TransactionSynchronizationManager.bindResource(sessionFactory, holder);            TransactionSynchronizationManager                    .registerSynchronization(new SqlSessionSynchronization(holder, sessionFactory));            holder.setSynchronizedWithTransaction(true);            holder.requested();        &#125; else &#123;            if (TransactionSynchronizationManager.getResource(environment.getDataSource()) == null) &#123;                LOGGER.debug(() -&gt; &quot;SqlSession [&quot; + session                        + &quot;] was not registered for synchronization because DataSource is not transactional&quot;);            &#125; else &#123;                throw new TransientDataAccessResourceException(                        &quot;SqlSessionFactory must be using a SpringManagedTransactionFactory in order to use Spring transaction synchronization&quot;);            &#125;        &#125;    &#125; else &#123;        LOGGER.debug(() -&gt; &quot;SqlSession [&quot; + session                + &quot;] was not registered for synchronization because synchronization is not active&quot;);    &#125;&#125;

但是，如果 TransactionSynchronizationManager.isSynchronizationActive() 返回 false（即，没有激活同步），也不会执行注册逻辑。这个 isSynchronizationActive 的判断逻辑如下:
public static boolean isSynchronizationActive() &#123;    return (synchronizations.get() != null);&#125;

上面的代码表示，如果能够获取到 synchronizations，则表示同步被激活。synchronizations 的声明如下，它是 TransactionSynchronizationManager 内部的用于维护每个线程各自 Set&lt;TransactionSynchronization&gt; 的 ThreadLocal 对象:
private static final ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =        new NamedThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt;(&quot;Transaction synchronizations&quot;);



何时会激活同步也就是何时会调用 synchronizations 的 set() 方法，答案是开启事务的时候。
以下是一段编程式开启事务的代码示例:
TransactionStatus txStatus =    transactionManager.getTransaction(new DefaultTransactionDefinition());

getTransaction 的逻辑如下: 
public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException &#123;    Object transaction = doGetTransaction();    // Cache debug flag to avoid repeated checks.    boolean debugEnabled = logger.isDebugEnabled();    if (definition == null) &#123;        // Use defaults if no transaction definition given.        definition = new DefaultTransactionDefinition();    &#125;    if (isExistingTransaction(transaction)) &#123;        // Existing transaction found -&gt; check propagation behavior to find out how to behave.        return handleExistingTransaction(definition, transaction, debugEnabled);    &#125;    // Check definition settings for new transaction.    if (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;        throw new InvalidTimeoutException(&quot;Invalid transaction timeout&quot;, definition.getTimeout());    &#125;    // No existing transaction found -&gt; check propagation behavior to find out how to proceed.    if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;        throw new IllegalTransactionStateException(                &quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;);    &#125;    else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||            definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||            definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;        SuspendedResourcesHolder suspendedResources = suspend(null);        if (debugEnabled) &#123;            logger.debug(&quot;Creating new transaction with name [&quot; + definition.getName() + &quot;]: &quot; + definition);        &#125;        try &#123;            boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);            DefaultTransactionStatus status = newTransactionStatus(                    definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);            doBegin(transaction, definition);            prepareSynchronization(status, definition);            return status;        &#125;        catch (RuntimeException ex) &#123;            resume(null, suspendedResources);            throw ex;        &#125;        catch (Error err) &#123;            resume(null, suspendedResources);            throw err;        &#125;    &#125;    else &#123;        // Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.        if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;            logger.warn(&quot;Custom isolation level specified but no actual transaction initiated; &quot; +                    &quot;isolation level will effectively be ignored: &quot; + definition);        &#125;        boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);        return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null);    &#125;&#125;

第39行执行了prepareSynchronization方法，该方法就是操作 TransactionSynchronizationManager的，代码如下:
protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) &#123;    if (status.isNewSynchronization()) &#123;        TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction());        TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(                definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?                        definition.getIsolationLevel() : null);        TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly());        TransactionSynchronizationManager.setCurrentTransactionName(definition.getName());        TransactionSynchronizationManager.initSynchronization();    &#125;&#125;

第9行调用了 TransactionSynchronizationManager.initSynchronization() 方法，该方法对 synchronizations 进行了设置:
public static void initSynchronization() throws IllegalStateException &#123;    if (isSynchronizationActive()) &#123;        throw new IllegalStateException(&quot;Cannot activate transaction synchronization - already active&quot;);    &#125;    logger.trace(&quot;Initializing transaction synchronization&quot;);    synchronizations.set(new LinkedHashSet&lt;TransactionSynchronization&gt;());&#125;]]></content>
      <tags>
        <tag>MyBatis-Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis Spring 覆盖自定义 Environment</title>
    <url>/2022/11/24/Framework/Java/MyBatis%20Spring/MyBatis-Spring-%E8%A6%86%E7%9B%96%E8%87%AA%E5%AE%9A%E4%B9%89-Environment/</url>
    <content><![CDATA[MyBatis 的官方文档提及到: 

如果你打算将 MyBatis 与 Spring 一起使用，则不需要配置任何 TransactionManager，因为 Spring 模块将设置自己的 TransactionManager，覆盖之前设置的任何配置。

其实，如果你使用 MyBatis-Spring，你无需配置 &lt;environment&gt; 节点，配置了也无效。因为后续会使用 Spring 的 SpringManagedTransactionFactory 以及 IoC 容器内的 DataSource 覆盖配置项。具体见 SqlSessionFactoryBean.buildSqlSessionFactory 的执行逻辑:
protected SqlSessionFactory buildSqlSessionFactory() throws Exception &#123;    final Configuration targetConfiguration;    XMLConfigBuilder xmlConfigBuilder = null;    if (this.configuration != null) &#123;        targetConfiguration = this.configuration;        if (targetConfiguration.getVariables() == null) &#123;            targetConfiguration.setVariables(this.configurationProperties);        &#125; else if (this.configurationProperties != null) &#123;            targetConfiguration.getVariables().putAll(this.configurationProperties);        &#125;    &#125; else if (this.configLocation != null) &#123;        xmlConfigBuilder = new XMLConfigBuilder(this.configLocation.getInputStream(), null,                this.configurationProperties);        targetConfiguration = xmlConfigBuilder.getConfiguration();    &#125; else &#123;        LOGGER.debug(                () -&gt; &quot;Property &#x27;configuration&#x27; or &#x27;configLocation&#x27; not specified, using default MyBatis Configuration&quot;);        targetConfiguration = new Configuration();        Optional.ofNullable(this.configurationProperties).ifPresent(targetConfiguration::setVariables);    &#125;    Optional.ofNullable(this.objectFactory).ifPresent(targetConfiguration::setObjectFactory);    Optional.ofNullable(this.objectWrapperFactory).ifPresent(targetConfiguration::setObjectWrapperFactory);    Optional.ofNullable(this.vfs).ifPresent(targetConfiguration::setVfsImpl);    if (hasLength(this.typeAliasesPackage)) &#123;        scanClasses(this.typeAliasesPackage, this.typeAliasesSuperType).stream()                .filter(clazz -&gt; !clazz.isAnonymousClass()).filter(clazz -&gt; !clazz.isInterface())                .filter(clazz -&gt; !clazz.isMemberClass())                .forEach(targetConfiguration.getTypeAliasRegistry()::registerAlias);    &#125;    if (!isEmpty(this.typeAliases)) &#123;        Stream.of(this.typeAliases).forEach(typeAlias -&gt; &#123;            targetConfiguration.getTypeAliasRegistry().registerAlias(typeAlias);            LOGGER.debug(() -&gt; &quot;Registered type alias: &#x27;&quot; + typeAlias + &quot;&#x27;&quot;);        &#125;);    &#125;    if (!isEmpty(this.plugins)) &#123;        Stream.of(this.plugins).forEach(plugin -&gt; &#123;            targetConfiguration.addInterceptor(plugin);            LOGGER.debug(() -&gt; &quot;Registered plugin: &#x27;&quot; + plugin + &quot;&#x27;&quot;);        &#125;);    &#125;    if (hasLength(this.typeHandlersPackage)) &#123;        scanClasses(this.typeHandlersPackage, TypeHandler.class).stream().filter(clazz -&gt; !clazz.isAnonymousClass())                .filter(clazz -&gt; !clazz.isInterface()).filter(clazz -&gt; !Modifier.isAbstract(clazz.getModifiers()))                .forEach(targetConfiguration.getTypeHandlerRegistry()::register);    &#125;    if (!isEmpty(this.typeHandlers)) &#123;        Stream.of(this.typeHandlers).forEach(typeHandler -&gt; &#123;            targetConfiguration.getTypeHandlerRegistry().register(typeHandler);            LOGGER.debug(() -&gt; &quot;Registered type handler: &#x27;&quot; + typeHandler + &quot;&#x27;&quot;);        &#125;);    &#125;    targetConfiguration.setDefaultEnumTypeHandler(defaultEnumTypeHandler);    if (!isEmpty(this.scriptingLanguageDrivers)) &#123;        Stream.of(this.scriptingLanguageDrivers).forEach(languageDriver -&gt; &#123;            targetConfiguration.getLanguageRegistry().register(languageDriver);            LOGGER.debug(() -&gt; &quot;Registered scripting language driver: &#x27;&quot; + languageDriver + &quot;&#x27;&quot;);        &#125;);    &#125;    Optional.ofNullable(this.defaultScriptingLanguageDriver)            .ifPresent(targetConfiguration::setDefaultScriptingLanguage);    if (this.databaseIdProvider != null) &#123;// fix #64 set databaseId before parse mapper xmls        try &#123;            targetConfiguration.setDatabaseId(this.databaseIdProvider.getDatabaseId(this.dataSource));        &#125; catch (SQLException e) &#123;            throw new NestedIOException(&quot;Failed getting a databaseId&quot;, e);        &#125;    &#125;    Optional.ofNullable(this.cache).ifPresent(targetConfiguration::addCache);    if (xmlConfigBuilder != null) &#123;        try &#123;            xmlConfigBuilder.parse();            LOGGER.debug(() -&gt; &quot;Parsed configuration file: &#x27;&quot; + this.configLocation + &quot;&#x27;&quot;);        &#125; catch (Exception ex) &#123;            throw new NestedIOException(&quot;Failed to parse config resource: &quot; + this.configLocation, ex);        &#125; finally &#123;            ErrorContext.instance().reset();        &#125;    &#125;    targetConfiguration.setEnvironment(new Environment(this.environment,            this.transactionFactory == null ? new SpringManagedTransactionFactory() : this.transactionFactory,            this.dataSource));    if (this.mapperLocations != null) &#123;        if (this.mapperLocations.length == 0) &#123;            LOGGER.warn(() -&gt; &quot;Property &#x27;mapperLocations&#x27; was specified but matching resources are not found.&quot;);        &#125; else &#123;            for (Resource mapperLocation : this.mapperLocations) &#123;                if (mapperLocation == null) &#123;                    continue;                &#125;                try &#123;                    XMLMapperBuilder xmlMapperBuilder = new XMLMapperBuilder(mapperLocation.getInputStream(),                            targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments());                    xmlMapperBuilder.parse();                &#125; catch (Exception e) &#123;                    throw new NestedIOException(&quot;Failed to parse mapping resource: &#x27;&quot; + mapperLocation + &quot;&#x27;&quot;, e);                &#125; finally &#123;                    ErrorContext.instance().reset();                &#125;                LOGGER.debug(() -&gt; &quot;Parsed mapper file: &#x27;&quot; + mapperLocation + &quot;&#x27;&quot;);            &#125;        &#125;    &#125; else &#123;        LOGGER.debug(() -&gt; &quot;Property &#x27;mapperLocations&#x27; was not specified.&quot;);    &#125;    return this.sqlSessionFactoryBuilder.build(targetConfiguration);&#125;


第 85 行显示 xmlConfigBuilder 将会从配置文件中读取配置，但随即 94 行就对 Environment 进行了重新赋值。因此，从 &lt;environment&gt; 节点读取的信息会被覆盖。
]]></content>
  </entry>
  <entry>
    <title>Spring Boot 整合 MyBatis 启动原理</title>
    <url>/2022/07/15/Framework/Java/MyBatis%20Spring%20Boot%20Starter/Spring-Boot-%E6%95%B4%E5%90%88-MyBatis-%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[Spring Boot 整合 MyBatis 启动原理需要知道，MyBatis 是通过 JDK 动态代理技术创建 Mapper 接口的代理类的。
MyBatis 整合 Spring Boot 需要解决的是如何将自己创建的代理对象（java.lang.reflect.Proxy）交给 Spring 容器管理，这与将一个类（Class）交给 Spring 管理有所不同。

将对象交给 Spring 容器管理，我们可以选择注入 Bean Definition，然后让 Spring 完成对象构造、配置、初始化等操作，然后放到 singletonObjects 单例池中，也可以选择直接放到单例池中，也就是不构造 Bean Definition，也不会存在于 beanDefinitionMap，这就是下面提及的 SingletonBeanRegistry.registerSingleton 方式

将自定义的对象交给 Spring 容器管理，一般考虑的方式是：

@Bean
factory method
SingletonBeanRegistry.registerSingleton
FactoryBean

对于 @Bean 方式，我们可以使用这种方式：
@Beanpublic UserMapper videoMapper(SqlSession sqlSession) &#123;    // 添加到 MapperRegistry.knownMappers，否则 SqlSession.getMapper 会抛出异常    sqlSession.getConfiguration().addMapper(UserMapper.class);    return sqlSession.getMapper(UserMapper.class);&#125;
上述方式的确可行，但是我们每定义一个 Mapper 就需要写一个 @Bean 方法，还是比较麻烦的。
factory method 注入的方式与 @Bean 大同小异。
MyBatis 整合进 Spring 选择的是 FactoryBean 方式，通过向容器注入 FactoryBean 这种特殊的 Bean Definitnion，进而注入 Mapper
比较朴素的想法是，对于每个 Mapper 我们都为它定义一个 FactoryBean，但是这样工作量太大，MyBatis 通过动态 Class 实现了只需要一个 MapperFactoryBean 就可以构造出不同的 Mapper 实例

底层对应 MapperFactoryBean 的类属性 mapperInterface，表示不同的 Mapper 接口的 Class 对象

在使用 Spring 整合 MyBatis 的时候，通常会使用如下配置，这也是官网 Getting Started 提供的案例：
&lt;bean id=&quot;userMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;  &lt;property name=&quot;mapperInterface&quot; value=&quot;org.mybatis.spring.sample.mapper.UserMapper&quot; /&gt;  &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt;

MyBatis Spring Boot Starter 为了解决上述这种按需配置 MapperFactoryBean 的繁琐步骤，引入了 Spring 类路径扫描机制。
Spring Boot 加载 Mapper
Spring Boot 启动过程中，会调用 AbstractApplicationContext 的 refresh 方法，其中一个过程是 invokeBeanFactoryPostProcessors，它会调用 ConfigurationClassPostProcessor 后置处理器加载具有 @Configuration 注解的 Bean。
ConfigurationClassPostProcessor 关注的是 @Configuration 类型的 Bean，它会判断该 Bean 是否包含 @Import 注解。假设我们将 @MapperScan 添加在主启动类上（一般是具有 @SpringBootApplication 注解），那么将会读取主启动类注解，发现具有 @MapperScan，而 @MapperScan 嵌套了 @Import 注解，value 为 MapperScannerRegistrar.class，因此，将会构造MapperScannerRegistrar Bean Definition 进入 Spring 容器

当 @Configuration 类解析完毕加载到容器后，就会执行 load 方法，用于加载这些 @Configuration 类相关的 Bean、Resource 等（如 @Import, @ImportResource）：
this.reader.loadBeanDefinitions(configClasses)

当 load 完毕，此时 MapperScannerRegistrar 已经加载到 Spring 容器，而且 load 会主动触发 MapperScannerRegistrar 的回调方法 registerBeanDefinitions。
MapperScannerRegistrar 是 ImportBeanDefinitionRegistrars 的子类，其关键方法 registerBeanDefinitions 如下：
public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;    // 获得 @MapperScan 的全部属性    AnnotationAttributes mapperScanAttrs = AnnotationAttributes        .fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));    if (mapperScanAttrs != null) &#123;        registerBeanDefinitions(importingClassMetadata, mapperScanAttrs, registry,            generateBaseBeanName(importingClassMetadata, 0));    &#125;&#125;

在底层构造了一个 MapperScannerConfigurer Bean Definitnion，并注册到容器。
void registerBeanDefinitions(AnnotationMetadata annoMeta, AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry, String beanName) &#123;    // 构造 MapperScannerConfigurer Bean Definition    BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);    builder.addPropertyValue(&quot;processPropertyPlaceHolders&quot;, true);    Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass(&quot;annotationClass&quot;);    if (!Annotation.class.equals(annotationClass)) &#123;        builder.addPropertyValue(&quot;annotationClass&quot;, annotationClass);    &#125;    Class&lt;?&gt; markerInterface = annoAttrs.getClass(&quot;markerInterface&quot;);    if (!Class.class.equals(markerInterface)) &#123;        builder.addPropertyValue(&quot;markerInterface&quot;, markerInterface);    &#125;    Class&lt;? extends BeanNameGenerator&gt; generatorClass = annoAttrs.getClass(&quot;nameGenerator&quot;);    if (!BeanNameGenerator.class.equals(generatorClass)) &#123;        builder.addPropertyValue(&quot;nameGenerator&quot;, BeanUtils.instantiateClass(generatorClass));    &#125;    Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = annoAttrs.getClass(&quot;factoryBean&quot;);    if (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) &#123;        builder.addPropertyValue(&quot;mapperFactoryBeanClass&quot;, mapperFactoryBeanClass);    &#125;    String sqlSessionTemplateRef = annoAttrs.getString(&quot;sqlSessionTemplateRef&quot;);    if (StringUtils.hasText(sqlSessionTemplateRef)) &#123;        builder.addPropertyValue(&quot;sqlSessionTemplateBeanName&quot;, annoAttrs.getString(&quot;sqlSessionTemplateRef&quot;));    &#125;    String sqlSessionFactoryRef = annoAttrs.getString(&quot;sqlSessionFactoryRef&quot;);    if (StringUtils.hasText(sqlSessionFactoryRef)) &#123;        builder.addPropertyValue(&quot;sqlSessionFactoryBeanName&quot;, annoAttrs.getString(&quot;sqlSessionFactoryRef&quot;));    &#125;    // 收集 basePackage    List&lt;String&gt; basePackages = new ArrayList&lt;&gt;();    basePackages.addAll(        Arrays.stream(annoAttrs.getStringArray(&quot;value&quot;)).filter(StringUtils::hasText).collect(Collectors.toList()));    basePackages.addAll(Arrays.stream(annoAttrs.getStringArray(&quot;basePackages&quot;)).filter(StringUtils::hasText)        .collect(Collectors.toList()));    basePackages.addAll(Arrays.stream(annoAttrs.getClassArray(&quot;basePackageClasses&quot;)).map(ClassUtils::getPackageName)        .collect(Collectors.toList()));    if (basePackages.isEmpty()) &#123;        basePackages.add(getDefaultBasePackage(annoMeta));    &#125;    String lazyInitialization = annoAttrs.getString(&quot;lazyInitialization&quot;);    if (StringUtils.hasText(lazyInitialization)) &#123;        builder.addPropertyValue(&quot;lazyInitialization&quot;, lazyInitialization);    &#125;    String defaultScope = annoAttrs.getString(&quot;defaultScope&quot;);    if (!AbstractBeanDefinition.SCOPE_DEFAULT.equals(defaultScope)) &#123;        builder.addPropertyValue(&quot;defaultScope&quot;, defaultScope);    &#125;    // 设置 basePackage 属性，用逗号(,)分隔    builder.addPropertyValue(&quot;basePackage&quot;, StringUtils.collectionToCommaDelimitedString(basePackages));    registry.registerBeanDefinition(beanName, builder.getBeanDefinition());&#125;

MapperScannerConfigurer 是 BeanDefinitionRegistryPostProcessor 的实现类，也就说其调用时机在 refresh 方法的 invokeBeanFactoryPostProcessors 中，它执行了类路径扫描，并注册了相关的 Mapper，关键方法如下：
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123;    if (this.processPropertyPlaceHolders) &#123;        processPropertyPlaceHolders();    &#125;    // 创建扫描器    ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);    scanner.setAddToConfig(this.addToConfig);    scanner.setAnnotationClass(this.annotationClass);    scanner.setMarkerInterface(this.markerInterface);    scanner.setSqlSessionFactory(this.sqlSessionFactory);    scanner.setSqlSessionTemplate(this.sqlSessionTemplate);    scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName);    scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName);    scanner.setResourceLoader(this.applicationContext);    scanner.setBeanNameGenerator(this.nameGenerator);    scanner.setMapperFactoryBeanClass(this.mapperFactoryBeanClass);    if (StringUtils.hasText(lazyInitialization)) &#123;        scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));    &#125;    if (StringUtils.hasText(defaultScope)) &#123;        scanner.setDefaultScope(defaultScope);    &#125;    scanner.registerFilters();    // 这里将之前用逗号(,)分隔的 basePackage 字符串分解成 String[]    scanner.scan(        StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));&#125;

ClassPathBeanDefinitionScanner 的 scan 方法如下：
public int scan(String... basePackages) &#123;    int beanCountAtScanStart = this.registry.getBeanDefinitionCount();    doScan(basePackages);    // Register annotation config processors, if necessary.    if (this.includeAnnotationConfig) &#123;        AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);    &#125;    return (this.registry.getBeanDefinitionCount() - beanCountAtScanStart);&#125;

ClassPathBeanDefinitionScanner 的 doScan 方法如下，它返回扫描到的所有 BeanDefinitionHolder 的集合：
protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123;    Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;&gt;();    for (String basePackage : basePackages) &#123;        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);        for (BeanDefinition candidate : candidates) &#123;            ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);            candidate.setScope(scopeMetadata.getScopeName());            String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);            if (candidate instanceof AbstractBeanDefinition) &#123;                postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);            &#125;            if (candidate instanceof AnnotatedBeanDefinition) &#123;                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);            &#125;            if (checkCandidate(beanName, candidate)) &#123;                BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);                definitionHolder =                        AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);                beanDefinitions.add(definitionHolder);                registerBeanDefinition(definitionHolder, this.registry);            &#125;        &#125;    &#125;    return beanDefinitions;&#125;

MyBatis 覆盖了原来的 doScan 方法，因为我们不能把扫描到的 Mapper 接口交给 Spring 容器，否则后续的实例化将无法进行。因此，MyBatis 在调用 super.doScan() 方法得到扫描到的 Set&lt;BeanDefinitionHolder&gt; 之后又进行后置处理：
public Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123;    // 调用 Spring 内置提供的 doScan 方法    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = super.doScan(basePackages);    if (beanDefinitions.isEmpty()) &#123;        LOGGER.warn(() -&gt; &quot;No MyBatis mapper was found in &#x27;&quot; + Arrays.toString(basePackages)            + &quot;&#x27; package. Please check your configuration.&quot;);    &#125; else &#123;        // 后置处理        processBeanDefinitions(beanDefinitions);    &#125;    return beanDefinitions;&#125;

MyBatis 的 ClassPathMapperScanner 后置处理方法如下：
private void processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt; beanDefinitions) &#123; AbstractBeanDefinition definition;    BeanDefinitionRegistry registry = getRegistry();    for (BeanDefinitionHolder holder : beanDefinitions) &#123;        definition = (AbstractBeanDefinition) holder.getBeanDefinition();        boolean scopedProxy = false;        if (ScopedProxyFactoryBean.class.getName().equals(definition.getBeanClassName())) &#123;            definition = (AbstractBeanDefinition) Optional                .ofNullable(((RootBeanDefinition) definition).getDecoratedDefinition())                .map(BeanDefinitionHolder::getBeanDefinition).orElseThrow(() -&gt; new IllegalStateException(                    &quot;The target bean definition of scoped proxy bean not found. Root bean definition[&quot; + holder + &quot;]&quot;));            scopedProxy = true;        &#125;        // 扫描到的 Mapper 接口，因此这里获取到的应该是形如 UserMapper 之类的        String beanClassName = definition.getBeanClassName();        LOGGER.debug(() -&gt; &quot;Creating MapperFactoryBean with name &#x27;&quot; + holder.getBeanName() + &quot;&#x27; and &#x27;&quot; + beanClassName            + &quot;&#x27; mapperInterface&quot;);        // Mapper 接口是 Bean 原始的类型，但是实际类型是 MapperFactoryBean        // 将原始类型（Mapper）作为构造器参数传入        definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); // issue #59        // 将 BeanClass 强制修改为 MapperFactoryBean 类型        definition.setBeanClass(this.mapperFactoryBeanClass);        definition.getPropertyValues().add(&quot;addToConfig&quot;, this.addToConfig);        // Attribute for MockitoPostProcessor        // https://github.com/mybatis/spring-boot-starter/issues/475        definition.setAttribute(FACTORY_BEAN_OBJECT_TYPE, beanClassName);        boolean explicitFactoryUsed = false;        if (StringUtils.hasText(this.sqlSessionFactoryBeanName)) &#123;        definition.getPropertyValues().add(&quot;sqlSessionFactory&quot;,            new RuntimeBeanReference(this.sqlSessionFactoryBeanName));        explicitFactoryUsed = true;        &#125; else if (this.sqlSessionFactory != null) &#123;        definition.getPropertyValues().add(&quot;sqlSessionFactory&quot;, this.sqlSessionFactory);        explicitFactoryUsed = true;        &#125;        if (StringUtils.hasText(this.sqlSessionTemplateBeanName)) &#123;        if (explicitFactoryUsed) &#123;            LOGGER.warn(                () -&gt; &quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;);        &#125;        definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;,            new RuntimeBeanReference(this.sqlSessionTemplateBeanName));        explicitFactoryUsed = true;        &#125; else if (this.sqlSessionTemplate != null) &#123;        if (explicitFactoryUsed) &#123;            LOGGER.warn(                () -&gt; &quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;);        &#125;        definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;, this.sqlSessionTemplate);        explicitFactoryUsed = true;        &#125;        if (!explicitFactoryUsed) &#123;        LOGGER.debug(() -&gt; &quot;Enabling autowire by type for MapperFactoryBean with name &#x27;&quot; + holder.getBeanName() + &quot;&#x27;.&quot;);        definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);        &#125;        definition.setLazyInit(lazyInitialization);        if (scopedProxy) &#123;        continue;        &#125;        if (ConfigurableBeanFactory.SCOPE_SINGLETON.equals(definition.getScope()) &amp;&amp; defaultScope != null) &#123;        definition.setScope(defaultScope);        &#125;        if (!definition.isSingleton()) &#123;        BeanDefinitionHolder proxyHolder = ScopedProxyUtils.createScopedProxy(holder, registry, true);        if (registry.containsBeanDefinition(proxyHolder.getBeanName())) &#123;            registry.removeBeanDefinition(proxyHolder.getBeanName());        &#125;        registry.registerBeanDefinition(proxyHolder.getBeanName(), proxyHolder.getBeanDefinition());        &#125;    &#125;&#125;


AutoConfiguredMapperScannerRegistrar如果没有发现 MapperScannerConfigurer 就会导入 AutoConfiguredMapperScannerRegistrar：
@org.springframework.context.annotation.Configuration@Import(AutoConfiguredMapperScannerRegistrar.class)@ConditionalOnMissingBean(&#123; MapperFactoryBean.class, MapperScannerConfigurer.class &#125;)public static class MapperScannerRegistrarNotFoundConfiguration implements InitializingBean &#123;    @Override    public void afterPropertiesSet() &#123;        logger.debug(            &quot;Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer.&quot;);    &#125;&#125;

AutoConfiguredMapperScannerRegistrar 的定义如下：
public static class AutoConfiguredMapperScannerRegistrar implements BeanFactoryAware, ImportBeanDefinitionRegistrar &#123;    private BeanFactory beanFactory;    @Override    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;        if (!AutoConfigurationPackages.has(this.beanFactory)) &#123;        logger.debug(&quot;Could not determine auto-configuration package, automatic mapper scanning disabled.&quot;);        return;        &#125;        logger.debug(&quot;Searching for mappers annotated with @Mapper&quot;);        List&lt;String&gt; packages = AutoConfigurationPackages.get(this.beanFactory);        if (logger.isDebugEnabled()) &#123;        packages.forEach(pkg -&gt; logger.debug(&quot;Using auto-configuration base package &#x27;&#123;&#125;&#x27;&quot;, pkg));        &#125;        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);        builder.addPropertyValue(&quot;processPropertyPlaceHolders&quot;, true);        builder.addPropertyValue(&quot;annotationClass&quot;, Mapper.class);        builder.addPropertyValue(&quot;basePackage&quot;, StringUtils.collectionToCommaDelimitedString(packages));        BeanWrapper beanWrapper = new BeanWrapperImpl(MapperScannerConfigurer.class);        Set&lt;String&gt; propertyNames = Stream.of(beanWrapper.getPropertyDescriptors()).map(PropertyDescriptor::getName)            .collect(Collectors.toSet());        if (propertyNames.contains(&quot;lazyInitialization&quot;)) &#123;        // Need to mybatis-spring 2.0.2+        builder.addPropertyValue(&quot;lazyInitialization&quot;, &quot;$&#123;mybatis.lazy-initialization:false&#125;&quot;);        &#125;        if (propertyNames.contains(&quot;defaultScope&quot;)) &#123;        // Need to mybatis-spring 2.0.6+        builder.addPropertyValue(&quot;defaultScope&quot;, &quot;$&#123;mybatis.mapper-default-scope:&#125;&quot;);        &#125;        registry.registerBeanDefinition(MapperScannerConfigurer.class.getName(), builder.getBeanDefinition());    &#125;    @Override    public void setBeanFactory(BeanFactory beanFactory) &#123;        this.beanFactory = beanFactory;    &#125;`&#125;

分析：
实现了 BeanFactoryAware 接口，因此该 Bean 在构造的过程中会自动调用 setBeanFactory 方法，使得该 Bean 获得 beanFactory 的引用
实现了 ImportBeanDefinitionRegistrar 接口，
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro BasicHttpAuthenticationFilter 认证流程</title>
    <url>/2022/07/08/Framework/Java/Shiro/Shiro-BasicHttpAuthenticationFilter-%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[Shiro BasicHttpAuthenticationFilter 认证流程分析以 Shiro 1.8.0 为例子，其中新增了一些新的组件，譬如 HttpAuthenticationFilter之前使用的 1.4.1 并不存在 HttpAuthenticationFilter 组件
1. BasicHttpAuthenticationFilter 层次结构要分析 BasicHttpAuthenticationFilter 的认证流程，其实也是分析该过滤器（doFilter）的执行流程，而该过滤器的继承层次有一定复杂度，因此先了解一下其继承结构：



2. OncePerRequestFilter.doFilter从继承关系可以看到 BasicHttpAuthenticationFilter 继承自抽象类 OncePerRequestFilter。

OncePerRequestFilter 的字面意思是：Once Per Request，即每个请求只执行一次，它巧妙的设计使得无论添加多少个过滤器，都只执行一次。

如下是 OncePerRequestFilter 的 doFilter 方法：
@Overridepublic final void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)        throws ServletException, IOException &#123;    if (!(request instanceof HttpServletRequest) || !(response instanceof HttpServletResponse)) &#123;        throw new ServletException(&quot;OncePerRequestFilter just supports HTTP requests&quot;);    &#125;    HttpServletRequest httpRequest = (HttpServletRequest) request;    HttpServletResponse httpResponse = (HttpServletResponse) response;    String alreadyFilteredAttributeName = getAlreadyFilteredAttributeName();    boolean hasAlreadyFilteredAttribute = request.getAttribute(alreadyFilteredAttributeName) != null;    if (hasAlreadyFilteredAttribute || skipDispatch(httpRequest) || shouldNotFilter(httpRequest)) &#123;        // 继续执行，不调用此过滤器        filterChain.doFilter(request, response);    &#125;    else &#123;        // 调用该过滤器        request.setAttribute(alreadyFilteredAttributeName, Boolean.TRUE);        try &#123;            doFilterInternal(httpRequest, httpResponse, filterChain);        &#125;        finally &#123;            // 为本次请求删除 &quot;已经过滤&quot; 的请求属性，能够释放一些空间            request.removeAttribute(alreadyFilteredAttributeName);        &#125;    &#125;&#125;


3. AdviceFilter.doFilterInternal可以知道 OncePerRequestFilter 已经实现了 doFilter，而且知道，真正的处理逻辑在 doFilterInternal() 方法中。然而，doFilterInternal() 方法是在子类 AdviceFilter 实现的，源码如下：
public void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain)    throws ServletException, IOException &#123;    Exception exception = null;    try &#123;        // 前置处理        boolean continueChain = preHandle(request, response);        if (log.isTraceEnabled()) &#123;            log.trace(&quot;Invoked preHandle method.  Continuing chain?: [&quot; + continueChain + &quot;]&quot;);        &#125;        // 是否继续        if (continueChain) &#123;            executeChain(request, response, chain);        &#125;        // 后置处理        postHandle(request, response);        if (log.isTraceEnabled()) &#123;            log.trace(&quot;Successfully invoked postHandle method&quot;);        &#125;    &#125; catch (Exception e) &#123;        exception = e;    &#125; finally &#123;        cleanup(request, response, exception);    &#125;&#125;



4. PathMatchingFilter.preHandle下面先看 preHandle，PathMatchingFilter 已经实现了 preHandle()。PathMatchingFilter，顾名思义，路径匹配过滤器，它的作用就是来根据路径匹配结果，调用相应过滤器（没匹配上的直接 return true，即继续执行过滤器链）。

path 匹配是通过 FilterChainDefinitionMap 注册的，比如设置了 “&#x2F;login”, “anon”，那么如果本次请求的地址也是 &#x2F;login，则会匹配上。

protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception &#123;    if (this.appliedPaths == null || this.appliedPaths.isEmpty()) &#123;        if (log.isTraceEnabled()) &#123;            log.trace(&quot;appliedPaths property is null or empty.  This Filter will passthrough immediately.&quot;);        &#125;        return true;    &#125;    for (String path : this.appliedPaths.keySet()) &#123;        // If the path does match, then pass on to the subclass implementation for        // specific checks        // (first match &#x27;wins&#x27;):        if (pathsMatch(path, request)) &#123;            log.trace(&quot;Current requestURI matches pattern &#x27;&#123;&#125;&#x27;.  Determining filter chain execution...&quot;, path);            Object config = this.appliedPaths.get(path);            return isFilterChainContinued(request, response, path, config);        &#125;    &#125;    // no path matched, allow the request to go through:    return true;&#125;

上述代码中的 config 对象具有非常高的灵活性，在 BasicHttpAuthenticationFilter 的流程中，你可以进行一些 HTTP Method、permissive 的特殊配置，这些设计都是内嵌在过滤器中的：
// 表示对于 /** 的 GET POST 请求都需要经过 Basic 验证chainDefinition.addPathDefinition(&quot;/**&quot;, &quot;authcBasic[get,post]&quot;);// 表示对于 /permissive 开头的请求都会放行chainDefinition.addPathDefinition(&quot;/permissive/**&quot;, &quot;authcBasic[permissive]&quot;);

如果 path 匹配成功，则会先执行 isFilterChainContinued()，isFilterChainContinued() 方法也是在 PathMatchingFilter 实现的。它的作用就是判断过滤器是否可用，如果可用就继续执行；否则，跳过，return true。
private boolean isFilterChainContinued(ServletRequest request, ServletResponse response,    String path, Object pathConfig) throws Exception &#123;    if (isEnabled(request, response, path, pathConfig)) &#123; // isEnabled check added in 1.2        if (log.isTraceEnabled()) &#123;            log.trace(&quot;Filter &#x27;&#123;&#125;&#x27; is enabled for the current request under path &#x27;&#123;&#125;&#x27; with config [&#123;&#125;].  &quot; +                &quot;Delegating to subclass implementation for &#x27;onPreHandle&#x27; check.&quot;,                new Object[] &#123; getName(), path, pathConfig &#125;);        &#125;//The filter is enabled for this specific request, so delegate to subclass implementations//so they can decide if the request should continue through the chain or not:        return onPreHandle(request, response, pathConfig);    &#125;    if (log.isTraceEnabled()) &#123;        log.trace(&quot;Filter &#x27;&#123;&#125;&#x27; is disabled for the current request under path &#x27;&#123;&#125;&#x27; with config [&#123;&#125;].  &quot; +            &quot;The next element in the FilterChain will be called immediately.&quot;,            new Object[] &#123; getName(), path, pathConfig &#125;);    &#125;//This filter is disabled for this specific request,//return &#x27;true&#x27; immediately to indicate that the filter will not process the request//and let the request/response to continue through the filter chain:    return true;&#125;


isEnabled 方法本质上是判断 enabled 是否为 true。其实几乎所有的过滤器都可以执行，因此 enabled 默认为 true，除非人为的去设置它的值：
5. AccessControlFilter.onPreHandle从 preHandle() 走下来的，这里之所以起名为 onPreHandle()，是因为这才是真正的执行逻辑，之前的种种都是可以看作判断。
onPreHandle() 在 PathMatchingFilter 的子类 AccessControlFilter 有了新的实现，它的返回值依赖两个方法 isAccessAllowed()、onAccessDenied()。
public boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception &#123;    return isAccessAllowed(request, response, mappedValue) || onAccessDenied(request, response, mappedValue);&#125;
上述逻辑可以转换为：
public boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception &#123;    if (isAccessAllowed(request, response, mappedValue)) &#123;        return true;    &#125;    return onAccessDenied(request, response, mappedValue);&#125;

6. HttpAuthenticationFilter.isAccessAllowed当执行 AccessControlFilter.onPreHandle 会首先判断 isAccessAllowed
protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) &#123;    HttpServletRequest httpRequest = WebUtils.toHttp(request);    String httpMethod = httpRequest.getMethod();    // Check whether the current request&#x27;s method requires authentication.    // If no methods have been configured, then all of them require auth,    // otherwise only the declared ones need authentication.    // 此处的 mappedValue 其实就是上述的 config 对象，本质上是一个 String[]    // 这里可以校验一些 HTTP Method 是否需要认证    // 这也就是为什么你可以设计为 authBasic[get,post]    Set&lt;String&gt; methods = httpMethodsFromOptions((String[]) mappedValue);    boolean authcRequired = methods.size() == 0;    for (String m : methods) &#123;        if (httpMethod.toUpperCase(Locale.ENGLISH).equals(m)) &#123;            // 需要认证            authcRequired = true;            break;        &#125;    &#125;    if (authcRequired) &#123;        return super.isAccessAllowed(request, response, mappedValue);    &#125; else &#123;        return true;    &#125;&#125;
上述校验 HTTP Method 的方法对 RESTful 风格非常有效：实际上，该方法先做了一个 HTTP Method 的比对，自定义 FilterChainDefinitionMap 的时候，可以设置一批 HTTP method 是需要认证的，比如：如果当前使用 RESTful 风格请求。现有 [PUT] &#x2F;project 用于更新，[GET] &#x2F;project 用于获取全部数据，这两个请求 URL 都是一样的，但如何让 GET 请求通过，PUT 请求需要授权呢？答案就是使用 HTTP Method 方法过滤。配置 &#x2F;project &#x3D; authcBasic[PUT]那么，访问 &#x2F;project 的时候，GET 方法是不用认证的。所以现在知道，即使没有写 GET，依然也会走 BasicHttpAuthenticationFilter，只是认证直接跳过（return true）。因此，如果 HTTP Method 属于这一类 Method，那么就调用了 super.isAccessAllowed 进行判断。
7. AuthenticationFilter.isAccessAllowed下面继续观察 super.isAccessAllowed() 方法到底做了什么？
首先，在继承链上，离 HttpAuthenticationFilter 最近的 AuthenticatingFilter 也实现了 isAccessAllowed() 方法，如下所示：
protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) &#123;    return super.isAccessAllowed(request, response, mappedValue) ||            (!isLoginRequest(request, response) &amp;&amp; isPermissive(mappedValue));&#125;


注意到，该方法也使用了 super 去调用父类方法，找到最近的有实现方法的父类 AuthenticationFilter，方法如下：
protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) &#123;    Subject subject = getSubject(request, response);    return subject.isAuthenticated();&#125;

获取 Subject，然后调用 isAuthenticated() 判断是否已经认证过了。

作用：判断是否认证过了，通俗来说，就是登陆了没。

如果 isAccessAllowed 返回 false，表示不允许访问，那么需要继续判断：
!isLoginRequest(request, response) &amp;&amp; isPermissive(mappedValue)

isLoginRequest() 的判断，在本 BasicHttpAuthenticationFilter 的案例中，根据请求头判断isPermissive() 的判断是根据你是否在 chainDefinition 配置 [permissive]

8. BasicHttpAuthenticationFilter.isLoginRequestprotected final boolean isLoginRequest(ServletRequest request, ServletResponse response) &#123;    return this.isLoginAttempt(request, response);&#125;protected boolean isLoginAttempt(ServletRequest request, ServletResponse response) &#123;    String authzHeader = getAuthzHeader(request);    // 判断头部 Authorization 是否以 BASIC 开头    return authzHeader != null &amp;&amp; isLoginAttempt(authzHeader);&#125;

9. BasicHttpAuthenticationFilter.onAccessDenied回到 AccessControlFilter.onPreHandle 第二个处理逻辑 —— onAccessDenied
该方法就是 isAccessAllowed 返回 false 之后执行的，即访问拒绝的逻辑。
BasicHttpAuthenticationFilter 实现了自己的 onAccessDenied：
protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception &#123;    boolean loggedIn = false; // false by default or we wouldn&#x27;t be in this method    // 判断是否是 Basic 特定请求头    if (isLoginAttempt(request, response)) &#123;        loggedIn = executeLogin(request, response);    &#125;    if (!loggedIn) &#123;        // 发送质询        sendChallenge(request, response);    &#125;    return loggedIn;&#125;


10. AuthenticatingFilter.executeLoginBasicHttpAuthenticationFilter 是没有实现 executeLogin() 的，因此将调用父类 AuthenticatingFilter 的 executeLogin() 方法。
protected boolean executeLogin(ServletRequest request, ServletResponse response) throws Exception &#123;    AuthenticationToken token = createToken(request, response);    if (token == null) &#123;        String msg = &quot;createToken method implementation returned null. A valid non-null AuthenticationToken &quot; +            &quot;must be created in order to execute a login attempt.&quot;;        throw new IllegalStateException(msg);    &#125;    try &#123;        Subject subject = getSubject(request, response);        subject.login(token);        return onLoginSuccess(token, subject, request, response);    &#125; catch (AuthenticationException e) &#123;        return onLoginFailure(token, e, request, response);    &#125;&#125;
createToken()，该方法又是 BasicHttpAuthenticationFilter 来实现的，其实也就是从 Authorization 的 Request Header 提取base64 编码的用户名和密码，然后解析，最终会实例化 UsernamePasswordToken。
protected AuthenticationToken createToken(ServletRequest request, ServletResponse response) &#123;    String authorizationHeader = getAuthzHeader(request);    if (authorizationHeader == null || authorizationHeader.length() == 0) &#123;        // Create an empty authentication token since there is no        // Authorization header.        return createToken(&quot;&quot;, &quot;&quot;, request, response);    &#125;    log.debug(&quot;Attempting to execute login with auth header&quot;);    String[] prinCred = getPrincipalsAndCredentials(authorizationHeader, request);    if (prinCred == null || prinCred.length &lt; 2) &#123;        // Create an authentication token with an empty password,        // since one hasn&#x27;t been provided in the request.        String username = prinCred == null || prinCred.length == 0 ? &quot;&quot; : prinCred[0];        return createToken(username, &quot;&quot;, request, response);    &#125;    String username = prinCred[0];    String password = prinCred[1];    return createToken(username, password, request, response);&#125;


在 createToken 之后，会 getSubject，执行 login()。后面会委托给 SecurityManager.login 方法，在 securityManager 中会对 token 进行验证，本质上就是调用 Realm 方法验证，如果验证过程中没有异常抛出，则顺利执行，
​如果认证过程没有异常抛出，最终会走到 onLoginSuccess()，如果有异常抛出则执行 onLoginFailure()。

一般也就是在 Realm 的执行逻辑中抛出异常。

]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro DefaultFilter 使用笔记</title>
    <url>/2022/07/14/Framework/Java/Shiro/Shiro-DefaultFilter-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[Shiro DefaultFilter 使用笔记anonAnonymousFilter
匿名过滤器，请求 onPreHandle() 直接通过。
authcFormAuthenticationFilter
onAccessDenied 方法分 loginUrl 处理和非 loginUrl 处理：(1) 当请求是 loginUrl 时，其中又根据是否为 POST 请求判断是否是 login 页面请求还是，login 提交。(2) 当请求是非 loginUrl 时，向 session 存储了一个属性 shiroSavedRequest， 然后跳转到登录页面。
authcBasicBasicHttpAuthenticationFilter
onAccessDenied 逻辑：

通过请求头 Authorization 判断是否为 login 请求，如果是，执行 executeLogin 逻辑，获取 username, password 构造 AuthenticationToken 进行 Realm 认证。
如果不是 login 请求，或者登录失败，发送质询

invalidRequestInvalidRequestFilter
默认全局过滤器，过滤一些非法请求
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro FilterChainDefinitionMap 注册原理</title>
    <url>/2022/07/14/Framework/Java/Shiro/Shiro-FilterChainDefinitionMap-%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[Shiro FilterChainDefinitionMap 注册原理在进行 FilterChainDefinitionMap 配置的时候，需要准备两个字符串，分别称之为 antPath 和 definition。以如下的配置为例：
DefaultShiroFilterChainDefinition chainDefinition = new DefaultShiroFilterChainDefinition();chainDefinition.addPathDefinition(&quot;/url&quot;, &quot;authc, roles[admin,user], perms[file:edit]&quot;);


第一个字符串可以认为是路径（可以包含通配符），第二个字符串是过滤器链定义

对于 FilterChainDefinitionMap 中每个 filter Chain Definition 的处理都是在 DefaultFilterChainManager 进行的，主要关注如下方法：
// 此处的 chainName 就是 antPath public void createChain(String chainName, String chainDefinition) &#123;    if (!StringUtils.hasText(chainName)) &#123;        throw new NullPointerException(&quot;chainName cannot be null or empty.&quot;);    &#125;    if (!StringUtils.hasText(chainDefinition)) &#123;        throw new NullPointerException(&quot;chainDefinition cannot be null or empty.&quot;);    &#125;    if (log.isDebugEnabled()) &#123;        log.debug(&quot;Creating chain [&quot; + chainName + &quot;] with global filters &quot; + globalFilterNames + &quot; and from String definition [&quot; + chainDefinition + &quot;]&quot;);    &#125;    // 首先以此添加全局 filter，比如 InvalidRequestFilter    if (!CollectionUtils.isEmpty(globalFilterNames)) &#123;        globalFilterNames.stream().forEach(filterName -&gt; addToChain(chainName, filterName));    &#125;    // 对值进行标记解析，以获得最后特定于过滤器的配置项    // 这里以半角逗号(,) 作为分隔符，忽略两边空白符    // 例如对于值：    //     &quot;authc, roles[admin,user], perms[file:edit]&quot;    // 最终的标记数组为：    //     &#123; &quot;authc&quot;, &quot;roles[admin,user]&quot;, &quot;perms[file:edit]&quot; &#125;    //    String[] filterTokens = splitChainDefinition(chainDefinition);    // 每个标记都是特定于每个过滤器的    // 即，这些配置可能是过滤器约定好的，你需要熟悉这些用法    // 譬如 roles[admin,user] 括号 [] 之间代表着角色    //      perms[file:edit] 括号 [] 之间代表权限，权限又用 : 隔开，前者表示操作对象，后者表示操作类型    // 剥离 name，提取括号 [] 之间的特定于过滤器的配置    for (String token : filterTokens) &#123;        // 一定是一个包含 2 个元素的数组，第一个是 filter name，第二个 config 可能是 null        // [ &quot;authc&quot;, null ]        // [ &quot;roles&quot;, &quot;admin,user&quot; ]        // [ &quot;perms&quot;, &quot;file:edit&quot; ]        String[] nameConfigPair = toNameConfigPair(token);        // 现在，我们拥有过滤器名称，路径，以及特定于路径的配置（可能是 null，也就是没有配置）        addToChain(chainName, nameConfigPair[0], nameConfigPair[1]);    &#125;&#125;


public void addToChain(String chainName, String filterName, String chainSpecificFilterConfig) &#123;    if (!StringUtils.hasText(chainName)) &#123;        throw new IllegalArgumentException(&quot;chainName cannot be null or empty.&quot;);    &#125;    Filter filter = getFilter(filterName);    if (filter == null) &#123;        throw new IllegalArgumentException(&quot;There is no filter with name &#x27;&quot; + filterName +                &quot;&#x27; to apply to chain [&quot; + chainName + &quot;] in the pool of available Filters.  Ensure a &quot; +                &quot;filter with that name/path has first been registered with the addFilter method(s).&quot;);    &#125;    // 这里主要就是把配置字符串，如：admin,user 按照半角逗号（,）分割    // 将得到的 chainName 和 [admin, user] 放入过滤器中  Map&lt;String, Object&gt; appliedPaths 结构中    // 之所以这样做，是因为对于不同的路径，可能会配置同一个过滤器的不同过滤规则    // 比如： 学校列表学校管理员与区级管理员可访问，区列表仅区级管理员访问    //      /school/list  roles[school_admin, area_admin]    //      /area/list    roles[area_admin]    applyChainConfig(chainName, filter, chainSpecificFilterConfig);    // ensureChain 顾名思义，表示确保 chain 存在，如果不存在就新建一个    NamedFilterList chain = ensureChain(chainName);    chain.add(filter);&#125;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro Subject login 流程分析</title>
    <url>/2022/07/14/Framework/Java/Shiro/Shiro-Subject-login-%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[Subject login 流程分析通常，在执行登录之前，我们必须拥有一个 Subject 对象，可能是从 SecurityUtils 类中获取：
Subject subject = SecurityUtils.getSubject();

Shiro 框架中 Subject 实现类 DelegatingSubject，顾名思义，委托中的 Subject，该类本身不做 login 操作，而是将 login 操作委托给 SecurityManager
Subject.login() 的方法声明如下，需要传入一个 AuthenticationToken：
void login(AuthenticationToken token) throws AuthenticationException;

具体实现代码如下：
public void login(AuthenticationToken token) throws AuthenticationException &#123;    clearRunAsIdentitiesInternal();    // 委托给 SecurityManager 执行    Subject subject = securityManager.login(this, token);    PrincipalCollection principals;    String host = null;    if (subject instanceof DelegatingSubject) &#123;        DelegatingSubject delegating = (DelegatingSubject) subject;        //we have to do this in case there are assumed identities - we don&#x27;t want to lose the &#x27;real&#x27; principals:        principals = delegating.principals;        host = delegating.host;    &#125; else &#123;        principals = subject.getPrincipals();    &#125;    if (principals == null || principals.isEmpty()) &#123;        String msg = &quot;Principals returned from securityManager.login( token ) returned a null or &quot; +                &quot;empty value.  This value must be non null and populated with one or more elements.&quot;;        throw new IllegalStateException(msg);    &#125;    this.principals = principals;    this.authenticated = true;    if (token instanceof HostAuthenticationToken) &#123;        host = ((HostAuthenticationToken) token).getHost();    &#125;    if (host != null) &#123;        this.host = host;    &#125;    Session session = subject.getSession(false);    if (session != null) &#123;        this.session = decorate(session);    &#125; else &#123;        this.session = null;    &#125;&#125;

DefaultSecurityManager 的 login 方法如下，其中 authenticate 是执行认证的关键方法：
public Subject login(Subject subject, AuthenticationToken token) throws AuthenticationException &#123;    AuthenticationInfo info;    try &#123;        info = authenticate(token);    &#125; catch (AuthenticationException ae) &#123;        try &#123;            onFailedLogin(token, ae, subject);        &#125; catch (Exception e) &#123;            if (log.isInfoEnabled()) &#123;                log.info(&quot;onFailedLogin method threw an &quot; +                        &quot;exception.  Logging and propagating original AuthenticationException.&quot;, e);            &#125;        &#125;        throw ae; //propagate    &#125;    Subject loggedIn = createSubject(token, info, subject);    onSuccessfulLogin(token, info, loggedIn);    return loggedIn;&#125;

SecurityManager 将认证的方法委托给了内部认证器 Authenticator：
public AuthenticationInfo authenticate(AuthenticationToken token) throws AuthenticationException &#123;    return this.authenticator.authenticate(token);&#125;

AbstractAuthenticator 认证方法 authenticate() 代码如下，其中 doAuthenticate() 是认证的关键方法：
public final AuthenticationInfo authenticate(AuthenticationToken token) throws AuthenticationException &#123;    if (token == null) &#123;        throw new IllegalArgumentException(&quot;Method argument (authentication token) cannot be null.&quot;);    &#125;    log.trace(&quot;Authentication attempt received for token [&#123;&#125;]&quot;, token);    AuthenticationInfo info;    try &#123;        info = doAuthenticate(token);        if (info == null) &#123;            String msg = &quot;No account information found for authentication token [&quot; + token + &quot;] by this &quot; +                    &quot;Authenticator instance.  Please check that it is configured correctly.&quot;;            throw new AuthenticationException(msg);        &#125;    &#125; catch (Throwable t) &#123;        AuthenticationException ae = null;        if (t instanceof AuthenticationException) &#123;            ae = (AuthenticationException) t;        &#125;        if (ae == null) &#123;            //Exception thrown was not an expected AuthenticationException.  Therefore it is probably a little more            //severe or unexpected.  So, wrap in an AuthenticationException, log to warn, and propagate:            String msg = &quot;Authentication failed for token submission [&quot; + token + &quot;].  Possible unexpected &quot; +                    &quot;error? (Typical or expected login exceptions should extend from AuthenticationException).&quot;;            ae = new AuthenticationException(msg, t);            if (log.isWarnEnabled())                log.warn(msg, t);        &#125;        try &#123;            notifyFailure(token, ae);        &#125; catch (Throwable t2) &#123;            if (log.isWarnEnabled()) &#123;                String msg = &quot;Unable to send notification for failed authentication attempt - listener error?.  &quot; +                        &quot;Please check your AuthenticationListener implementation(s).  Logging sending exception &quot; +                        &quot;and propagating original AuthenticationException instead...&quot;;                log.warn(msg, t2);            &#125;        &#125;        throw ae;    &#125;    log.debug(&quot;Authentication successful for token [&#123;&#125;].  Returned account [&#123;&#125;]&quot;, token, info);    notifySuccess(token, info);    return info;&#125;

通常，我们可以认为 Shiro 框架中的认证器就是 ModularRealmAuthenticator，因为没有其他实现类了，其 doAuthenticate() 方法如下：
protected AuthenticationInfo doAuthenticate(AuthenticationToken authenticationToken) throws AuthenticationException &#123;    assertRealmsConfigured();    Collection&lt;Realm&gt; realms = getRealms();    if (realms.size() == 1) &#123;        // 只有 1 个 Realm        return doSingleRealmAuthentication(realms.iterator().next(), authenticationToken);    &#125; else &#123;        // 具有多个 Realm        return doMultiRealmAuthentication(realms, authenticationToken);    &#125;&#125;


如果配置了多个 Realm，会使用到认证策略 AuthenticationStrategy，认证策略也有很多种，其中的 AllSuccessfulStrategy 要求所有的 Realm 都必须认证成功，并且会合并所有的 AuthenticationInfo 中的 PrincipalCollection 形成 MutablePrincipalCollection，凭证 credential 也会合并为集合。

]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro 架构</title>
    <url>/2022/07/24/Framework/Java/Shiro/Shiro-%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[Shiro 架构Apache Shiro 架构Apache Shiro 的设计目的就是，通过直观化且易于使用来简化应用程序安全性。Shiro 的核心设计模型化了大多数人考虑应用安全性的方式 —— 在某人（或某物）与应用程序交互的上下文中。
软件应用通常基于用户故事设计的。即，你通常会根据用户将会（或者应该）如何与软件交互来设计用户接口或者服务 API。例如，你可能会说，”如果与我的软件交互的用户已经登陆了，我将向他们展示一个按钮，他们可以点机查看其账户信息。如果他们未登录，我将显示一个注册按钮”。
该实例语句标识，应用程序主要是为了满足用户需求和需要而大量编写的。即使“用户”是另一个软件系统，不是一个人类，你仍然可以编码，根据谁（或者什么东西）目前正在与你的软件进行交互反映行为。
高级概述


Subject: 正如我们在教程中提及的，Subject 本质上是当前正在执行用户的安全性特定“视图”。尽管词语“用户”通常表示一个人，但是 Subject 可以是一个人，但它也可以表示第三方服务，守护账户，cron 作业，或者任何类似的东西 —— 基本任何当前与软件交互的东西。

Subject 实例都会绑定到（且需要）一个 SecurityManager。当你和一个 Subject 交互时，这些交互会转换为特定于 subject 的与 SecurityManager 的交互。

SecurityManager: SecurityManager 是 Shiro 架构的核心。它主要是一个 “伞” 对象，可以协调其管理的组件，确保他们能顺序运行。

我们将在稍后详细讨论 SecurityManager，但是重要的是要意识到，当你与 Subject 进行互动时，实际上，幕后的 SecurityManager 为任何 Subject 安全操作做了所有繁重的工作。这反映在上面的基本流程图中。

Realms: Realm 充当 Shiro 与你应用程序安全性数据之间的“桥梁”或者连接器。

从这个意义上讲，一个 Realm 本质上是一种特定于安全性的 DAO: 它封装了数据源的连接细节，并使得 Shiro 在需要时获得相关数据。当配置 Shiro 时，你必须至少指定一个用于认证以及（或者）授权的 Realm。SecurityManager 可以配置多个 Realm，但至少需要配置一个。
详细架构

Subject (org.apache.shiro.subject.Subject) 当前正在与软件交互的，特定安全的实体视图（用户，第三方服务，cron 任务等）
SecurityManager (org.apache.shiro.mgt.SecurityManager) 如上所述，SecurityManager 是 Shiro 架构的核心。它主要是一个 “伞” 对象，可以协调其管理的组件，确保他们能顺序运行。它还管理每个应用用户的视图，因此它知道每个用户如何执行安全操作。
Authenticator (org.apache.shiro.authc.Authenticator) Authenticator 是负责执行和响应用户的认证（登录）请求的组件。当一个用户尝试登录，Authenticator 就会执行该逻辑。Authenticator 知道如何与一个或多个存储相关用户&#x2F;账户信息的 Realms 协作。用从这些 Realms 获得的数据验证用户身份，保证用户的确如他们所说。
Authorizer (org.apache.shiro.authz.Authorizer) Authorizer 是负责确定用户在应用程序中访问控制的组件。归根结底地说，这是一种机制，判断是否用户允许做某事。像 Authenticator 一样，Authorizer 也知道如何与多个后端数据源协作，访问角色和权限信息。Authorizer 使用这些信息，确定是否用户允许执行给定的操作。
SessionManager (org.apache.shiro.session.mgt.SessionManager) SessionManager  知道如何创建和管理用户 Session 生命周期，为所有环境中的用户提供强大的会话体验。这是安全框架的世界独有的功能，Shiro 有能力本地化地管理任何环境下的用户会话，即使没有可用的 Web&#x2F;Servlet 或者 EJB 容器。默认情况下，Shiro 将使用现有的会话机制，如果可用，（例如 Servlet Container），但是如果没有，例如在一个独立应用或者非 Web 环境下，将使用其内建的企业会话管理，提供相同的编程体验。SessionDAO 允许使用任何数据源持久化 Session。
CacheManager (org.apache.shiro.cache.CacheManager)
Cryptography (org.apache.shiro.crypto.*) 
Realms (org.apache.shiro.realm.Realm) 如上所述，Realms 充当 Shiro 和应用安全数据之间的 “桥梁” 或者 “连接器”。当实际需要与安全相关数据（就像用户账户）进行交互，执行认证（login）以及授权（访问控制）的时候，Shiro 会从一个或多个为应用配置的 Realms 中查找许多相关的数据。你可以根据需要配置尽可能多的 Realms（通常每个数据源配一个），Shiro 在认证和授权的时候，根据需要协调它们。

Apache Shiro Web SupportDefault FiltersSession ManagementServlet Container Sessions在 Web 环境下，Shiro 的默认会话管理器 SessionManager 的实现是 ServletContainerSessionManager。这是一个非常简易的实现，将所有会话管理的职责（包括会话集群，如果 Servlet 容器支持）委托给运行时的 Servlet 容器。它本质上是 Shiro 会话 API 到 Servlet 容器的桥梁，几乎没做什么。
Native Sessions如果你希望会话配置设置以及集群可以在 Servlet 容器上移植，或者你想控制特定的会话&#x2F;集群功能，你可以启用 Shiro 的本地会话管理。
这里 “Native” 一词意味着，将会使用 Shiro 自己的企业会话管理实现，支持所有 Subject 以及 HttpServletRequest 会话，并完全绕过 Servlet 容器。但是，请放心，Shiro 直接实现了相关的 Servlet 规范部分，因此任何现有的 web&#x2F;http 相关代码都可以按照预期工作，并且也不需要知道 Shiro 正在透明地管理会话。
DefaultWebSessionManager]]></content>
  </entry>
  <entry>
    <title>ShiroFilter 执行流程</title>
    <url>/2022/07/23/Framework/Java/Shiro/ShiroFilter%20%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[ShiroFilter 执行流程SpringShiroFilterSpringShiroFilter 是 Shiro 整合 Spring Web 提供的一个 Filter，通过将其配置到 Servlet 容器的过滤器链中参与处理。

包装 Request 和 Response，使它们由原来的 HttpServlet 系列包装（装饰）为 ShiroHttpServletRequest


装饰器设计模式，扩展了一些功能


创建 Subject，传递给接下来的过滤器（通过 ThreadLocal）；

如果没有定义任何 FilterChainDefinitionMap，那 Shiro 也会把 Request 交给它默认的过滤器过滤。

寻找合适的 FilterChain，如果找到则转交给该 FilterChain 过滤

更新 SessionLastAccessTime（native sessions）


以下是 SpringShiroFilter 的代码清单：
protected void doFilterInternal(ServletRequest servletRequest, ServletResponse servletResponse, final FilterChain chain)        throws ServletException, IOException &#123;    Throwable t = null;    try &#123;        // 装饰原生 request response        final ServletRequest request = prepareServletRequest(servletRequest, servletResponse, chain);        final ServletResponse response = prepareServletResponse(request, servletResponse, chain);        final Subject subject = createSubject(request, response);        //noinspection unchecked        // 通过 Callable 进行增强，底层会将 subject、securityManager 都存到 ThreadLocal        subject.execute(new Callable() &#123;            public Object call() throws Exception &#123;                // 更新 session last access time                updateSessionLastAccessTime(request, response);                // 执行链                executeChain(request, response, chain);                return null;            &#125;        &#125;);    &#125; catch (ExecutionException ex) &#123;        t = ex.getCause();    &#125; catch (Throwable throwable) &#123;        t = throwable;    &#125;    if (t != null) &#123;        if (t instanceof ServletException) &#123;            throw (ServletException) t;        &#125;        if (t instanceof IOException) &#123;            throw (IOException) t;        &#125;        //otherwise it&#x27;s not one of the two exceptions expected by the filter method signature - wrap it in one:        String msg = &quot;Filtered request failed.&quot;;        throw new ServletException(msg, t);    &#125;&#125;


从上述代码可以看到，subject 对象并不是直接调用相关的方法，而是通过向 execute 方法传递一个 Callable，该 Callable 实际会被 Shiro 的 SubjectCallable 包装起来，可以认为是一种装饰器模式。SubjectCallable 调用如下：
public V call() throws Exception &#123;    try &#123;        // threadState 实际上是 SubjectThreadState        // bind 方法底层会将 subject, securityManager 都绑定到一个 Map 的 ThreadLocal        threadState.bind();        // 实际调用被装饰的 callable        return doCall(this.callable);    &#125; finally &#123;        threadState.restore();    &#125;&#125;protected V doCall(Callable&lt;V&gt; target) throws Exception &#123;    return target.call();&#125;

Subject 执行 executeChain 的代码清单如下：
protected void executeChain(ServletRequest request, ServletResponse response, FilterChain origChain) throws IOException, ServletException &#123;    // 寻找合适的 FilterChain    // 可能是 Tomcat 原生（未找到），也可能是 Shiro 自己链    FilterChain chain = getExecutionChain(request, response, origChain);    chain.doFilter(request, response);&#125;

以下是通过 requestURI 获取 FilterChain 的方法：
public FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain) &#123;    FilterChainManager filterChainManager = getFilterChainManager();    if (!filterChainManager.hasChains()) &#123;        return null;    &#125;    final String requestURI = getPathWithinApplication(request);    final String requestURINoTrailingSlash = removeTrailingSlash(requestURI);    //the &#x27;chain names&#x27; in this implementation are actually path patterns defined by the user.  We just use them    //as the chain name for the FilterChainManager&#x27;s requirements    for (String pathPattern : filterChainManager.getChainNames()) &#123;        // If the path does match, then pass on to the subclass implementation for specific checks:        if (pathMatches(pathPattern, requestURI)) &#123;            if (log.isTraceEnabled()) &#123;                log.trace(&quot;Matched path pattern [&#123;&#125;] for requestURI [&#123;&#125;].  &quot; +                        &quot;Utilizing corresponding filter chain...&quot;, pathPattern, Encode.forHtml(requestURI));            &#125;            return filterChainManager.proxy(originalChain, pathPattern);        &#125; else &#123;            // in spring web, the requestURI &quot;/resource/menus&quot; ---- &quot;resource/menus/&quot; bose can access the resource            // but the pathPattern match &quot;/resource/menus&quot; can not match &quot;resource/menus/&quot;            // user can use requestURI + &quot;/&quot; to simply bypassed chain filter, to bypassed shiro protect            // 在 Spring Web 中，requestURI &quot;/resource/menus&quot; ---- &quot;resource/menus/&quot; 都可以访问资源            // 但是 pathPattern 匹配 &quot;/resource/menus&quot; 不能匹配 &quot;resource/menus/&quot;            // 用户可能使用 requestURI + &quot;/&quot; 来简单跳过 chain filter，以避开 shiro 的保护            // 因此，这里去除了末尾的 &quot;/&quot;            pathPattern = removeTrailingSlash(pathPattern);            // 逻辑类似上面            if (pathMatches(pathPattern, requestURINoTrailingSlash)) &#123;                if (log.isTraceEnabled()) &#123;                    log.trace(&quot;Matched path pattern [&#123;&#125;] for requestURI [&#123;&#125;].  &quot; +                                &quot;Utilizing corresponding filter chain...&quot;, pathPattern, Encode.forHtml(requestURINoTrailingSlash));                &#125;                return filterChainManager.proxy(originalChain, pathPattern);            &#125;        &#125;    &#125;    return null;&#125;]]></content>
  </entry>
  <entry>
    <title>Spring Boot DataSource 选择策略</title>
    <url>/2022/11/29/Framework/Java/Spring-Boot/Spring-Boot-DataSource-%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[0. 参考引用https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-connect-to-production-database
选择算法
我们更喜欢 HikariCP 的性能和并发。如果 HikariCP 可用，我们始终会选择它
否则，如果 Tomcat 池化 DataSource 可用，我们将使用它
如果 HikariCP 和 Tomcat 池化数据源都不可用，并且 Commons DBCP2 可用，我们会使用它

没有找到任何数据源，则抛出异常
请打开 DataSourceAutoConfiguration 类的定义，这是一个自动配置类，其中会尝试自动注入池化 DataSource:
@Configuration(proxyBeanMethods = false)@Conditional(PooledDataSourceCondition.class)@ConditionalOnMissingBean(&#123; DataSource.class, XADataSource.class &#125;)@Import(&#123; DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,        DataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.Generic.class,        DataSourceJmxConfiguration.class &#125;)protected static class PooledDataSourceConfiguration &#123;&#125;


Hikari
@Configuration(proxyBeanMethods = false)@ConditionalOnClass(HikariDataSource.class)@ConditionalOnMissingBean(DataSource.class)@ConditionalOnProperty(    name = &quot;spring.datasource.type&quot;,    havingValue = &quot;com.zaxxer.hikari.HikariDataSource&quot;,    matchIfMissing = true)static class Hikari &#123;    @Bean    @ConfigurationProperties(prefix = &quot;spring.datasource.hikari&quot;)    HikariDataSource dataSource(DataSourceProperties properties) &#123;        HikariDataSource dataSource = createDataSource(properties, HikariDataSource.class);        if (StringUtils.hasText(properties.getName())) &#123;            dataSource.setPoolName(properties.getName());        &#125;        return dataSource;    &#125;&#125;

Tomcat JDBC Pool DataSource
@Configuration(proxyBeanMethods = false)@ConditionalOnClass(org.apache.tomcat.jdbc.pool.DataSource.class)@ConditionalOnMissingBean(DataSource.class)@ConditionalOnProperty(name = &quot;spring.datasource.type&quot;, havingValue = &quot;org.apache.tomcat.jdbc.pool.DataSource&quot;,        matchIfMissing = true)static class Tomcat &#123;    @Bean    @ConfigurationProperties(prefix = &quot;spring.datasource.tomcat&quot;)    org.apache.tomcat.jdbc.pool.DataSource dataSource(DataSourceProperties properties) &#123;        org.apache.tomcat.jdbc.pool.DataSource dataSource = createDataSource(properties,                org.apache.tomcat.jdbc.pool.DataSource.class);        DatabaseDriver databaseDriver = DatabaseDriver.fromJdbcUrl(properties.determineUrl());        String validationQuery = databaseDriver.getValidationQuery();        if (validationQuery != null) &#123;            dataSource.setTestOnBorrow(true);            dataSource.setValidationQuery(validationQuery);        &#125;        return dataSource;    &#125;&#125;


Dbcp2
@Configuration(proxyBeanMethods = false)@ConditionalOnClass(org.apache.commons.dbcp2.BasicDataSource.class)@ConditionalOnMissingBean(DataSource.class)@ConditionalOnProperty(    name = &quot;spring.datasource.type&quot;,    havingValue = &quot;org.apache.commons.dbcp2.BasicDataSource&quot;,    matchIfMissing = true)static class Dbcp2 &#123;    @Bean    @ConfigurationProperties(prefix = &quot;spring.datasource.dbcp2&quot;)    org.apache.commons.dbcp2.BasicDataSource dataSource(DataSourceProperties properties) &#123;        return createDataSource(properties, org.apache.commons.dbcp2.BasicDataSource.class);    &#125;&#125;


@Configuration(proxyBeanMethods = false)@ConditionalOnMissingBean(DataSource.class)@ConditionalOnProperty(name = &quot;spring.datasource.type&quot;)static class Generic &#123;    @Bean    DataSource dataSource(DataSourceProperties properties) &#123;        return properties.initializeDataSourceBuilder().build();    &#125;&#125;]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 启动流程</title>
    <url>/2022/07/24/Framework/Java/Spring-Boot/Spring-Boot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[Spring Boot 启动流程Spring Boot 入口一般会使用静态方法，也可以自己 new 一个 SpringApplication，或者使用 Buidler 定制化。
@SpringBootApplicationpublic class StartupApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(StartupApplication.class, args);    &#125;&#125;


SpringApplication 构造器:
public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;    // 资源加载器，默认 null    this.resourceLoader = resourceLoader;    Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);    // 主要资源类，Set 去重    this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));    // 推断 Web 环境，底层通过 classpath 是否包含特定类检测，NONE, SERVLET, REACTIVE    this.webApplicationType = WebApplicationType.deduceFromClasspath();    // 设置应用上下文初始化器 （从 META-INF/spring.factories）    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));    // 设置监听器 （从 META-INF/spring.factories）    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));    // 推断主应用类，通过 stackTrace    this.mainApplicationClass = deduceMainApplicationClass();&#125;


上面之所以要加载 ApplicationListener 保存到 SpringApplication，是因为下面要传递给 ApplicationEventMulticaster。SpringApplication 作为 EventPublishingRunListener 参数传入。

SpringApplication 运行方法：
public ConfigurableApplicationContext run(String... args) &#123;    // 1. 创建一个秒表，并启动    StopWatch stopWatch = new StopWatch();    stopWatch.start();    ConfigurableApplicationContext context = null;    // 设置系统属性 java.awt.headless    configureHeadlessProperty();    // 创建所有 SpringApplicationRunListener（EventPublishingRunListener）    // 将所有 SpringApplicationRunListener 封装到 SpringApplicationRunListeners    // 底层会读取 spring.factories 的 org.springframework.boot.SpringApplicationRunListener    SpringApplicationRunListeners listeners = getRunListeners(args);    // 立即发布 ApplicationStartingEvent 应用启动事件    listeners.starting();    try &#123;        // 初始化默认应用参数类        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);        // 根据 SpringApplicationRunListener 和应用参数准备 spring Environment        // 发布 ApplicationEnvironmentPreparedEvent 事件        ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);        // 将要忽略的 bean 的参数打开        configureIgnoreBeanInfo(environment);        // 创建 Banner 打印类        Banner printedBanner = printBanner(environment);        // 创建应用上下文（借助构造器推断的 webApplicationType 选择类）        context = createApplicationContext();        // 准备上下文        prepareContext(context, environment, listeners, applicationArguments, printedBanner);        // 刷新        refreshContext(context);        // 后置处理        afterRefresh(context, applicationArguments);        // 停止秒表        stopWatch.stop();        if (this.logStartupInfo) &#123;            new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);        &#125;        // 发布应用上下文启动完毕事件 ApplicationStartedEvent        listeners.started(context);        // 执行所有的 Runner        callRunners(context, applicationArguments);    &#125;    catch (Throwable ex) &#123;        handleRunFailure(context, ex, listeners);        throw new IllegalStateException(ex);    &#125;    try &#123;        // 发布 ApplicationReadyEvent 事件        listeners.running(context);    &#125;    catch (Throwable ex) &#123;        handleRunFailure(context, ex, null);        throw new IllegalStateException(ex);    &#125;    return context;&#125;

StopWatch计时器&#x2F;秒表
StopWatch stopWatch = new StopWatch();stopWatch.start();


configureHeadlessProperty设置属性 java.awt.headless，如果不存在默认值设置为 true
private void configureHeadlessProperty() &#123;    System.setProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS,            System.getProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, Boolean.toString(this.headless)));&#125;

getRunListeners该方法返回一个 SpringApplicationRunListeners 实例，注意末尾有一个 “s”。
// SpringApplicationprivate SpringApplicationRunListeners getRunListeners(String[] args) &#123;    Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;    // 传入的 this 参数就是 SpringApplication    return new SpringApplicationRunListeners(logger,            getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));&#125;


照应前面所说，之所以将 SpringApplication 传入，作为后续的构造器参数，是因为后面需要往 ApplicationEventMulticaster 加入 ApplicationListener，而 ApplicationListener 已经在 SpringApplication 的构造器加载完毕

private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) &#123;    ClassLoader classLoader = getClassLoader();    // Use names and ensure unique to protect against duplicates    Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));    List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);    AnnotationAwareOrderComparator.sort(instances);    return instances;&#125;
一般情况下，只有 spring-boot 下面的 spring.factories 配置了一个 EventPublishingRunListener，其构造器如下：
public EventPublishingRunListener(SpringApplication application, String[] args) &#123;    this.application = application;    this.args = args;    // 事件多播器    this.initialMulticaster = new SimpleApplicationEventMulticaster();    // 获得所有发现的 ApplicationListener    for (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123;        // 添加到事件多播器        this.initialMulticaster.addApplicationListener(listener);    &#125;&#125;


listeners.starting()在获得了 SpringApplicationRunListeners 之后立即发布一个事件，告诉所有 ApplicationListener 容器正在启动。
通常这里只有 1 个 listeners，即 EventPublishingRunListener。
void starting() &#123;    for (SpringApplicationRunListener listener : this.listeners) &#123;        listener.starting();    &#125;&#125;

EventPublishingRunListener 底层调用内部的 Multicaster 进行广播。
public void starting() &#123;    // 构造一个事件广播    this.initialMulticaster.multicastEvent(new ApplicationStartingEvent(this.application, this.args));&#125;

public void multicastEvent(ApplicationEvent event) &#123;    // 调用 resolveDefaultEventType，解析得到 ResolvableType    multicastEvent(event, resolveDefaultEventType(event));&#125;

public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) &#123;    ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));    Executor executor = getTaskExecutor();    for (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;        if (executor != null) &#123;            executor.execute(() -&gt; invokeListener(listener, event));        &#125;        else &#123;            invokeListener(listener, event);        &#125;    &#125;&#125;

获得关心该事件的 ApplicationListener
protected Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners(ApplicationEvent event, ResolvableType eventType) &#123;    // 获得 event 中的 source，一般为 SpringApplication    Object source = event.getSource();    Class&lt;?&gt; sourceType = (source != null ? source.getClass() : null);    // 获得 key    ListenerCacheKey cacheKey = new ListenerCacheKey(eventType, sourceType);    // Potential new retriever to populate    // retriever 检索器    CachedListenerRetriever newRetriever = null;    // Quick check for existing entry on ConcurrentHashMap    CachedListenerRetriever existingRetriever = this.retrieverCache.get(cacheKey);    if (existingRetriever == null) &#123;        // Caching a new ListenerRetriever if possible        if (this.beanClassLoader == null ||                (ClassUtils.isCacheSafe(event.getClass(), this.beanClassLoader) &amp;&amp;                        (sourceType == null || ClassUtils.isCacheSafe(sourceType, this.beanClassLoader)))) &#123;            newRetriever = new CachedListenerRetriever();            // 用新的覆盖            existingRetriever = this.retrieverCache.putIfAbsent(cacheKey, newRetriever);            if (existingRetriever != null) &#123;                newRetriever = null;  // no need to populate it in retrieveApplicationListeners            &#125;        &#125;    &#125;    if (existingRetriever != null) &#123;        Collection&lt;ApplicationListener&lt;?&gt;&gt; result = existingRetriever.getApplicationListeners();        if (result != null) &#123;            return result;        &#125;        // If result is null, the existing retriever is not fully populated yet by another thread.        // Proceed like caching wasn&#x27;t possible for this current local attempt.    &#125;    return retrieveApplicationListeners(eventType, sourceType, newRetriever);&#125;

默认情况下，这里会根据 Starting 事件匹配到 4 个：

LoggingApplicationListener
BackgroundPreinitializer
DelegatingApplicationListener
LiquibaseServiceLocatorApplicationListener

prepareEnvironment准备环境。也会发布事件
private ConfigurableEnvironment prepareEnvironment(        SpringApplicationRunListeners listeners,        ApplicationArguments applicationArguments) &#123;    // Create and configure the environment    // 根据 webApplicationType 实例化 Environment，注意其间不断调用父类默认构造器    ConfigurableEnvironment environment = getOrCreateEnvironment();    // 配置环境，设置 ConversionService；添加命令行    configureEnvironment(environment, applicationArguments.getSourceArgs());    ConfigurationPropertySources.attach(environment);    // 发布事件    listeners.environmentPrepared(environment);    bindToSpringApplication(environment);    if (!this.isCustomEnvironment) &#123;        environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment,                deduceEnvironmentClass());    &#125;    ConfigurationPropertySources.attach(environment);    return environment;&#125;


补充一下 StandardServletEnvironment 构造器做了什么:
// AbstractEnvironmentpublic AbstractEnvironment() &#123;    // customizePropertySources 是一个空实现    // 这里传入了 this 属性，但可以不传?    customizePropertySources(this.propertySources);&#125;

以下是 StandardServletEnvironment 对于 customizePropertySources 的覆盖（定制化）：
// StandardServletEnvironmentprotected void customizePropertySources(MutablePropertySources propertySources) &#123;    // 添加 servletConfigInitParams    propertySources.addLast(new StubPropertySource(SERVLET_CONFIG_PROPERTY_SOURCE_NAME));    // 添加 servletContextInitParams    propertySources.addLast(new StubPropertySource(SERVLET_CONTEXT_PROPERTY_SOURCE_NAME));    if (JndiLocatorDelegate.isDefaultJndiEnvironmentAvailable()) &#123;        propertySources.addLast(new JndiPropertySource(JNDI_PROPERTY_SOURCE_NAME));    &#125;    // 注意，这里也调用了父类 StandardEnvironement 的方法    super.customizePropertySources(propertySources);&#125;

以下是 StandardEnvironement 关于 customizePropertySources 方法的覆盖（定制化）: 
// StandardEnvironementprotected void customizePropertySources(MutablePropertySources propertySources) &#123;    // 添加系统属性    propertySources.addLast(            new PropertiesPropertySource(SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties()));    // 添加环境变量    propertySources.addLast(            new SystemEnvironmentPropertySource(SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));&#125;

prepareContextprivate void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment,        SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) &#123;    context.setEnvironment(environment);    postProcessApplicationContext(context);    applyInitializers(context);    listeners.contextPrepared(context);    if (this.logStartupInfo) &#123;        logStartupInfo(context.getParent() == null);        logStartupProfileInfo(context);    &#125;    // Add boot specific singleton beans    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();    beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments);    if (printedBanner != null) &#123;        beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner);    &#125;    if (beanFactory instanceof DefaultListableBeanFactory) &#123;        ((DefaultListableBeanFactory) beanFactory)                .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);    &#125;    if (this.lazyInitialization) &#123;        context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());    &#125;    // Load the sources    // 加载资源，包括启动类    Set&lt;Object&gt; sources = getAllSources();    Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);    load(context, sources.toArray(new Object[0]));    listeners.contextLoaded(context);&#125;]]></content>
  </entry>
  <entry>
    <title>Eureka 配置实践</title>
    <url>/2022/07/12/Framework/Java/Spring-Cloud/Eureka-%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[Eureka Server如何使用？确保引入 maven 依赖
&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;


ConfigEureka 的 Server 配置没有特别好的文档，官网的指引也只是让你看源代码注释。
Eureka Instance Config
Instance IdString getInstanceId();

获得该实例注册到 eureka 的唯一 ID（在 appName 范围内）

App NameString getAppname();

获得注册到 eureka 的应用名称

lease renewal interval in seconds

getLeaseRenewalIntervalInSeconds()

字面意思：租约续期间隔。
表示 eureka 客户端多久发送心跳给 eureka server，告诉它自己还活着。如果心跳在 getLeaseExpirationDurationInSeconds() 指定的期间还未收到，eureka server 就会从它的视图中移除该实例，从而禁用了该实例的流量。

该参数只是用于 Eureka Client 发送心跳间隔。需要确保与 Eureka Server 的 getLeaseExpirationDurationInSeconds() 参数值一致，否则 Eureka Server 无法正常工作。


lease expiration duration in seconds

表示 Eureka Server 自收到某个实例最后一次心跳，在可以从它的视图中移除该实例从而禁用该实例流量之前，等待的时间，单位：秒。
设置该值太长可能意味着，即使该实例并不存活，也可以将流量路由到该实例。设置该值太小可能意味着，由于临时的网络故障，该实例可能会从流量中剔除。该值设置至少高于 getLeaseRenewalIntervalInSeconds() 指定的值。

如果该值比 getLeaseRenewalIntervalInSeconds() 小，那么实例将无法存活于注册表，即使注册成功，很快就被剔除。

Eureka Server Config
AWS Access Id

String getAWSAccessId();
AWS 云 Access ID

AWS Secret Key

String getAWSSecretKey();
AWS 云 Secret Key

EIPBindRebindRetries
int getEIPBindRebindRetries();

EIPBindingRetryIntervalMsWhenUnbound
int getEIPBindingRetryIntervalMsWhenUnbound();

EIPBindingRetryIntervalMs

enable-self-preservation


boolean shouldEnableSelfPreservation();

是否开启自我保护机制。
启用后，Eureka Server 将跟踪其应该从服务接收到的续约次数。任何时候，续约数量低于 getRenewalPercentThreshold() 定义的阈值百分比，Eureka Server 会关闭过期以避免危险。这有助于在 Eureka Client 与 Eureka Server 之间发生网络问题时维持注册表信息。

注意，自我保护是防止一些网络问题误杀。


eviction-interval-timer-in-ms

清理无效节点的时间间隔。默认值 60000

可以将这个时间设置的短一些，进行快速下线。防止使用不可用的服务。


expected-client-renewalI-interval-seconds

int getExpectedClientRenewalIntervalSeconds();
期望客户端以这个间隔发送它们的心跳。
默认值：30
如果客户端以不同的频率发送心跳，例如每 15 秒发送一次，那么应该相应地调整此参数，否则，自我保护将无法按预期工作。

该参数用于计算内部的阈值。


Response Cache Update Interval Ms

long getResponseCacheUpdateIntervalMs();
获取更新 Eureka Client 负载缓存的时间间隔。

Use Read Only Response Cache

boolean shouldUseReadOnlyResponseCache();

字面意思：是否使用只读响应缓存
com.netflix.eureka.registry.ResponseCache 当前使用两级缓存策略来响应。带有过期策略的独写缓存，以及不会过期的只读缓存。

Renewal Percent Threshold

在由 getRenewalThresholdUpdateIntervalMs() 指定的期间，期望从服务端续期次数的最小百分比。
如果续约降低到阈值以下，并且启用了 shouldEnableSelfPreservation() 则会禁用过期。

getRenewalThresholdUpdateIntervalMs

由 getRenewalPercentThreshold() 指定的阈值，应该更新的间隔。阈值更新间隔

shouldEnableSelfPreservation

检查 eureka server 是否启用了自我保护。
当启用，服务会跟踪它应该从微服务接受到的续约次数。在任何时候，续订次数的数量低于 getRenewalPercentThreshold() 定义的阈值百分比，服务器就会关闭过期以避免危险。这有助于在客户端和服务端之间产生网络问题时服务器维持注册信息。
]]></content>
  </entry>
  <entry>
    <title>Spring Boot Features</title>
    <url>/2022/07/07/Framework/Java/Spring-Boot/Spring-Boot-Features/</url>
    <content><![CDATA[Spring Boot Features1. SpringApplicationSpringApplication 类提供了一种简单的方式来引导 Spring 应用程序从 main 方法中启动。在许多情况下，你可以委托给静态的 SpringApplication.run 方法，就像下面的例子：
public static void main(String[] args) &#123;    SpringApplication.run(MySpringConfiguration.class, args);&#125;

当你的应用启动时，你应该会看到类似的输出：
  .   ____          _            __ _ _ /\\ / ___&#x27;_ __ _ _(_)_ __  __ _ \ \ \ \( ( )\___ | &#x27;_ | &#x27;_| | &#x27;_ \/ _` | \ \ \ \ \\/  ___)| |_)| | | | | || (_| |  ) ) ) )  &#x27;  |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot ::   v2.3.12.RELEASE2019-04-31 13:09:54.117  INFO 56603 --- [           main] o.s.b.s.app.SampleApplication            : Starting SampleApplication v0.1.0 on mycomputer with PID 56603 (/apps/myapp.jar started by pwebb)2019-04-31 13:09:54.166  INFO 56603 --- [           main] ationConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@6e5a8246: startup date [Wed Jul 31 00:08:16 PDT 2013]; root of context hierarchy2019-04-01 13:09:56.912  INFO 41370 --- [           main] .t.TomcatServletWebServerFactory : Server initialized with port: 80802019-04-01 13:09:57.501  INFO 41370 --- [           main] o.s.b.s.app.SampleApplication            : Started SampleApplication in 2.992 seconds (JVM running for 3.658)
1.1. Startup Failure如果你的应用程序未能启动，则注册的 FailureAnalyzers 将有机会提供专用的错误消息以及具体操作来解决该问题。例如，如果你在端口 8080 启动一个 Web 项目，并且该端口已经被占用，你应该能看到类似以下消息的东西：
***************************APPLICATION FAILED TO START***************************Description:Embedded servlet container failed to start. Port 8080 was already in use.Action:Identify and stop the process that&#x27;s listening on port 8080 or configure this application to listen on another port.


Spring Boot 提供了许多 FailureAnalyzer 实现，你可以添加自己的实现。

1.4. Customizing SpringApplication如果 SpringApplication 的默认值不符合你的口味，那么你可以取而代之地创建一个本地实例并自定义它。例如，关闭 banner，你可以这样写：
public static void main(String[] args) &#123;    SpringApplication app = new SpringApplication(MySpringConfiguration.class);    app.setBannerMode(Banner.Mode.OFF);    app.run(args);&#125;


传递给 SpringApplication 地构造器参数是用于 Spring Bean 地配置源。在大多数情况下，这些是 @Configuration 类地引用，但它们也可以引用 XML 配置或者应该扫描的包。

也可以使用 application.properties 文件来配置 SpringApplication。有关详细信息，参见 Externalized Configuration
1.5. Fluent Builder API如果你需要构建 ApplicationContext 层次结构（具有父子关系的多上下文）或者你更喜欢用 “fluent” 构造器 API，你可以使用 SpringApplicationBuilder。
SpringApplicationBuilder 使你可以将多个方法连接在一起，并且包含 parent 和 child 方法，可以让你创建一个层次结构，如下示例所示：
new SpringApplicationBuilder()        .sources(Parent.class)        .child(Application.class)        .bannerMode(Banner.Mode.OFF)        .run(args);

1.7. Application Events and Listeners除了通常的 Spring Framework 事件，例如 ContextRefreshedEvent，一个 SpringApplication 还会发送一些其他应用事件。

实际上，在 ApplicationContext 创建之前一些事件就已经被触发了，因此你无法以 @Bean的方式在上面注册监听器。你可以用 SpringApplication.addListeners(...) 方法或者 SpringApplicationBuilder.listeners(...) 方法注册它们。如果你希望这些监听器自动注册，无论应用程序的创建方式如何，你可以添加一个 META-INF/spring.factories 文件到你的项目中，并通过使用 org.springframework.context.ApplicationListener key 引用你的监听器，如下示例所示：
org.springframework.context.ApplicationListener=com.example.project.MyListener

1.8. Web EnvironmentSpringApplication 试图在你的立场上创建正确的 ApplicationContext 类型。决定一个 WebApplicationType 的算法如下：

如果 Spring MVC 存在，使用 AnnotationConfigServletWebServerApplicationContext
如果 Spring MVC 不存在，Spring WebFlux 存在，使用 AnnotationConfigReactiveWebServerApplicationContext
否则，使用 AnnotationConfigApplicationContext

这意味着，如果你在同一个应用使用 Spring MVC 以及来自 Spring WebFlux 的新 WebClient，默认使用 Spring MVC。你可以通过调用 setWebApplicationType(WebApplicationType) 轻易覆盖这一点。
1.9. Accessing Application Arguments如果你需要访问传递给 SpringApplication.run(...) 的参数，那么你可以注入一个 org.springframework.boot.ApplicationArguments 的 bean。ApplicationArguments 接口提供了对原始 String[] 参数的访问，以及被解析的 option 和 non-option 参数，正如下面这个例子：
import org.springframework.boot.*;import org.springframework.beans.factory.annotation.*;import org.springframework.stereotype.*;@Componentpublic class MyBean &#123;    @Autowired    public MyBean(ApplicationArguments args) &#123;        boolean debug = args.containsOption(&quot;debug&quot;);        List&lt;String&gt; files = args.getNonOptionArgs();        // if run with &quot;--debug logfile.txt&quot; debug=true, files=[&quot;logfile.txt&quot;]    &#125;&#125;
1.11. Application Exit每个 SpringApplication 都会在 JVM 上注册一个关闭钩子，以确保 ApplicationContext 在退出时优雅地关闭。所有标准的 Spring 生命周期回调（例如 DisposableBean 接口或者 @PreDestroy 注解）都可以使用。
此外，如果希望当 SpringApplication.exit() 调用时返回特定的结束码，Bean 可以实现 org.springframework.boot.ExitCodeGenerator 接口。然后可以将此退出码传递给 System.exit()，以一个状态码的形式返回，如下示例所示：
@SpringBootApplicationpublic class ExitCodeApplication &#123;    @Bean    public ExitCodeGenerator exitCodeGenerator() &#123;        return () -&gt; 42;    &#125;    public static void main(String[] args) &#123;        System.exit(SpringApplication.exit(SpringApplication.run(ExitCodeApplication.class, args)));    &#125;&#125;


2. Externalized Configuration2.1. Configuring Random ValuesRandomValuePropertySource 可用于注入随机值（例如，secret 或者测试用例）。它可以产生 integer，long，uuid，或者 string，如下示例所示：
my.secret=$&#123;random.value&#125;my.number=$&#123;random.int&#125;my.bignumber=$&#123;random.long&#125;my.uuid=$&#123;random.uuid&#125;my.number.less.than.ten=$&#123;random.int(10)&#125;my.number.in.range=$&#123;random.int[1024,65536]&#125;

2.3. Application Property FilesSpringApplication 在以下位置的 application.properties 文件中加载属性，并将它们添加到 Spring Environment：

当前目录的一个 /config 子目录
当前文件夹
类路径 /config 包
类路径根

2.7. Using YAML Instead of PropertiesYAML 是 JSON 的超集，因此，也是一种指定层次配置数据的方便格式。SpringApplication 类自动支持 YAML 作为 properties 的替代品，只需要在类路径添加 SnakeYAML 库支持。
如果你使用 “starter”，SnakeYAML 将由 spring-boot-starter 自动提供。
2.7.1. Loading YAMLSpring Framework 提供了两个方便的类，可以用于加载 YAML 文档。YamlPropertiesFactoryBean 将 YAML 加载作为 Properties，而 YamlMapFactoryBean 将 YAML 加载作为 Map。
例如，考虑如下 YAML 文档：
environments:    dev:        url: https://dev.example.com        name: Developer Setup    prod:        url: https://another.example.com        name: My Cool App
前面的示例将转换为以下属性：
environments.dev.url=https://dev.example.comenvironments.dev.name=Developer Setupenvironments.prod.url=https://another.example.comenvironments.prod.name=My Cool App

2.7.4. YAML ShortcomingsYAML 文件不能使用 @PropertySource 注解加载。因此，以这种方式加载值，你需要使用 properties 文件。
在特定 profile 的 YAML 文件中使用多 YAML 文档语法可能导致不可预测的行为。例如，考虑如下文件配置：
server:  port: 8000---spring:  profiles: &quot;!test&quot;  security:    user:      password: &quot;secret&quot;

如果你以参数 --spring.profiles.active=dev 运行应用，你可能期望 security.user.password 设置为 “secret”，但是事实并非如此。
嵌套文档将被过滤，因为主文件名为 application-dev.yml。它已经被认为是特定于配置文件的，并且嵌套的文档将会被忽略。

我们建议你不要将特定 profile 的 YAML 文件和多 YAML 文档混合。坚持使用其一。

2.8. Type-safe Configuration Properties2.8.1. JavaBean properties binding如下示例所示，可以绑定声明标准 JavaBean 属性：
package com.example;import java.net.InetAddress;import java.util.ArrayList;import java.util.Collections;import java.util.List;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(&quot;acme&quot;)public class AcmeProperties &#123;    private boolean enabled;    private InetAddress remoteAddress;    private final Security security = new Security();    public boolean isEnabled() &#123; ... &#125;    public void setEnabled(boolean enabled) &#123; ... &#125;    public InetAddress getRemoteAddress() &#123; ... &#125;    public void setRemoteAddress(InetAddress remoteAddress) &#123; ... &#125;    public Security getSecurity() &#123; ... &#125;    public static class Security &#123;        private String username;        private String password;        private List&lt;String&gt; roles = new ArrayList&lt;&gt;(Collections.singleton(&quot;USER&quot;));        public String getUsername() &#123; ... &#125;        public void setUsername(String username) &#123; ... &#125;        public String getPassword() &#123; ... &#125;        public void setPassword(String password) &#123; ... &#125;        public List&lt;String&gt; getRoles() &#123; ... &#125;        public void setRoles(List&lt;String&gt; roles) &#123; ... &#125;    &#125;&#125;

上面的 POJO 定义了以下属性：

acme.enabled，具有默认值 false
acme.remote-address，具有可以从 String 强转的类型
acme.security.username，具有一个嵌套的 “security” 对象，其名称由属性名决定。特别注意，返回类型这里根本没有使用，有可能是 SecurityProperties
acme.security.password
acme.security.roles 带有默认为 USER 的 String 集合

一般需要提供一个无参构造器，并且 getter 和 setter 是强制地，除了一些情况：

Map，只要被实例化过了，只需要一个 getter 无需 setter
Collection 和 Array，可以使用索引或者逗号分隔来访问。后者需要 setter。始终建议添加 setter。如果自己初始化，确保它是 not immutable
嵌套属性无需 setter。如果希望默认构造器能够创建该嵌套属性地实例，需要 setter。

有人使用 Lombok，确保其不会为属性类生成任何特定地构造函数，因为容器会自动使用它来实例化对象。
只考虑标准 Java Bean，不支持静态属性绑定。
2.8.3. Enabling @ConfigurationProperties-annotated typesSpring Boot 提供了绑定 @ConfigurationProperties 类型并将其注册为 Bean 的基础架构。你可以在一个一个的类上启用配置属性，或者启用配置属性扫描，这以类似于组件扫描的方式工作。
有时候，@ConfigurationProperties 可能不适合总是被扫描。例如，如果你正在开发自己的 auto-configuration，或者你需要有条件的启用它们。在这些情况下，使用 @EnableConfiguratonProperties 注解指定要处理的类列表。这可以在任何 @Configuration 类上完成，如下示例所示：
@Configuration(proxyBeanMethods = false)@EnableConfigurationProperties(AcmeProperties.class)public class MyConfiguration &#123;&#125;

要使用配置属性扫描，请将 @ConfigurationPropertiesScan 注解添加到你的应用。通常，会将其添加到用 @SpringBootApplication 注解的主应用类中，但也可以添加到任何 @Configuration 类。默认情况下，将从声明注解的类所在的包开始扫描。如果你想定义特定的包扫描，你可以像下面示例这样做：
@SpringBootApplication@ConfigurationPropertiesScan(&#123; &quot;com.example.app&quot;, &quot;org.acme.another&quot; &#125;)public class MyApplication &#123;&#125;



当使用配置属性扫描或者 @EnableConfigurationProperties 注册 @ConfigurationProperties bean 时，bean 有一个约定名称：&lt;prefix&gt;-&lt;fqn&gt;，&lt;prefix&gt; 是 @ConfigurationProperties 的 prefix 属性，&lt;fqn&gt; 是 bean 的全限定名。如果注解没有提供任何前缀，则使用 bean 的完全限定名称。

3. ProfilesSpring 配置文件提供了一种方式，可以分离应用配置的一部分，并使其仅在某些环境中可用。任何 @Component，@Configuration，或者 @ConfigurationProperties 都可以用 @Profile 标记以限制何时加载，如下示例所示：
@Configuration(proxyBeanMethods = false)@Profile(&quot;production&quot;)public class ProductionConfiguration &#123;    // ...&#125;

你可以使用 spring.profiles.active Environment 属性来指定哪些配置文件处于激活状态。你可以以本章前面描述的任何方式指定属性。例如，你可以在你的 application.properties 中包含，如下示例所示：
spring.profiles.active=dev,hsqldb

你也可以使用以下开关在命令行上指定：--spring.profiles.active=dev.hsqldb
如果没有配置文件处于激活状态。则启用默认配置文件。默认配置文件的名称为 default，并且可以使用 spring.profiles.default Environment 属性进行调整，如下示例所示：
spring.profiles.default=none

4. LoggingSpring Boot 使用 Commons Logging 用于所有内部的日志记录，但是保持底层的日志实现开放。为 Java Util Logging，Log4J2，以及 Logback 提供了默认配置。在每种情况下，日志记录器是预先配置使用控制台输出，同事可选的文件输出也是可用的。
默认情况下，如果你使用 “starter”，则使用 Logback 进行日志记录。适当的 Logback 路由也会被包括进来，确保使用 Java Util Logging，Commons Logging，Log4J，或者 SLF4J 的独立库都能正常工作。

Java 有很多可供选择的日志框架。如果上面的清单似乎令人困惑，但不用担心。通常，你无需更改日志依赖项，Spring Boot 默认项工作就好。

4.1. Log FormatSpring Boot 的默认日志输出类似于以下示例：
2019-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.522019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms2019-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: &#x27;dispatcherServlet&#x27; to [/]2019-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: &#x27;hiddenHttpMethodFilter&#x27; to: [/*]

4.2. Console Output默认的日志配置在写入时会将信息回显到控制台。默认地，ERROR 级别，WARN 级别，以及 INFO 级别的信息会被记录。你还可以通过使用 --debug 标记启动应用，开启 “debug” 模式。
4.3. File Output默认情况下，Spring Boot 日志仅仅输出到控制台，并不会写到日志文件。如果你希望除了输出到控制台还能写到日志文件，你需要设置 logging.file.name 或者 logging.file.path 属性（例如，在你的 application.properties）。
下表一起展示了如何使用 logging.* 属性：
|logging.file.name|logging.file.path|Example|Description||(none)|(none)||仅控制台记录||特定文件|(none)|my.log|写到特定日志文件。名称可以是精确的位置或者相对于当前文件夹||(none)|Specific directory|&#x2F;var&#x2F;log|写 spring.log 到特定文件夹。名字可以是一个精确的位置或者相对于当前文件夹|
日志文件达到 10MB 时旋转，并且与控制台输出一样，默认记录了 ERROR 级别，WARN 级别，以及 INFO 级别的信息。可以使用 logging.file.max-size 属性修改大小限制。默认情况下，保留最后7天的轮转日志文件，除非设置 logging.file.max-history。可以使用 logging.file.total-size-cap 属性限制日志归档的总大小。当日志归档的总大小超过该阈值的时候，将删除备份。要在应用程序启动时强制执行日志归档清理，请使用 logging.file.clean-history-on-start 属性。

日志属性与实际日志基础架构无关。结果就是，Spring Boot 不会管理特定的配置键（例如，对于 Logback 的 logback.configurationFile）。

4.4. Log Levels所有支持的日志系统都可以通过使用 logging.level.&lt;logger-name&gt;=&lt;level&gt; 在 Spring Environment 中（例如，在 application.properties）设置日志级别，其中 level 是 TRACE，DEBUG，INFO，WARN，ERROR，FATAL，或者 OFF 之一。可以使用 logging.level.root 配置 root 记录器。
以下示例展示了 application.properties 中的可能的日志设置：
logging.level.root=warnlogging.level.org.springframework.web=debuglogging.level.org.hibernate=error

也可以使用环境变量设置日志级别。例如，LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_WEB=DEBUG 将设置 org.springframework.web 为 DEBUG。
4.7. Custom Log Configuration可以通过在类路径上包含适当的库来激活各种日志系统，并可以通过提供合适的配置文件进行进一步的定制化，配置文件可以在类路径的根或者由下面 Spring Environment 属性：logging.config 指定位置。
你可以使用 org.springframework.boot.logging.LoggingSystem 系统属性强制 Spring Boot 使用特定的日志系统。该值必须是 LoggingSystem 实现的完全限定类名。你也可以使用 none 值完全禁用 Spring Boot 的日志配置。

由于 logging 是在 ApplicationContext 创建之前初始化的，因此不可能从 @Configuration 文件中的 @PropertySources 控制日志。更改日志系统或者完全禁用唯一的方式是通过系统属性。

根据你的日志系统，加载下面的文件：



Logging System
Customization



Logback
logback-spring.xml, logback-spring.groovy, logback.xml, 或者 logback.groovy


Log4j2
log4j2-spring.xml，或者 log4j2.xml


JDK (Java Util Logging)
logging.properties


5. Internationalization6. JSON7. Developing Web Applications7.1. The “Spring Web MVC Framework”7.1.1. Spring MVC Auto-configurationSpring Boot 为 Spring MVC 提供了自动配置 WebMvcAutoConfiguration。

WebMvcAutoConfigurationAdapter

如果希望保持 Spring Boot MVC 的定制，并作出更多 MVC 自定义的话，只需要添加自己的 WebMvcConfigurer，并添加 @Configuration 类，而不要使用 @EnableWebMvc。
@EnableWebMvc 导致 Spring Boot 自动配置失效原因：@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
如果向完全控制 Spring MVC，可以添加带有 @EnableWebMvc 的 @Configuration，或者添加自己的 @Configuration 的 DelegatingWebMvcConfiguration
7.1.2. HttpMessageConvertersSpring MVC 使用 HttpMessageConverter 接口来转换 HTTP 请求和响应。开箱即用地包含一些合理的默认项。例如，可以自动地将对象转换为 JSON（通过使用 Jackson 库）或者 XML（通过使用 Jackson XML 扩展，如果可用，或者如果 Jackson XML 扩展不可用就是用 JAXB）。
如果需要添加 converter，可以使用 Spring Boot 的 HttpMessageConverters：
@Configuration(proxyBeanMethods = false)public class MyConfiguration &#123;    @Bean    public HttpMessageConverters customConverters() &#123;        HttpMessageConverter&lt;?&gt; additional = ...        HttpMessageConverter&lt;?&gt; another = ...        return new HttpMessageConverters(additional, another);    &#125;&#125;

7.1.3. Custom JSON Serializers and Deserializers使用 @JsonComponent 自定义序列化和反序列化
&amp;nbsp;
7.1.5. Static Content默认地，Spring Boot 提供静态资源的路径（见 ResourceProperties.CLASSPATH_RESOURCE_LOCATIONS）：

classpath:&#x2F;static
classpath:&#x2F;public
classpath:&#x2F;resources
classpath:&#x2F;META-INF&#x2F;resources
servletContext 根路径

Spring Boot 使用 Spring MVC 的 ResourceHttpRequestHandler 处理静态资源，可以通过添加自己的 WebMvcConfigurer 并覆盖 addResourceHandlers 方法修改此行为。
&amp;nbsp;默认地，静态资源资源映射在 &#x2F;**，可以使用如下配置调整：
# 增加一个固定前缀 resourcesspring.mvc.static-path-pattern=/resources/**

&amp;nbsp;修改默认的静态资源搜寻路径，支持数组（上面描述的 4 个 classpath 路径会失效）：
# Servlet Context 的根路径会自动添加# 注意末尾需要添加 /spring.resources.static-locations=classpath:/res/


官方提示 如果应用程序预计打包为 jar，不要使用 src&#x2F;main&#x2F;webapp 目录。虽然这是一个通用标准，但只是在 war 包上，如果生成 jar，会被大多数构建工具忽略。
7.1.6. Welcome PageSpring Boot 支持静态和模板的欢迎页面。Spring Boot 首先在配置静态内容位置中寻找 index.html 文件。如果一个都没找到，那么它会寻找一个 index 模板。如果找到了某一个模板，模板将会自动使用作为应用的欢迎页。
7.1.7. Custom Favicon在配置的静态内容位置寻找 favicon.ico，如果存在自动作为应用的图标（不可以增加静态资源前缀）。
7.1.11. Error Handling默认地，Spring Boot 提供一个 /error 的 mapping 以明智的方式来处理所有的错误，并且它被注册为一个 Servlet 容器“全局”错误页面。对于机器客户端，它会产生一个具有错误详情，HTTP 状态码，异常信息的 JSON 响应。对于浏览器客户端，有一个白页错误视图，以 HTML 的格式渲染相同的数据（要定制它，需要添加一个解析到 error 的视图）。
如果你要自定义默认的错误处理行为，则可以设置许多 server.error 属性。参见附录的 “Server Properties”
为了完全替换默认行为，你可以实现 ErrorController 并注册该类型的 Bean Definition，或者添加类型为 ErrorAttributes 的 Bean，以使用现存的机制，但是替换内容。
你还可以定义一个以 @ControllerAdvice 注解的类，来自定义 JSON 格式，用于特定的 Controller 或者异常类型，如下示例所示：
@ControllerAdvice(basePackageClasses = AcmeController.class)public class AcmeControllerAdvice extends ResponseEntityExceptionHandler &#123;    @ExceptionHandler(YourException.class)    @ResponseBody    ResponseEntity&lt;?&gt; handleControllerException(HttpServletRequest request, Throwable ex) &#123;        HttpStatus status = getStatus(request);        return new ResponseEntity&lt;&gt;(new CustomErrorType(status.value(), ex.getMessage()), status);    &#125;    private HttpStatus getStatus(HttpServletRequest request) &#123;        Integer statusCode = (Integer) request.getAttribute(&quot;javax.servlet.error.status_code&quot;);        if (statusCode == null) &#123;            return HttpStatus.INTERNAL_SERVER_ERROR;        &#125;        return HttpStatus.valueOf(statusCode);    &#125;&#125;


&amp;nbsp;

@ResponseStatus 注解的异常类

通过处理过程抛出特定的异常，该异常类被 @ResponseStatus 注解
&amp;nbsp;在 Spring 中，HandlerExceptionResolverComposite 也是一个 HandlerExceptionResolver，而且它是多个 HandlerExceptionResolver 的组合。默认地，它以如下的顺序包含多个 HandlerExceptionResolver：
(1) ExceptionHandlerExceptionResolver(2) ResponseStatusExceptionResolver(3) DefaultHandlerExceptionResolver，垫底处理，实现 Ordered 接口，并且 order &#x3D; Ordered.LOWEST_PRECEDENCE
Custom Error Pages对于给定的 HTTP 状态码，自定义 HTML 错误页面，可以添加文件到 &#x2F;error 路径。错误页面可以是静态 HTML 或者使用模板引擎。
页面名称应该是精确的状态码或一系列掩码，如：404.html, 5xx.html。
7.4. Embedded Servlet Container SupportSpring Boot 包含对内嵌的 Tomcat，Jetty，以及 Undertow 服务器的支持。大多数开发者使用适当的 “starter” 获得完整的配置实例。默认的，内嵌的服务器在端口 8080 上监听 HTTP 请求。
7.4.1. Servlets, Filters, and listeners当使用内嵌的 Servlet 容器时，你可以通过使用 Spring Bean 或者通过扫描 Servlet 组件的方式注册来自于 Servlet 规范的 Servlet，Filter，以及所有的 Listener（例如 HttpSessionListener）
Registering Servlets, Filters, and Listeners as Spring Beans任何作为一个 Spring Bean 的 Servlet，Filter，或者 servlet *Listener 实例都会注册到内嵌的容器中。如果你想在配置期间引用一个来自于你 application.properties 的值，这是极其方便的。
默认情况下，如果上下文仅包含一个 Servlet，则将其映射到 /。在多 Servlet Bean 场景下，Bean Name 用于路径前缀。过滤器映射到 /*。
如果基于约定的映射不够灵活，你可以使用 ServletRegistrationBean，FilterRegistrationBean，以及 ServletListenerRegistrationBean 类获得完全控制。
通常，保持 Filter Bean 无序是安全的。如果需要特定的 order，你应该用 @Order 注解 Filter 或者使其实现 Ordered。你无法通过用 @Order 注解其 bean 方法配置 Filter 的 order。如果你无法更改 Filter 类以添加 @Order 或者实现 Ordered，你必须定义为该 Filter 定义一个 FilterRegistrationBean 并使用 setOrder(int) 方法设置注册 Bean 的 order。避免配置在 Ordered.HIGEST_PRECEDENCE 读取请求体的过滤器，因为它可能与你应用的字符编码配置违背。如果 Servlet filter 包装请求，则应使用小于等于 OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER 的 order 值。
7.4.2. Servlet Context Initialization嵌入式 Servlet 容器不会直接执行 Servlet 3.0+ 的 javax.servlet.ServletContainerInitializer 接口或者是 Spring 的 org.springframework.web.WebApplicationInitializer 接口。这是一个故意的设计决定，旨在降低被设计在 war 中运行的第三方包可能破坏 Spring Boot 应用的风险。
如果你需要在 Spring Boot 应用中执行 Servlet Context 初始化，你应该注册一个实现了 org.springframework.boot.web.servlet.ServletContextInitializer 接口的 Bean。单个 onStartup 方法提供了对 ServletContext 的访问，并且如果有必要，可以轻松地用作现存的 WebApplicationInitializer 的适配器。
Scanning for Servlets, Filters, and listeners当使用嵌入式容器时，可以通过使用 @ServletComponentScan 自动注册被 @WebServlet，@WebFilter，以及 @WebListener 注解的类。
8. Graceful shutdown11. Working with SQL DatabasesSpring Framework 为使用 SQL 数据库提供了广泛支持，从使用 JdbcTemplate 直接进行 JDBC 访问，到完成 “object relational mapping” 技术，例如 Hibernate。Spring Data 提供了更多功能级别：从你的接口中直接创建 Repository 实现，并使用约定从你的方法名称中生成查询。
11.1. Configure a DataSourceJava 的 javax.sql.DataSource 接口提供了一种使用数据库连接的标准方法。传统上，一个 ‘DataSource’ 使用 URL 以及一些凭证来建立数据库连接。
11.1.1. Embedded Database Support通常，使用一个内存嵌入式数据库开发应用很方便。显然，内存数据库不提供持久化存储。当你的应用程序启动时，你需要填充你的数据库，并在应用结束时准备好丢掉数据。
Spring Boot 可以自动配置嵌入式 H2，HSQL，以及 Derby 数据库。你不需要提供任何连接 URL。你只需要对要使用的嵌入式数据库包含一个构建依赖。
11.1.2. Connection to a Production Database还可以通过使用池化 DataSource 自动配置生产数据库连接。Spring Boot 使用以下算法来选择特定的实现：

我们更喜欢 HikariCP 的性能和并发。如果 HikariCP 可用，我们始终会选择它
否则，如果 Tomcat 池化 DataSource 可用，我们将使用它
如果 HikariCP 和 Tomcat 池化数据源都不可用，并且 Commons DBCP2 可用，我们会使用它

如果你使用 spring-boot-starter-jdbc 或者 spring-boot-starter-data-jpa “starter”，你会自动获得 HikariCP 的依赖。
DataSource 的配置由 spring.datasource.* 之中的外部配置属性控制。例如，你可以在 application.properties 中声明如下部分：
spring.datasource.url=jdbc:mysql://localhost/testspring.datasource.username=dbuserspring.datasource.password=dbpassspring.datasource.driver-class-name=com.mysql.jdbc.Driver


你应该至少通过设置 spring.datasource.url 属性来指定 URL。否则，Spring Boot 将尝试自动配置嵌入式数据库。


你通常不需要指定 driver-class-name，因为 Spring Boot 可以从 url 中推导得到大多数数据库。

11.2. Using JdbcTemplateSpring 的 JdbcTemplate 和 NamedParameterJdbcTemplate 类是自动配置的，你可以将它们直接 @Autowire 进自己的 Bean，如下示例所示：
import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Component;@Componentpublic class MyBean &#123;    private final JdbcTemplate jdbcTemplate;    @Autowired    public MyBean(JdbcTemplate jdbcTemplate) &#123;        this.jdbcTemplate = jdbcTemplate;    &#125;    // ...&#125;


作者的话 上面的例子其实不必在构造器上加 @Autowired，因为这是 Spring 的默认行为

11.3. JPA and Spring Data JPAJava Persistence API 是一种标准技术，可以让你映射对象到关系型数据库。spring-boot-starter-data-jpa POM 提供了一种快速入门的方法。它提供了如下几个关键依赖：

Hibernate：最流行的 JPA 实现之一
Spring Data JPA：帮你实现基于 JPA 的存储库
Spring ORM：为 Spring Framework 提供核心 ORM 支持

11.3.1. Entity Classes传统上，JPA 实体类在 persistence.xml 文件中指定。使用 Spring Boot，不需要此文件，而是使用 “实体扫描”。默认情况下，在你主应用类（注解了 @EnableAutoConfiguration 以及 @SpringBootApplication 的类）下的所有包都会被搜索。
使用 @Entity，@Embeddable，或者 @MappedSuperclass 注解的类都会被纳入。一个典型的实体类类似于以下示例：
package com.example.myapp.domain;import java.io.Serializable;import javax.persistence.*;@Entitypublic class City implements Serializable &#123;    @Id    @GeneratedValue    private Long id;    @Column(nullable = false)    private String name;    @Column(nullable = false)    private String state;    // ... additional members, often include @OneToMany mappings    protected City() &#123;        // no-args constructor required by JPA spec        // this one is protected since it shouldn&#x27;t be used directly    &#125;    public City(String name, String state) &#123;        this.name = name;        this.state = state;    &#125;    public String getName() &#123;        return this.name;    &#125;    public String getState() &#123;        return this.state;    &#125;    // ... etc&#125;

11.3.2. Spring Data JPA RepositoriesSpring Data JPA repository 是一些接口，你可以定义其用于访问数据。JPA 查询从你的方法名称自动创建。例如，一个 CityRepository 接口可能声明了一个 findAllByState(String state) 方法，用于找到给定 state 的所有 city。
有关更复杂的查询，你可以使用 Spring Data 的 Query 注解来注解你的方法。
通常，Spring Data repository 从 Repository 或者 CrudRepository 接口扩展。如果你使用自动配置，将会从包含主配置类（被 @EnableAutoConfiguration 或者 @SpringBootApplication 注解的类）的包下面搜索 repository。
以下示例展示了一个典型的 Spring Data repository 接口的定义：
package com.example.myapp.domain;import org.springframework.data.domain.*;import org.springframework.data.repository.*;public interface CityRepository extends Repository&lt;City, Long&gt; &#123;    Page&lt;City&gt; findAll(Pageable pageable);    City findByNameAndStateAllIgnoringCase(String name, String state);&#125;

Spring Data JPA repository 支持三种不同的自我引导模式：default，deferred，以及 lazy。要启动 deferred 或者 lazy 自启，请将分别将 spring.data.jpa.repositories.bootstrap-mode 属性设置为 deferred 或者 lazy。当使用 deferred 或者 lazy 引导模式时，自动配置的 EntityManagerFactoryBuilder 将会使用上下文的 AsyncTaskExecutor（如果有的话）作为引导的执行器。如果存在多个，将会使用名为 applicationTaskExecutor 的那个。
11.4. Spring Data JDBCSpring Data 包含对 JDBC 支持的 repository，并将自动为 CrudRepository 上的方法生成 SQL。对于更高级的查询，提供了一个 @Query 注解。
当必要的依赖在类路径上时，Spring Boot 将自动配置 Spring Data 的 JDBC repository。使用仅仅一个依赖 spring-boot-starter-data-jdbc，就可以将它们添加到你的项目。如果有必要，你可以通过添加 @EnableJdbcRepositories 注解或者 JdbcConfiguration 子类到你的应用来控制 Spring Data JDBC 的配置。
11.5. Using H2’s Web ConsoleH2 数据库提供了一个基于浏览器的控制台，Spring Boot 可以为你自动配置。当满足如下条件时，将自动配置控制台：

你正在开发一个基于 Servlet 的 Web 应用
com.h2database:h2 在类路径
你正在使用 Spring Boot’s developer tools

如果你没有使用 Spring Boot developer tools，但仍然希望使用 H2 的控制台，你可以配置 spring.h2.console.enabled 属性值为 true
11.5.1. Changing the H2 Console’s Path默认情况下，控制台在 /h2-console 可以获得。你可以使用 spring.h2.console.path 属性自定义控制台路径。
12. Working with NoSQL Technologies12.5. Elasticsearch12.1. Redis13. CachingSpring Framework 为透明地将缓存添加到应用提供了支持。从其核心，抽象将缓存应用于方法，从而根据缓存中可用的信息减少了执行次数。缓存逻辑是透明地应用的，不会对调用者进行任何干扰。只要通过 @EnableCaching 注解启用缓存支持，Spring Boot 就会自动配置缓存基础架构。
简而言之，为了将缓存添加到服务的操作中，将相关的注解添加到其方法中，如下图所示：
import org.springframework.cache.annotation.Cacheable;import org.springframework.stereotype.Component;@Componentpublic class MathService &#123;    @Cacheable(&quot;piDecimals&quot;)    public int computePiDecimal(int i) &#123;        // ...    &#125;&#125;

该示例证明了在可能高成本的操作中使用缓存。在调用 computePiDecimal，抽象在 piDecimals 缓存中匹配 i 参数的条目。如果找到条目，则立即将缓存中的内容返回给调用者，并且该方法不会调用。否则，将调用方法，在返回该值之前更新缓存。

你还可以透明地使用标准 JSR-107(JCache) 注解（例如 @CacheResult）。但是，我们强烈建议你不要混合并匹配 Spring Cache 和 JCache 注解。

如果你没有添加任何特定的缓存库，Spring Boot 自动配置一个在内存的使用 concurrent map 的 simple provider。当需要缓存（例如在前面例子中的 piDecimals）时，该 provider 就会为你创建一个。实际上，并不建议将 simple provider 用于生产，但是它非常适合入门，以及确保你了解这些功能。当你决定要使用 cache provider 时，请确保阅读其文档，以找出如何配置应用程序使用的缓存。几乎所有的 provider 都要求你显式配置每个你在应用中使用的缓存。有些提供一种自定义默认缓存的方法，通过定义 spring.cache.cache-names 属性。

也可以透明地更新或从缓存中驱逐数据

13.1. Supported Cache Providers缓存抽象并不提供实际的存储，并依赖于由 org.springframework.cache.Cache 和 org.springframework.cache.CacheManager 接口实现的抽象。
如果你没有定义 CacheManager 类型的 Bean 或者名为 cacheResolver 的 CacheResolver，Spring Boot 会尝试检测以下 provider（按照指示的顺序）：

Generic
JCache (JSR-107)(EhCache 3, Hazelcast, Infinispan, and others)
EhCache 2.x
Hazelcast
Infinispan
Couchbase
Redis
Caffeine
Simple

13.1.1. Generic如果上下文定义了至少一个 org.springframework.cache.Cache Bean，则使用 Generic 缓存。将会创建一个 CacheManager 包裹所有该类型的 Bean。
13.1.2. JCache (JSR-107)通过类路径包含一个 javax.cache.spi.CachingProvider 会自动引导 JCache，并且 spring-boot-starter-cache “starter” 提供 JCacheCacheManager。可以获得各种符合条件的库，Spring 为 Ehcache 3，Hazelcast 和 Infinispan 提供依赖管理。也可以添加任何其他符合条件的库。
有可能出现多个 provider，在这种情况下，provider 必须显式指定。即使 JSR-107 标准没有强制一种标准的方式定义配置文件的路径，Spring Boot 尽力容纳使用实现细节配置一个缓存，如下示例所示：
# Only necessary if more than one provider is presentspring.cache.jcache.provider=com.acme.MyCachingProviderspring.cache.jcache.config=classpath:acme.xml

有两种方法可以自定义底层的 javax.cache.cacheManager:

可以通过启动时设置 spring.cache.cache-names 属性创建缓存。如果定义了自定义的 javax.cache.configuration.Configuration，则将用于定制化缓存。
使用 CacheManager 引用调用 org.springframework.boot.autoconfigure.cache.JCacheManagerCustomizer Bean，获得完整定制化。

13.1.3. EhCache 2.x如果在类路径的根路径下能够找到名为 ehcache.xml 的文件，那么 EhCache 2.x 会被使用。如果找到 EhCache 2.x，那么由 spring-boot-starter-cache “starter” 提供的 EhCacheCacheManager 将用于引导 cache manager。也可以提供可替代的配置文件，如下示例所示：
spring.cache.ehcache.config=classpath:config/another-config.xml

13.1.4. HazelcastSpring Boot 对 Hazelcast 有一般支持。如果 HazelcastInstance 已经自动配置了，那么它将自动包裹进 CacheManager。
13.1.5. Infinispan13.1.7. Redis如果 Redis 可用且已配置，RedisCacheManager 就会自动配置。可以通过设置 spring.cache.cache-names 属性在启动时创建额外的缓存，以及通过使用 spring.cache.redis.* 属性配置缓存默认值。例如，以下配置创建了 cache 和 cache2 缓存，并具有 10 分钟的存活时间: 
spring.cache.cache-names=cache1,cache2spring.cache.redis.time-to-live=600000


Tips 需要依赖 spring-boot-starter-data-redis 才能引入 RedisCacheManager


默认情况下，添加了一个 key 前缀，这是为了，如果两个分开的缓存使用相同的 key，redis 没有重叠的 key，且无法返回无效值。我们强烈建议你在创建自己的 RedisCacheManager 时启用该设置。

21. Quartz Scheduler26. TestingSpring Boot 在测试你的应用程序时提供了许多工具和注解。由两个模块提供测试支持：spring-boot-test 包含核心项目，spring-boot-test-autoconfigure 包含测试的自动配置。
大多数开发者使用 spring-boot-starter-test “starter”，该测试不仅导入了 Spring Boot 测试模块，而且还导入了 JUnit Jupiter，AssertJ，Hamcrest，以及许多其他有用的库。

starter 还引入了 vintage 引擎，因此你既可以运行 JUnit 4 也可以运行 JUnit 5 的测试。如果你已经将测试迁移到 JUnit 5，你应该排除 JUnit 4 的支持，如下示例所示：
&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/&gt; artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;            &lt;artifactId&gt;junit-vintage-engine&lt;/&gt; artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;

26.1. Test Scope Dependencies29. Creating Your Own Auto-configuration29.1. Understanding Auto-configured Beans表层之下 ，使用标准 @Configuration 类实现自动配置。当使用自动配置时，需要使用额外的 @Conditional 注解进行约束。通常，自动配置类使用 @ConditionalOnClass 以及 @ConditionalOnMissingBean 注解。这样可以确保仅当找到相关的类，以及未声明自己的 @Configuration 时才使用自动配置。
你可以浏览 spring-boot-autoconfigure 源码，查看 Spring 提供的 @Configuration 类（见 META-INF/spring.factories 文件）。
29.2. Locating Auto-configuration CandidatesSpring Boot 检查你已发布的 jar 中是否存在 META-INF/spring.factories 文件。该文件应在 EnableAutoConfiguration key 下列出你的配置类，如下示例所示：
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration

29.3. Condition Annotations29.3.1. Class Conditions
@ConditionalConClass
@ConditionalOnMissingClass

29.3.2. Bean Conditions
@ConditionalOnBean
@ConditionalOnMissingBean

29.3.3. Property Conditions
@ConditionalOnProperty

29.3.4. Resource Conditions
@ConditionalOnResource

29.3.5. Web Application Conditions
@ConditionalOnWebApplication
@ConditionalOnNotWebApplication

29.3.6. SpEL Expression Conditions]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Hystrix 配置实践</title>
    <url>/2022/07/15/Framework/Java/Spring-Cloud/Hystrix-%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[涉及到断路器的参数（HystrixCommandProperties）：



参数
描述
默认值



circuitBreaker.enabled
是否开启断路器
true


circuitBreaker.requestVolumeThreshold
请求总数阈值。这意味着，如果 hystrix 命令在休眠窗口期间调用次数不足 20 次，即使请求都失败，断路器也不会打开
20


circuitBreaker.sleepWindowInMilliseconds
休眠窗口
5000


circuitBreaker.errorThresholdPercentage
错误阈值。当请求总数在休眠窗口内超过了阈值，断路器就会打开。
50


]]></content>
  </entry>
  <entry>
    <title>Spring Cloud BootstrapImportSelector</title>
    <url>/2022/07/22/Framework/Java/Spring-Cloud/Spring-Cloud-BootstrapImportSelector/</url>
    <content><![CDATA[Spring Cloud BootstrapImportSelector在 BootstrapApplicationListener 监听器中，会将 BootstrapImportSelectorConfiguration 配置类注入到 IoC 容器，该配置类有一个注解 @Import，将 BootstrapImportSelector 类注入到容器：
@Configuration(proxyBeanMethods = false)@Import(BootstrapImportSelector.class)public class BootstrapImportSelectorConfiguration &#123;&#125;


BootstrapImportSelector 获得 spring.factories 文件中 key 为 org.springframework.cloud.bootstrap.BootstrapConfiguration 的配置组件。
构建 bootstrapServiceContext 流程在 SpringApplication 运行 run 方法的过程中会调用 prepareEnvironment 进行环境准备，其中会调用所有的监听器 SpringApplicationRunListener 进行环境准备，调用链如下：
SpringApplication.run()-&gt; SpringApplication.prepareEnvironment()-&gt; listeners.environmentPrepared()

一般来说，默认只有一个监听器 EventPublishingRunListener，以下是 SpringApplicationRunListeners 的调用入口：
void environmentPrepared(ConfigurableEnvironment environment) &#123;    for (SpringApplicationRunListener listener : this.listeners) &#123;        listener.environmentPrepared(environment);    &#125;&#125;

EventPublishingRunListener 会调用内部的 initialMulticaster 进行事件广播，代码清单如下：
public void environmentPrepared(ConfigurableEnvironment environment) &#123;    this.initialMulticaster            .multicastEvent(new ApplicationEnvironmentPreparedEvent(this.application, this.args, environment));&#125;


接下来会进入 SimpleApplicationEventMulticaster 的广播事件逻辑，将会获取所有的 ApplicationListener（这也包括 BootstrapApplicationListener）：
public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) &#123;    ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));    Executor executor = getTaskExecutor();    for (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;        if (executor != null) &#123;            executor.execute(() -&gt; invokeListener(listener, event));        &#125;        else &#123;            invokeListener(listener, event);        &#125;    &#125;&#125;

调用事件逻辑链如下：
SimpleApplicationEventMulticaster.invokeListener()-&gt; SimpleApplicationEventMulticaster.doInvokeListener()-&gt; ApplicationListener.onApplicationEvent(event)


下面 BootstrapApplicationListener 开始处理事件:
public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) &#123;    ConfigurableEnvironment environment = event.getEnvironment();    if (!environment.getProperty(&quot;spring.cloud.bootstrap.enabled&quot;, Boolean.class,            true)) &#123;        return;    &#125;    // don&#x27;t listen to events in a bootstrap context    if (environment.getPropertySources().contains(BOOTSTRAP_PROPERTY_SOURCE_NAME)) &#123;        return;    &#125;    ConfigurableApplicationContext context = null;    String configName = environment            .resolvePlaceholders(&quot;$&#123;spring.cloud.bootstrap.name:bootstrap&#125;&quot;);    for (ApplicationContextInitializer&lt;?&gt; initializer : event.getSpringApplication()            .getInitializers()) &#123;        if (initializer instanceof ParentContextApplicationContextInitializer) &#123;            context = findBootstrapContext(                    (ParentContextApplicationContextInitializer) initializer,                    configName);        &#125;    &#125;    if (context == null) &#123;        // 这里调用 bootstrapServiceContext 创建了一个上下文        context = bootstrapServiceContext(environment, event.getSpringApplication(), configName);        event.getSpringApplication().addListeners(new CloseContextOnFailureApplicationListener(context));    &#125;    apply(context, event.getSpringApplication(), environment);&#125;

下面是 BoostrapApplicationListener 创建上下文的方法：
private ConfigurableApplicationContext bootstrapServiceContext(        ConfigurableEnvironment environment, final SpringApplication application,        String configName) &#123;    StandardEnvironment bootstrapEnvironment = new StandardEnvironment();    MutablePropertySources bootstrapProperties = bootstrapEnvironment            .getPropertySources();    for (PropertySource&lt;?&gt; source : bootstrapProperties) &#123;        bootstrapProperties.remove(source.getName());    &#125;    String configLocation = environment            .resolvePlaceholders(&quot;$&#123;spring.cloud.bootstrap.location:&#125;&quot;);    String configAdditionalLocation = environment            .resolvePlaceholders(&quot;$&#123;spring.cloud.bootstrap.additional-location:&#125;&quot;);    Map&lt;String, Object&gt; bootstrapMap = new HashMap&lt;&gt;();    bootstrapMap.put(&quot;spring.config.name&quot;, configName);    // if an app (or test) uses spring.main.web-application-type=reactive, bootstrap    // will fail    // force the environment to use none, because if though it is set below in the    // builder    // the environment overrides it    // 如果一个应用（或者 test）使用 spring.main.web-application-type=reactive，bootstrap 就会失败    // 强制环境使用 none，因为如果在构建器中设置为 below，环境就会覆盖???    bootstrapMap.put(&quot;spring.main.web-application-type&quot;, &quot;none&quot;);    if (StringUtils.hasText(configLocation)) &#123;        bootstrapMap.put(&quot;spring.config.location&quot;, configLocation);    &#125;    if (StringUtils.hasText(configAdditionalLocation)) &#123;        bootstrapMap.put(&quot;spring.config.additional-location&quot;,                configAdditionalLocation);    &#125;    bootstrapProperties.addFirst(            new MapPropertySource(BOOTSTRAP_PROPERTY_SOURCE_NAME, bootstrapMap));    for (PropertySource&lt;?&gt; source : environment.getPropertySources()) &#123;        if (source instanceof StubPropertySource) &#123;            continue;        &#125;        bootstrapProperties.addLast(source);    &#125;    // TODO: is it possible or sensible to share a ResourceLoader?    SpringApplicationBuilder builder = new SpringApplicationBuilder()            .profiles(environment.getActiveProfiles()).bannerMode(Mode.OFF)            .environment(bootstrapEnvironment)            // Don&#x27;t use the default properties in this builder            .registerShutdownHook(false).logStartupInfo(false)            .web(WebApplicationType.NONE);    final SpringApplication builderApplication = builder.application();    if (builderApplication.getMainApplicationClass() == null) &#123;        // gh_425:        // SpringApplication cannot deduce the MainApplicationClass here        // if it is booted from SpringBootServletInitializer due to the        // absense of the &quot;main&quot; method in stackTraces.        // But luckily this method&#x27;s second parameter &quot;application&quot; here        // carries the real MainApplicationClass which has been explicitly        // set by SpringBootServletInitializer itself already.        builder.main(application.getMainApplicationClass());    &#125;    if (environment.getPropertySources().contains(&quot;refreshArgs&quot;)) &#123;        // If we are doing a context refresh, really we only want to refresh the        // Environment, and there are some toxic listeners (like the        // LoggingApplicationListener) that affect global static state, so we need a        // way to switch those off.        builderApplication                .setListeners(filterListeners(builderApplication.getListeners()));    &#125;    // 这里配了一个 BootstrapImportSelectorConfiguration    builder.sources(BootstrapImportSelectorConfiguration.class);    final ConfigurableApplicationContext context = builder.run();    // gh-214 using spring.application.name=bootstrap to set the context id via    // `ContextIdApplicationContextInitializer` prevents apps from getting the actual    // spring.application.name    // during the bootstrap phase.    context.setId(&quot;bootstrap&quot;);    // Make the bootstrap context a parent of the app context    addAncestorInitializer(application, context);    // It only has properties in it now that we don&#x27;t want in the parent so remove    // it (and it will be added back later)    bootstrapProperties.remove(BOOTSTRAP_PROPERTY_SOURCE_NAME);    mergeDefaultProperties(environment.getPropertySources(), bootstrapProperties);    return context;&#125;


BootstrapImportSelector 如何进行 selectImports 操作bootstrapServiceContext 与一般的 ApplicationContext 类似，也需要进行容器 refresh 操作。
其中会调用许多 BeanFactoryPostProcessor 进行处理，包括 ConfigurationClassPostProcessor，Bean Definition bootstrapImportSelectorConfiguration 就是其处理对象，也可以说是候选人 candidates 之一。
候选人经过 ConfigurationClassParser 解析，解析之后会得到许多 ConfigurationClass。解析的过程主要分两个步骤：解析、延迟处理：

对于那些实现了 DeferredImportSelector 接口的 ImportSelector，会在延迟处理中处理

// ConfigurationClassParserpublic void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) &#123;    for (BeanDefinitionHolder holder : configCandidates) &#123;        BeanDefinition bd = holder.getBeanDefinition();        // 以下的 parse 方法也会特殊过滤 DeferredImportSelector        try &#123;            if (bd instanceof AnnotatedBeanDefinition) &#123;                parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());            &#125;            else if (bd instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;                parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());            &#125;            else &#123;                parse(bd.getBeanClassName(), holder.getBeanName());            &#125;        &#125;        catch (BeanDefinitionStoreException ex) &#123;            throw ex;        &#125;        catch (Throwable ex) &#123;            throw new BeanDefinitionStoreException(                    &quot;Failed to parse configuration class [&quot; + bd.getBeanClassName() + &quot;]&quot;, ex);        &#125;    &#125;    // 延迟处理 ImportSelector    this.deferredImportSelectorHandler.process();&#125;


parse 方法执行结束，接着使用 ConfigurationClassBeanDefinitionReader 加载所有的 ConfigurationClass。一般这里会解析到如下：

org.springframework.cloud.bootstrap.BootstrapImportSelectorConfiguration
org&#x2F;springframework&#x2F;cloud&#x2F;bootstrap&#x2F;config&#x2F;PropertySourceBootstrapConfiguration.class
org&#x2F;springframework&#x2F;cloud&#x2F;bootstrap&#x2F;encrypt&#x2F;EncryptionBootstrapConfiguration.class
org&#x2F;springframework&#x2F;cloud&#x2F;autoconfigure&#x2F;ConfigurationPropertiesRebinderAutoConfiguration.class
org&#x2F;springframework&#x2F;boot&#x2F;autoconfigure&#x2F;context&#x2F;PropertyPlaceholderAutoConfiguration.class
org&#x2F;springframework&#x2F;cloud&#x2F;util&#x2F;random&#x2F;CachedRandomPropertySourceAutoConfiguration.class

针对这些 ConfigurationClass，以此进行 Bean Definition 的加载：
// ConfigurationClassBeanDefinitionReader.javaprivate void loadBeanDefinitionsForConfigurationClass(        ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) &#123;    if (trackedConditionEvaluator.shouldSkip(configClass)) &#123;        String beanName = configClass.getBeanName();        if (StringUtils.hasLength(beanName) &amp;&amp; this.registry.containsBeanDefinition(beanName)) &#123;            this.registry.removeBeanDefinition(beanName);        &#125;        this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());        return;    &#125;    if (configClass.isImported()) &#123;        registerBeanDefinitionForImportedConfigurationClass(configClass);    &#125;    for (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;        loadBeanDefinitionsForBeanMethod(beanMethod);    &#125;    // 用于处理导入资源    loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());    // 用于处理     loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());&#125;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Config</title>
    <url>/2022/07/17/Framework/Java/Spring-Cloud/Spring-Cloud-Config/</url>
    <content><![CDATA[Spring Cloud Config1. Quick Start
该章是官网的一个体验案例

首先，启动服务，如下：
$ cd spring-cloud-config-server$ ../mvnw spring-boot:run
服务是一个 Spring Boot 程序，你也可以从 IDE 运行。
接下来，试验一下客户端，如下：
$ curl localhost:8888/foo/development&#123;&quot;name&quot;:&quot;foo&quot;,&quot;label&quot;:&quot;master&quot;,&quot;propertySources&quot;:[  &#123;&quot;name&quot;:&quot;https://github.com/scratches/config-repo/foo-development.properties&quot;,&quot;source&quot;:&#123;&quot;bar&quot;:&quot;spam&quot;&#125;&#125;,  &#123;&quot;name&quot;:&quot;https://github.com/scratches/config-repo/foo.properties&quot;,&quot;source&quot;:&#123;&quot;foo&quot;:&quot;bar&quot;&#125;&#125;]&#125;

定位属性资源的默认策略是去克隆一个 git 存储库（位于 spring.cloud.config.server.git.uri），并使用它去实例化一个迷你的 SpringApplication。
HTTP 服务以下格式的资源：
/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]/&#123;application&#125;-&#123;profile&#125;.yml/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml/&#123;application&#125;-&#123;profile&#125;.properties/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.properties

1.1. Client Side Usage为了在应用程序中使用这些功能，你可以将其构建为依赖于 spring-cloud-config-client 的Spring Boot 项目。最简便的方法是使用 Spring Boot 启动器 org.springframework.cloud:spring-cloud-starter-config。对于 maven 用户以及 Gradle 和 Spring CLI 用户的 Spring IO 版本管理属性文件，也有一个父 POM 和 BOM（spring-cloud-starter-parent）。
&lt;dependency&gt;	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;	&lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt;


现在，你可以创建一个标准的 Spring Boot 应用，就像下面的 HTTP 服务：
@SpringBootApplication@RestControllerpublic class Application &#123;    @RequestMapping(&quot;/&quot;)    public String home() &#123;        return &quot;Hello World!&quot;;    &#125;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class, args);    &#125;&#125;

当这个 HTTP 服务启动的时候，它会从默认的监听于本地端口 8888 配置服务（如果启动了）获取外部配置。如果想修改默认行为，你可以修改 bootstrap.properties 中的配置服务的位置，如下所示：
spring.cloud.config.uri: http://myconfigserver.com

默认地，如果应用名称没有设置，则会使用 application。如果要修改默认行为，可以使用 spring.application.name 进行修改：
spring.application.name: myapp



设置属性 $&#123;spring.application.name&#125; 不要使用保留字 application- 作为应用名前缀，防止无法解析出正确的资源。


2. Spring Cloud Config ServerSpring Cloud Config Server 提供了一个用于外部配置的 HTTP 资源 API。通过使用 @EnableConfigServer 注解，服务就能嵌入到 Spring Boot 应用中。因此，下面的应用就是一个配置服务：
@SpringBootApplication@EnableConfigServerpublic class ConfigServer &#123;  public static void main(String[] args) &#123;    SpringApplication.run(ConfigServer.class, args);  &#125;&#125;

和所有的 Spring Boot 应用一样，它默认运行在 8080 端口，但你可以将其切换到约定好的 8888 端口。最简单的方式是，通过配置 spring.config.name=configserver 来启动应用，这同时也设置了默认的存储库类型。

注意，这种配置方式的依据是 Config Server jar 包下的 configserver.yml 文件。实际并没有作用，引用的是 github 上面的样本地址。

另一种方式是使用你自己的 application.properties，如下所示：
application.properties
server.port: 8888spring.cloud.config.server.git.uri: file://$&#123;user.home&#125;/config-repo

在这里，$&#123;user.home&#125;/config-repo 是一个包含 YAML 以及属性文件的 git 存储库。

在 Windows 上，如果 git 存储库是一个绝对驱动的前缀，你需要再加一个 “&#x2F;“，例如：file:///$&#123;user.home&#125;/config-repo)

2.1. Environment Repository在什么地方存储配置服务的配置数据？管理此行为的策略是 EnvironmentRepository，服务 Environment 对象。这个 Environment 是 Spring Environment 的浅拷贝（包括 propertySources 作为主要功能）。Environment 资源是三个变量的参数化：

&#123;application&#125;，映射到 spring.application.name
&#123;profile&#125;，在客户端映射到 spring.profiles.active
&#123;label&#125;

存储库的实现通常表现得像一个 Spring Boot 程序，它从 spring.config.name 等于 &#123;application&#125; 以及 spring.profiles.active 等于 &#123;profiles&#125; 中加载配置文件。配置文件的优先规则也与常规的 Spring Boot 程序相同：激活的配置文件优先于默认值，如果又多个配置文件，则选择最后一个（类似向 Map 添加条目）。
如果存储库是基于文件的，那么服务器将从 application.yml 和 foo.yml 中创建一个 Environment。如果 YAML 文件在它们内部有指向 Spring 配置文件的文档，那么会使用更高的优先级。如果有特定的配置 YAML 文件，那么这些文件也以比默认值更高的优先级而使用。高优先级转换为在 Environment 中提前列出的 PropertySource。
2.1.1. Git Backend默认的 EnvironmentRepository 的实现使用 Git 后端，这对于管理升级和物理环境，以及对于跟踪变化非常方便。要更改存储库的位置，你可以在 Config Server（例如在 application.yml 中）中设置 spring.cloud.config.server.git.uri 配置属性。如果你用一个 file: 前缀进行设置，则应从本地存储库工作，以便于你可以在没有服务器的情况下快速启动。但是，在这种情况下，服务直接在本地存储库上操作而无需克隆（无论是否是裸仓库都无关紧要，因为 Config Server 永远不会更改 “remote” 存储库）。为了扩展 Config Server 并使其高度可用，你需要将所有服务实例指向相同的存储库，因此只有共享文件系统才能起作用。甚至在这种情况下，最好将 ssh: 协议用于共享文件系统存储库，以便于服务可以克隆它，并将本地工作副本作为缓存。
Skipping SSL Certificate Validation通过将 git.skipSslValidation 属性设置为 true（默认为 false），可以禁用配置服务器对 Git 服务器的 SSSL 证书校验：
spring:  cloud:    config:      server:        git:          uri: https://example.com/my/repo          skipSslValidation: true

Setting HTTP Connection Timeout2.1.3. File System BackendConfig Server 中拥有一个 native profile，该配置不使用 Git，而是从本地类路径或者文件系加载配置文件。为了使用本地配置，以 spring.profiles.active=native 启动 Config Server。
搜索路径可以包含占位符 &#123;application&#125;, &#123;profile&#125;, &#123;label&#125;。通过这种方式，你可以在路径中分离目录并选择一个对你有意义的策略。
如果你没有在搜索路径中使用占位符，存储库还会将 &#123;label&#125; 参数追加到存储路径末尾，因此属性文件会从每个搜索路径，以及有一个 label 后缀的子目录去加载。因此，没有占位符的默认行为与在搜索路径末尾添加 /&#123;label&#125;/ 相同。举个例子，file:/tmp/config 与 file:/tmp/config,file:/tmp/config/&#123;label&#125; 相同。这个行为可以通过设置 spring.cloud.config.server.native.addLabelLocations=false 从而禁用。


默认添加 label 后缀的行为很单纯，例如，你设置了 spring.cloud.config.server.native.search-locations=file:///f:/profiles/application，同时 label 参数为 dev，那么还会搜索的路径就是 file:///f:/profiles/applicationdev，并不会帮你自动添加路径分隔符 /，至少在 2.2.8.RELEASE 测试是如此。


2.1.6. Sharing Configuration With All Applications2.1.6.1. File Based Repositories使用基于文件的存储库，在所有客户端应用之间共享文件名为 application* 的资源（application.properties, application.yml, application-*.properties 等）。你可以使用具有这些文件名的资源来进行全局默认配置，并且根据需要让它们被应用特定的文件覆盖。
属性覆盖功能也可以用于设置全局默认，应用程序允许在本地覆盖它们。

使用 native 配置文件（本地文件系统后端），你应该使用不属于服务自己的配置的指定搜索路径。否则，位于默认搜索路径中的 application* 资源会被移除，因为它们是服务的一部分。

2.1.7. JDBC BackendSpring Cloud Config 服务支持 JDBC 作为配置属性的后端。你可以通过添加 spring-jdbc 到类路径，并使用 jdbc 配置，或者添加 JdbcEnvironmentRepository 该 bean 来启用此功能。
你可以通过设置 spring.cloud.config.server.jdbc.enabled=false 来禁用 JdbcEnvironmentRepository 的自动配置。

至少 Spring Cloud Config 2.2.8.RELEASE 开始支持 enabled 属性

数据库需要有一个名为 PROPERTIES 的表，列为 APPLICATION, PROFILE, LABEL, KEY, VALUE。所有的字段都是 Java 的 String 类型，因此你可以定义为 VARCHAR。属性值表现与它们来自 Spring Boot 属性文件 &#123;application&#125;-&#123;profile&#125;.properties 相同，包括所有的编码与解码，这些稍后会进行处理（即不会直接再存储库实现中）。

默认的 SQL 为 SELECT KEY, VALUE from PROPERTIES where APPLICATION=? and PROFILE=? and LABEL=?，但这对于 MySQL 并不管用，因为 KEY 为关键字，应当被反引号包裹，否则在执行过程中报错。

2.1.8. Redis Backend2.1.11 Composite Environment Repositories从多个环境存储库提取配置数据。
2.2.  Health Indicator配置服务器附带一个健康指示器，用于检查配置的 EnvironmentRepository 是否正常工作。默认地，它会请求 EnvironmentRepository 一个名为 app 的应用，default 的配置，由 EnvironmentRepository 实现提供的默认标签。
通过 health.config.enabled=false，你可以禁用健康指示器。
2.3. Security你可以以任何对你有意义的方法保护 Config Server（从物理网络安全到 OAuth2 持票人令牌），Spring Security 和 Spring Boot 提供了许多安全性的功能。
为了使用默认的 Spring Boot 配置 HTTP Basic 安全，需要包含 Spring Security 到类路径。默认具有一个名为 user 的用户名和随机生成的密码。实践中，随机密码并没有太大用处，推荐配置密码并加密。


需要包含 spring-boot-starter-security 依赖，以使用 Spring 的自动配置化的 HTTP Basic 安全
通过设置 spring.security.user.password 配置密码
客户端注意设置用户名和密码


2.4. Encryption and Decryption
为了使用加密和解密功能，旧版本 JDK 需要下载完全的 JCD

如果远程属性资源包含加密内容（以 &#123;cipher&#125; 开头），则先解密再通过 HTTP 发送。该设置的优点是：当属性值 “静止” 时，不需要以纯文本方式展示。如果值无法被解密，将会从属性源中删除它，并添加一个额外的有相同键的属性，但是具有 invalid 前缀，值意味着不适用。这主要是为了加密文本用作密码，有可能意外泄漏。
2.5. Key ManagementConfig Server 可以使用对称加密或者非对称加密（RSA 密钥对）。选择不对称加密在安全性方面更优越，但使用对称密钥通常更方便，因为它是在 bootstrap.properties 中配置的单个属性值。
要配置对称密钥，你需要设置 encryt.key 为密钥字符串（或者使用 ENCRYPT_KEY 环境变量，可以脱离纯文本配置文件）。
2.6. Creating a Key Store for Testing使用 JDK 自带的 keytool 工具创建密钥库。
$ keytool -genkeypair -alias mytestkey -keyalg RSA \  -dname &quot;CN=Web Server,OU=Unit,O=Organization,L=City,S=State,C=US&quot; \  -keypass changeme -keystore server.jks -storepass letmein

将生成的 server.jks 文件放到类路径下，然后在 bootstrap.yml 进行配置：
encrypt:  keyStore:    location: classpath:/server.jks # keystore 文件存储路径    password: letmein # storepass 密钥仓库    alias: mytestkey # 密钥对别名    secret: changeme # keypass 用来保护所生成密钥对中的私钥

2.7. Using Multiple Keys and Key Rotation2.8. Serving Encrypted Properties有时候，你往客户端自行解密配置，而不是在配置中心解密完毕再传送过来。在这种情况下，如果你提供了 encrypt.* 相关配置来定位 key，你还是可以具有 /encrypt 和 /decrypt 端点，但是你需要在 boostrap.[yml|properties] 设置 spring.cloud.config.server.encrypt.enabled=false 来显式关闭传出属性的解密功能。如果你不关心端点，那么如果你没有配置 key 或者 enabled 标志，就能起作用了。
3. Serving Alternative Formats来自环境端点的默认 JSON 格式是完美被 Spring 应用消费的，因为它直接映射到 Environment 抽象上。如果你愿意，你也可以通过增加一个后缀（”.yml”, “.yaml” 或者 “.properties”）以 YAML 或者 Java 属性消费相同的数据。这对于那些不关心 JSON 端点的结构，或者额外元数据的应用来消费是非常有用的（例如，未使用 Spring 的应用可能会受益于此方法的简单性）。
4. Serving Plain Text不使用 Environment 抽象，你的应用可能需要对其环境量身定制的通用普通文本配置文件。Config Server 通过一个位于 /&#123;application&#125;/&#123;profile&#125;/&#123;label&#125;/&#123;path&#125; 的额外端点提供这些，其中，application，profile，label 与常规的环境端点有相同含义，但是 path 是一个文件名的路径（例如 log.xml）。此端点的源文件以与环境端点相同的方式定位。相同的搜索路径被用于 properties 和 YAML 文件。但是，仅返回第一个被匹配的资源，而不是聚合所有资源。
在资源被定位之后，以常规格式的占位符（$&#123;...&#125;）会被使用提供的 application name，profile，label 解析。以这种方式，资源端点与环境端点紧密集成。
5. Embedding the Config Server配置服务最好以独立应用运行。但是，如果你需要，你也可以将其嵌入到另一个应用中。使用 @EnableConfigServer 注解，一个可选的属性 spring.cloud.config.server.bootstrap 在这种情况下是有用的。这是一个标记，指示该服务是否应该从它自己的远程存储库配置自己。默认地，该标记是关闭的，因为它可以延迟启动。但是，当嵌入另一个应用中时，将与任何其他应用程序以一样的方式启动是有意义的。将 spring.cloud.config.server.bootstrap 设置为 true 时，还必须使用符合环境存储库配置。
6. Push Notifications and Spring Cloud Bus许多源代码存储库提供者（如 Github，Gitlab，Gitea, Gitee, Gogs, 或者 Bitbucket）通过 webhook 通知你存储库中的更改。你可以通过提供者的用户接口以一个 URL 和一组你感兴趣的事件配置 webhook。如果你添加了 spring-cloud-config-monitor 依赖，并且在你的配置中心激活了 Spring Cloud Bus，那么 /monitor 端点会被启用。
当 webhook 被激活时，配置服务会针对它认为可能已经更改的应用程序发送 RefreshRemoteApplicationEvent 。变更检测是策略化的。但是，默认地，它会寻找与应用程序名称匹配的文件中地变更。
7. Spring Cloud Config ClientSpring Boot 应用可以立即使用 Spring Config 服务。
7.1. Config First Bootstrap类路径上拥有 Spring Cloud Config Client 的应用程序，默认的行为是：当配置客户端启动时，它会绑定到 Config Server（通过 spring.cloud.config.uri 引导配置属性），并使用远程属性源初始化 Spring 的 Environment。
此行为的最终结果是，所有希望消费 Config Server 的客户端需要一个 bootstrap.yml，其中需要在 spring.cloud.config.uri 中配置好服务地址（默认是 http://localhost:8888）。
7.2. Discovery First Bootstrap7.3. Config Client Fail Fast7.4. Config Client Retry7.5. Locating Remote Configuration ResourcesConfig Service 从 /&#123;application&#125;/&#123;profile&#125;/&#123;label&#125; 供应属性源，在客户端应用中默认的绑定如下：

“application”&#x3D;$&#123;spring.application.name&#125;
“profile”&#x3D;$&#123;spring.profiles.active&#125;
“label”&#x3D;”master”

你可以通过设置 spring.cloud.config.* 来覆盖它们（此处 * 表示 name, profile, label）。
label 对于回滚到之前的配置版本比较有用，使用默认的 Config Server 实现，它可以是 git label，分支名，commit ID。
label 也可以用逗号分隔的列表表示，在这种情况下，列表中的项目会逐个尝试，直至成功（即只有一个有效）。当工作在功能分支上时，此行为可能比较有用，例如，你可能希望将 label 与你的分支对齐，但使其可选，在这种情况下，你可以使用 spring.cloud.config.label=myfeature,develop。
7.6. Specifying Multiple Urls for the Config Server7.7. Configuring Timeouts配置超时阈值：

读取超时：spring.cloud.config.request-read-timeout
连接超时：spring.cloud.config.request-connect-timeout

7.8. Security如果你使用 HTTP Basic 安全验证，客户端需要知晓密码（如果不是默认的，还需要用户名）。你可以通过配置服务的 URI 指定用户名和密码，或者通过 username 和 password 属性：
spring:  cloud:    config:     uri: https://user:secret@myconfig.mycompany.com

spring:  cloud:    config:     uri: https://myconfig.mycompany.com     username: user     password: secret


spring.cloud.config.username 和 spring.cloud.config.password 会覆盖 URI 里的值

]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Gateway</title>
    <url>/2022/07/15/Framework/Java/Spring-Cloud/Spring-Cloud-Gateway/</url>
    <content><![CDATA[Spring Cloud Gateway1. How to Include Spring Cloud Gateway&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt;

如果你包含了 starter，但是你不想启用网关，则可以设置 spring.cloud.gateway.enabled=false
2. Glossary
Route: 网关的基本构建。它由 ID，目标 URI，谓词集合，以及过滤器集合定义。如果聚合谓词为 true，则匹配路由。
Predicate: 这是 Java 8 Function Predicate。输入类型是 Spring Framework ServerWebExchange。这使你可以匹配来自 HTTP 请求中的任何东西，例如 Header 或者参数。
Filter: 这些是一些 GatewayFilter 实例，它们由特定的工厂构建出来。在这里，你可以在发送下游请求之前或之后修改请求和响应。

4. Configuring Route Predicate Factories and Gateway Filter Factories配置谓词和过滤器有两种方式：快捷方式和完全扩展参数。下面大多数示例都是用快捷方式。
4.1. Shortcut Configuration快捷方式配置由过滤器名称识别，跟着一个等号（=），后面跟着由逗号（,）分割的参数值。
application.yml
spring:  cloud:    gateway:      routes:      - id: after_route        uri: https://example.org        predicates:        - Cookie=mycookie,mycookievalue
上面的样例定义了具有两个参数的 Cookie 路由谓词工厂，参数分别是，cookie name mycookie，以及要匹配 mycookievalue 的值。
5. Route Predicate FactoriesSpring Cloud Gateway 包含许多内置的路由谓词工厂，所有这些谓词匹配不同的 HTTP 请求属性
5.1. The After Route Predicate FactoryAfter 路由谓词工厂携带一个参数，即一个 datetime（其实是 Java 的 ZonedDateTime）。该谓词匹配发生在指定时间之后的请求。
spring:  cloud:    gateway:      routes:      - id: after_route        uri: http://www.baidu.com        predicates:          - After=2021-06-03T10:00:00.000+08:00


5.2. The Before Route Predicate FactoryBefore 路由谓词工厂携带一个参数，即一个 datetime（其实是 Java 的 ZonedDateTime）。该谓词匹配发生在指定时间之前的请求。
spring:  cloud:    gateway:      routes:      - id: before_route        uri: http://www.baidu.com        predicates:          - Before=2021-06-03T10:00:00.000+08:00

5.3. The Between Route Predicate FactoryBetween 路由谓词工厂携带两个参数，datetime1 和 datetime2，他们都是 Java 的 ZonedDateTime 对象。该谓词匹配发生在 datetime1 之后，以及 datetime2 之前的请求。datetime2 参数必须在 datetime1 之后。
spring:  cloud:    gateway:      routes:      - id: method_route        uri: http://www.baidu.com        predicates:          - Between=2017-01-20T17:42:47.789-07:00[America/Denver], 2017-01-21T17:42:47.789-07:00[America/Denver]

5.4. The Cookie Route Predicate FactoryCookie 路由谓词工厂携带两个参数，name 和 regexp（本质是 Java 的正则表达式）。该谓词匹配具有给定名称，并且值匹配正则表达式的 cookie。
spring:  cloud:    gateway:      routes:        - id: method_route          uri: https://www.baidu.com          predicates:            - Cookie=x-token, \w+

5.5. The Header Route Predicate FactoryHeader 路由谓词工厂携带两个参数，name 和 regexp（本质是 Java 的正则表达式）。该谓词匹配具有给定名称，并且值匹配正则表达式的 header。
spring:  cloud:    gateway:      routes:        - id: method_route          uri: http://www.baidu.com          predicates:            - Header=X-Request-Id, \d+


5.6. The Host Route Predicate FactoryHeader 路由谓词工厂携带一个参数：主机名 patterns 列表。模式是一种 Ant 风格的带有 . 作为分隔符的模式。该谓词匹配模式中的的 Host 头部。
spring:  cloud:    gateway:      routes:        - id: method_route          uri: http://www.baidu.com          predicates:            - Header=X-Request-Id, \d+


消息头部的字段名是大小写不敏感的，也就是头部 X-Request-Id，也可以传递 x-request-idRFC 2616 https://www.rfc-editor.org/rfc/inline-errata/rfc2616.html，查询 (“:”) 关键字附近文字可以找到：Field names are case-insensitive.

5.7. The Method Route Predicate FactoryMethod 路由谓词工厂携带一个参数 methods，该参数是一个或者多个参数：待匹配的 HTTP 方法。
spring:  cloud:    gateway:      routes:      - id: method_route        uri: http://www.baidu.com        predicates:          - Method=GET,POST

5.8. The Path Route Predicate Factoryspring:  cloud:    gateway:      routes:        - id: method_route          uri: http://localhost:8080          predicates:            - Path=/echo/&#123;segment&#125;


5.9. The Query Route Predicate FactoryQuery 路由谓词工厂携带两个参数，一个必需的 param 和一个可选的 regexp（本质是 Java 的正则表达式）。
spring:  cloud:    gateway:      routes:        - id: method_route          uri: https://www.baidu.com          predicates:            - Query=id

5.10. The RemoteAddr Route Predicate FactoryRemoteAddr 路由谓词工厂携带一个 sources 列表，这是 CIDR 符号字符串，例如 192.168.0.1/16，此处 192.168.0.1 是 IP 地址，16 是子网掩码。
spring:  cloud:    gateway:      routes:      - id: remoteaddr_route        uri: http://www.baidu.com        predicates:          - RemoteAddr=192.168.0.187/24]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Netflix</title>
    <url>/2022/07/12/Framework/Java/Spring-Cloud/Spring-Cloud-Netflix/</url>
    <content><![CDATA[Spring Cloud Netflix1. Service Discovery: Eureka Clients服务发现是微服务架构的关键原则之一。手工配置每个客户端或基于某种约定是非常脆弱的。Eureka 是 Netflix 服务发现服务端和客户端。服务可以被配置和部署，变得高可用，每个服务都会复制其他已经注册服务的状态。
1.1. How to Include Eureka Client&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;

1.2. Registering with Eureka当 Eureka Client 注册 Eureka Server 时，它会提供自己的元数据，比如：主机，端口，健康指示器 URL，主页等详细信息。Eureka Server 接收属于某个服务的每个实例的心跳消息。如果心跳在可配置的时间表上失败，则通常从注册表中删除实例。
以下实例展示了最小的 Eureka Client 应用：
@SpringBootApplication@RestControllerpublic class Application &#123;    @RequestMapping(&quot;/&quot;)    public String home() &#123;        return &quot;Hello world&quot;;    &#125;    public static void main(String[] args) &#123;        new SpringApplicationBuilder(Application.class).web(true).run(args);    &#125;&#125;


请注意，前面的示例展示了一个普通的 Spring Boot 应用。通过包含 spring-cloud-starter-netflix-eureka-client 于类路径，你的应用会自动注册到 Eureka Server。需要配置的就是定位 Eureka Server，如下示例所示：
eureka:  client:    serviceUrl:      defaultZone: http://localhost:8761/eureka/

在前面的示例中，defaultZone 是一个魔术字符串备用值，它为任何没有表示首选项的客户端提供服务 URL（换句话说，这是一个有用的默认值）。

defaultZone 属性是大小写敏感，并且需要驼峰格式，因为 serviceUrl 属性是一个 Map&lt;String, String&gt;。因此，defaultZone 属性不遵循通常的 Spring Boot 蛇形约定 default-zone。

默认的应用名（即，服务 ID），虚拟机主机名，以及非安全端口（从 Environment 中获取）分别是 $&#123;spring.application.name&#125;，$&#123;spring.application.name&#125;，以及 $&#123;server.port&#125;。
1.3. Authenticating with the Eureka Server如果 eureka.client.serviceUrl.defaultZone 之一有凭证嵌入其中，则会自动把 HTTP basic 认证添加到 eureka 客户端。
注意 这里并不是给 URL 添加凭证，只是激活 HTTP basic 用于请求的认证。
1.4. Status Page and Health Indicator1.5. Registering a Secure Application如果你的应用希望通过 HTTPS 连接，你可以在 EurekaInstanceConfig 设置两个标记：

eureka.instance.[nonSecurePortEnabled]=[false]
eureka.instance.[securePortEnabled]=[true]

1.6. Eureka’s Health Checks1.7. Eureka Metadata for Instances and Clients1.7.1. Using Eureka on Cloud Foundry1.7.2. Using Eureka on AWS如果你计划将应用程序部署到 AWS 云上，则必须将 Eureka 实例配置为 AWS-aware。你可以通过自定义 EurekaInstanceConfigBean 来做到这一点，如下所示：
@Bean@Profile(&quot;!default&quot;)public EurekaInstanceConfigBean eurekaInstanceConfig(InetUtils inetUtils) &#123;  EurekaInstanceConfigBean b = new EurekaInstanceConfigBean(inetUtils);  AmazonInfo info = AmazonInfo.Builder.newBuilder().autoBuild(&quot;eureka&quot;);  b.setDataCenterInfo(info);  return b;&#125;

1.7.3. Changing the Eureka Instance ID一般地，NetFlix Eureka 实例以 host name 注册为其主机名。Spring Cloud Eureka 提供了一个明确的默认值：
$&#123;spring.cloud.client.hostname&#125;:$&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;server.port&#125;&#125;
例如：myhost:myappname:8080
在 Spring Cloud 中，你可以通过提供唯一标识符 eureka.instance.instanceId 来覆盖该值：
eureka:  instance:    instanceId: $&#123;spring.application.name&#125;:$&#123;vcap.application.instance_id:$&#123;spring.application.instance_id:$&#123;random.value&#125;&#125;&#125;

1.8. Using the EurekaClient一旦你拥有一个发现客户端的应用程序，你可以使用它从 Eureka Server 发现服务实例。这样做的一种方法是使用本地 com.netflix.discovery.EurekaClient
1.9. Alternatives to the Native Netflix EurekaClient你无需使用原生的 NetFlix 的 EurekaClient。而且，在某种形式的包装之后通常会更容易使用它。通过逻辑 eureka 服务标识符（VIPs）而不是物理 URL，Spring Cloud 支持 Feign（一个 REST 客户端构建器）以及 Spring RestTemplate。
1.10. Why Is It so Slow to Register a Service?作为一个实例，还涉及到向注册中心（通过 client 的 serviceUrl）的定期心跳，默认时间为 30 秒。一个服务，直到该实例，注册中心，客户端缓存中都有相同的元数据（因此需要 3 个心跳），客户端才能发现其不可用。你可以通过设置 eureka.instance.leaseRenewalIntervalInSeconds 来更改周期。将其设置为小于 30 的值，可以加快客户端连接到其他服务的进程。在生产中，由于注册中心的内部计算对租赁续期做了假设，因此最好坚持使用默认值。
2. Service Discovery: Eureka Server参考配置
2.1. How to Include Eureka Server要在你的项目中包含 Eureka Server，请使用 group ID 为 org.springframework.cloud 以及 artifact ID 为 spring-cloud-starter-netflix-eureka-server 的 starter。参见 Spring Cloud Project page
2.2. How to Run a Eureka Server服务端有一个主页和 HTTP API （在 &#x2F;eureka&#x2F;* 下）。
&amp;nbsp;
2.3. High Availability, Zones and RegionsEureka 服务端并没有后端存储，但是注册表中的服务实例都必须发送心跳，来保持它们的注册最新（这可以在内存中完成）。客户端还有一个内存中的 Eureka 注册缓存，因此对于每个服务的请求，不必跳转到注册表。
默认情况下，每个 Eureka 服务端也是 Eureka 客户端，至少需要一个服务 URL 来定位对等体。如果没有提供服务 URL，服务跑起来并开始工作，就会填充大量的噪音到日志中（无法与对等体注册的异常）。
&amp;nbsp;
2.4. Standalone Mode双缓存和心跳机制，两者组合可以让独立 Eureka Server 对于失败具有相当的弹性，只要有某种监视器或者弹性的运行时间保持存活。在独立模式下，你可能更希望关闭客户端行为，避免不断尝试并无法达到对等体的错误。
server:  port: 8761eureka:  instance:    hostname: localhost  client:    registerWithEureka: false    fetchRegistry: false    serviceUrl:      defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/

注意 serviceUrl 需要指向本地实例相同的主机。
2.5. Peer Awareness通过运行多个实例，并让他们互相注册，eureka 可以变得更具有弹性和可用性。实际上，这是默认的行为，所以你只需要向对等体添加有效的 serviceUrl 即可。
为了在单个主机上体验对等感知，可以操作 /etc/hosts 文件来解析主机名。实际上，如果运行在一台已知主机名的机器上时，没有必要配置 eureka.instance.hostname。默认地，会使用 java.net.InetAddress 寻找。
你可以向一个系统添加多个对等体，只要它们通过至少边缘彼此连接，它们之间就会同步注册信息。如果对等体物理分离，那么系统原则上存在脑裂的问题。
2.6. When to Prefer IP Address在某些情况下，eureka 更偏向于建议使用服务的 IP 而不是主机名。设置 eureka.instance.preferIpAddress 为 true，那么当应用注册到 eureka 时，将会使用 IP 地址而不是主机名。

如果 Java 无法确定 hostname，那么就会发送 IP 地址给 eureka。

2.8. Disabling Ribbon with Eureka Server and Client startersspring-cloud-starter-netflix-eureka-server 和 spring-cloud-starter-netflix-eureka-client y与 spring-cloud-starter-netflix-ribbon 一起出现。由于 Ribbon 负载均衡处于维护模式，因此我们建议切换使用 Spring Cloud LoadBalancer，也包含在 Eureka starter 中。
为此，你可以将 spring.cloud.loadbalancer.ribbon.enabled 属性设置为 false。
然后，你还可以从构建文件中地 Eureka starter 中排除 ribbon 相关的依赖，像这样：
&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;        &lt;/exclusion&gt;        &lt;exclusion&gt;            &lt;groupId&gt;com.netflix.ribbon&lt;/groupId&gt;            &lt;artifactId&gt;ribbon-eureka&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;

3. Circuit Breaker: Spring Cloud Circuit Breaker With Hystrix3.1. Disabling Spring Cloud Circuit Breaker Hystrix你可以通过设置 spring.cloud.circuitbreaker.hystrix.enabled 为 false 来禁用自动配置。
spring.cloud.circuitbreaker.hystrix.enabled=false

3.2. Configuring Hystrix Circuit Breakers3.2.1. Default Configuration为了给您所有的断路器提供默认配置，请创建传递一个 HystrixCircuitBreakerFactory 或者 ReactiveHystrixCircuitBreakerFactory 的 Customize Bean。configureDefault 方法可用于提供默认配置。
@Beanpublic Customizer&lt;HystrixCircuitBreakerFactory&gt; defaultConfig() &#123;    return factory -&gt; factory.configureDefault(id -&gt; HystrixCommand.Setter            .withGroupKey(HystrixCommandGroupKey.Factory.asKey(id))            .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()            .withExecutionTimeoutInMilliseconds(4000)));&#125;

Reactive Example@Beanpublic Customizer&lt;ReactiveHystrixCircuitBreakerFactory&gt; defaultConfig() &#123;    return factory -&gt; factory.configureDefault(id -&gt; HystrixObservableCommand.Setter            .withGroupKey(HystrixCommandGroupKey.Factory.asKey(id))            .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()                    .withExecutionTimeoutInMilliseconds(4000)));&#125;

3.2.2. Specific Circuit Breaker Configuration类似于提供默认配置，您可以传递一个 HystrixCircuitBreakerFactory 创建一个 Customize Bean。
@Beanpublic Customizer&lt;HystrixCircuitBreakerFactory&gt; customizer() &#123;    return factory -&gt; factory.configure(builder -&gt; builder.commandProperties(                    HystrixCommandProperties.Setter().withExecutionTimeoutInMilliseconds(2000)), &quot;foo&quot;, &quot;bar&quot;);&#125;

Reactive Example@Beanpublic Customizer&lt;ReactiveHystrixCircuitBreakerFactory&gt; customizer() &#123;    return factory -&gt; factory.configure(builder -&gt; builder.commandProperties(                    HystrixCommandProperties.Setter().withExecutionTimeoutInMilliseconds(2000)), &quot;foo&quot;, &quot;bar&quot;);&#125;

4. Circuit Breaker: Hystrix ClientsNetflix 已经创建了一个名为 Hystrix 的库，该库实现了 circuit breaker pattern（熔断器模式）。在微服务体系结构中，通常具有多层服务调用，如下示例所示：


Figure 1. Microservice Graph
较低级别的服务失败可能导致级联失败，直至用户。当对特定服务调用超过 circuitBreaker.requestVolumeThreshold（默认是 20 次请求），并且，在一个由 metrics.rollingStats.timeInMilliseconds 定义滑动窗口（默认为 10 秒）内，失败百分比大于 circuitBreaker.errorThresholdPercentage（默认 &gt;50%）， 熔断器会打开，并且不进行调用。在出错并且熔断器打开的情况下，开发者可以提供一个 fallback。


Figure 2. Hystrix fallback prevents cascading failures
4.1. How to Include Hystrix若要在你的项目中包含 Hystrix，请使用 group ID 为 org.springframework.cloud，artifact ID 为 spring-cloud-starter-netflix-hystrix 的 starter。
下面示例展示了一个极简的带有 Hystrix 熔断器的 Eureka 服务：
@SpringBootApplication@EnableCircuitBreakerpublic class Application &#123;    public static void main(String[] args) &#123;        new SpringApplicationBuilder(Application.class).web(true).run(args);    &#125;&#125;@Componentpublic class StoreIntegration &#123;    @HystrixCommand(fallbackMethod = &quot;defaultStores&quot;)    public Object getStores(Map&lt;String, Object&gt; parameters) &#123;        //do stuff that might fail    &#125;    public Object defaultStores(Map&lt;String, Object&gt; parameters) &#123;        return /* something useful */;    &#125;&#125;


@HystrixCommand 由名为 “javanica” 的 Netflix contrib 库提供。Spring Cloud 以代理的方式包装具有该注解的 Spring Bean，用于连接到 Hystrix 熔断器。熔断器计算何时打开和关闭回路，以及在失败的情况下做什么。
要配置 @HystrixCommand，你可以以 @HystrixProperty 注解列表的形式使用 commandProperties 属性。有关更多详情，请参见此处。有关可用属性的详细信息，参见 Hystrix wiki
4.2. Propagating the Security Context or Using Spring Scopes如果你希望一些线程的本地上下文传播到 @HystrixCommand，默认声明并不起作用，因为它在线程池中执行命令（在超时情况下）。你可以通过配置或者直接在注解上，请求 Hystrix 使用不同的 “Isolation Strategy”，切换 Hystrix 使用相同的线程作为调用者。以下示例演示了在注解中设置线程：
@HystrixCommand(fallbackMethod = &quot;stubMyService&quot;,    commandProperties = &#123;      @HystrixProperty(name=&quot;execution.isolation.strategy&quot;, value=&quot;SEMAPHORE&quot;)    &#125;)...

4.3. Health Indicator连接熔断器的状态也可以暴露在调用应用的 /health 端点上，如下示例所示：
&#123;    &quot;hystrix&quot;: &#123;        &quot;openCircuitBreakers&quot;: [            &quot;StoreIntegration::getStoresByLocationLink&quot;        ],        &quot;status&quot;: &quot;CIRCUIT_OPEN&quot;    &#125;,    &quot;status&quot;: &quot;UP&quot;&#125;

4.4. Hystrix Metrics Stream若要启动 Hystrix metrics stream，请包含关于 spring-boot-starter-actuator 的依赖，并设置 management.endpoints.web.exposure.include=hystrix.stream。这样做会暴露 /actuator/hystrix.stream 作为管理端点，如下示例所示：
&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;

5. Circuit Breaker: Hystrix Dashboard只需要引入以下依赖即可：
&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt;

配置类添加以下注解：
@EnableHystrixDashboard


6. Hystrix Timeouts And Ribbon Clients当使用 Hystrix command 包装你希望的 Ribbon 客户端时，确保你的 Hystrix 配置的 timeout 比 Ribbon 配置的 timeout 更长，包括任何可能的重试。例如，如果你的 Ribbon 连接 timeout 是 1 秒，并且 Ribbon 客户端可能重试请求 3 次，那么你的 Hystrix 超时时间应该略高于 3 秒。

作者的话 如果上述示例配置低于 3 秒，那么 Ribbon 可能还未完成 3 次重试就已经结束，并不满足配置预期。

6.1. How to Include the Hystrix Dashboard若要在你的项目包含 Hystrix Dashboard，请使用 group ID 为 org.springframework.cloud，artifact ID 为 spring-cloud-starter-netflix-hystrix-dashboard 的 starter。
若要运行 Hystrix Dashboard，请使用 @EnableHystrixDashboard 注解你的 Spring Boot 主类。然后访问 /hystrix，并将 dashboard 指向一个实例在 Hystrix 客户端应用中的 /hystrix.stream 端点。
7. Client Side Load Balancer: RibbonRibbon 是一个客户端的负载均衡，可以对 HTTP 和 TCP 客户端行为进行大量控制。Feign 已经使用了 Ribbon，因此，如果你使用 @FeignClient，这部分也会使用。

Ribbon 是一个进程内 LB

Ribbon 的核心概念是有名客户端。每个负载均衡器都是组件集合的一部分，组件们在一起工作，按需要连接到远程服务器，并且整体有一个名字，这是你作为开发者赋予的名字。根据需要，Spring Cloud 通过使用 RibbonClientConfiguration 以 ApplicationContext 为每个有名客户端创建一个新的整体。这包含一个 ILoadBalancer，一个 RestClient，以及一个 ServerListFiter。
7.1. How to Include Ribbon要在你的项目使用 ribbon，请使用 group ID 为 org.springframework.cloud，artifact ID 为 spring-cloud-starter-netflix-ribbon 的 starter。有关使用当前 Spring Cloud Release Train 设置你的构建系统详情见 Spring Cloud Project page

如果你依赖了 eureka，则 ribbon 也会同时引入，无需显式引入

7.2. Customizing the Ribbon Client你可以通过使用 &lt;client&gt;.ribbon.* 之中的外部属性配置 Ribbon 客户端的一些部分，这类似于使用原生的 Netflix API，但你可以使用 Spring Boot 配置文件。原生选项可以在 CommonClientConfigKey  （ribbon-core 的一部分）以静态字段查看。
Spring Cloud 还让你通过使用 @RibbonClient 声明额外配置（除了 RibbonClientConfiguration）来完全控制客户端，如下所示：
@Configuration@RibbonClient(name = &quot;custom&quot;, configuration = CustomConfiguration.class)public class TestConfiguration &#123;&#125;

在这个案例中，客户端由已经存在于 RibbonClientConfiguration 的组件，以及在 CustomConfiguration （后者通常覆盖前者）中的一些组成。

CustomConfiguration 类必须是 @Configuration 类，但是注意，不要放在主应用上下文的 @ComponentScan 中。否则，它将被所有的 @RibbonClients 共享。如果你使用 @ComponentScan（或者 @SpringBootApplication），你需要采取一些方法以避免将其包括在内（例如，你可以将其放入分开的，不重叠的包中，或者在 @ComponentScan 中指定要明确扫描的包）。

7.3. Customizing the Default for All Ribbon Clients可以通过使用 @RibbonClients 注解，注册一个默认的配置，为所有的 Ribbon 客户端提供默认配置，如下示例所示：
@RibbonClients(defaultConfiguration = DefaultRibbonConfig.class)public class RibbonClientDefaultConfigurationTestsConfig &#123;    public static class BazServiceList extends ConfigurationBasedServerList &#123;        public BazServiceList(IClientConfig config) &#123;            super.initWithNiwsConfig(config);        &#125;    &#125;&#125;@Configuration(proxyBeanMethods = false)class DefaultRibbonConfig &#123;    @Bean    public IRule ribbonRule() &#123;        return new BestAvailableRule();    &#125;    @Bean    public IPing ribbonPing() &#123;        return new PingUrl();    &#125;    @Bean    public ServerList&lt;Server&gt; ribbonServerList(IClientConfig config) &#123;        return new RibbonClientDefaultConfigurationTestsConfig.BazServiceList(config);    &#125;    @Bean    public ServerListSubsetFilter serverListFilter() &#123;        ServerListSubsetFilter filter = new ServerListSubsetFilter();        return filter;    &#125;&#125;

7.4. Customizing the Ribbon Client by Setting Properties从 1.2.0 开始，Spring Cloud Netflix 现在支持通过设置兼容 Ribbon documentation 属性来定制化 Ribbon 客户端。
这使你可以在不同环境中更改启动时行为。
下面的列表展示了支持的属性：

&lt;clientName&gt;.ribbon.NFLoadBalancerClassName：应该实现了 ILoadBalancer
&lt;clientName&gt;.ribbon.NFLoadBalancerRuleClassName：应该实现了 IRule
&lt;clientName&gt;.ribbon.NFLoadBalancerPingClassName：应该实现了 IPing
&lt;clientName&gt;.ribbon.NIWSServerListClassName：应该实现了 ServerList
&lt;clientName&gt;.ribbon.NIWSServerListFilterClassName：应该实现了 ServerListFilter


这些属性中定义的类，相较于使用 @RibbonClient(configuration=MyRibbonConfig.class) 定义的 Bean，以及由 Spring Cloud Netflix 提供的默认值，具有更高优先级

要设置名为 users 的服务名的 IRule
7.6. Example: How to Use Ribbon Without EurekaEureka 是一种便捷的方式，它抽象化远程服务的发现，因此你不必在客户端中进行硬编码。但是，如果你不想使用 Eureka，Ribbon 和 Feign 也可以工作。假设你已经声明了 “stores” 的 @RibbonClient，并且 Eureka 没有使用（甚至不在类路径）。Ribbon 客户端默认到配置好的服务列表。你可以按如下方式提供配置：
application.yml
stores:  ribbon:    listOfServers: example.com,google.com

7.7. Example: Disable Eureka Use in Ribbon将 ribbon.eureka.enabled 属性设置为 false，显式地禁用 Ribbon 中 Eureka 的使用，如下示例所示：
application.yml
ribbon:  eureka:   enabled: false


7.8. Using the Ribbon API Directly你也可以直接使用 LoadBalanceClient，如下示例所示：
public class MyClass &#123;    @Autowired    private LoadBalancerClient loadBalancer;    public void doStuff() &#123;        ServiceInstance instance = loadBalancer.choose(&quot;stores&quot;);        URI storesUri = URI.create(String.format(&quot;https://%s:%s&quot;, instance.getHost(), instance.getPort()));        // ... do something with the URI    &#125;&#125;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Netflix</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud OpenFeign</title>
    <url>/2022/07/13/Framework/Java/Spring-Cloud/Spring-Cloud-OpenFeign/</url>
    <content><![CDATA[Spring Cloud OpenFeign1. Declarative REST Client: FeignFeign 是一个声明式 Web 服务客户端。它使得编写 Web 服务客户端更容易。使用 Feign 创建一个接口并注解它。它具有可插入的注解支持，包括 Feign 注解和 JAX-RS 注解。Feign 还支持可插拔的编码器和解码器。Spring Cloud 增加了对 Spring MVC 注解的支持，以及支持使用 Spring Web 中默认项相同的 HttpMessageConverters。Spring Cloud 集成了 Ribbon 以及 Eureka，Spring Cloud CiruitBreaker，以及 Spring Cloud LoadBalancer，以便在使用 Feign 时提供负载均衡的 HTTP 客户端。
1.1. How to Include Feign要在项目中包含 Feign，请使用 group 为 org.springframework.cloud，artifact id 为 spring-cloud-starter-openfeign 的 starter。有关使用当前 Spring Cloud Release Train 设置你的构建系统的详情，参见 Spring Cloud Project page
示例 Spring Boot 应用：
@SpringBootApplication@EnableFeignClientspublic class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class, args);    &#125;&#125;

StoreClient.java
@FeignClient(&quot;stores&quot;)public interface StoreClient &#123;    @RequestMapping(method = RequestMethod.GET, value = &quot;/stores&quot;)    List&lt;Store&gt; getStores();    @RequestMapping(method = RequestMethod.GET, value = &quot;/stores&quot;)    Page&lt;Store&gt; getStores(Pageable pageable);    @RequestMapping(method = RequestMethod.POST, value = &quot;/stores/&#123;storeId&#125;&quot;, consumes = &quot;application/json&quot;)    Store update(@PathVariable(&quot;storeId&quot;) Long storeId, Store store);&#125;

在 @FeignClient 注解中，字符串 value（即上面的 “stores”）是一个任意的 client name，用于创建一个 Ribbon 负载均衡或者 Spring Cloud LoadBalancer。你还可以使用 url 属性（绝对值或者一个主机名）指定一个 URL。应用上下文中 Bean 的名称是接口的完全限定名。为了指定你自己的别名，你可以使用 @FeignClient 注解的 qualifiers 值。
上面的负载均衡客户端将会希望发现 “stores” 服务的物理地址。如果你的应用是 Eureka 客户端，则它将在 Eureka 服务注册表中解析该服务。如果你不想使用 Eureka，则可以使用 SimpleDiscoveryClient 在外部配置中简单地配置服务器列表。
1.2. Overriding Feign DefaultsSpring Cloud 的 Feign 支持中的一个核心概念就是有名客户端。每个 Feign 客户端都是一群组件的部分，它们共同协作按需与远程服务进行连接，并且这个整体有一个你作为开发者使用 @FeignClient 注解赋予的名字。Spring Cloud 使用 FeignClientsConfiguration 为每个有名客户端按需地，以 ApplicationContext 的形式创建一个全新的整体。这包含一个 feign.Decoder，一个 feign.Encoder，以及一个 feign.Contract。可以使用 @FeignClient 注解的 contextId 属性覆盖该整体的名称。
Spring Cloud 使你可以使用 @FeignClient 声明额外的配置（覆盖 FeignClientsConfiguration）完全控制 feign 客户端。
示例：
@FeignClient(name = &quot;stores&quot;, configuration = FooConfiguration.class)public interface StoreClient &#123;    //..&#125;

在这种情况下，客户端是由已经存在于 FeignClientsConfiguration 中的组件，以及 FooConfiguration （后者覆盖前者）中的种种组成。

FooConfiguration 不需要 @Configuration 注解。但是，如果这样做，请将其从任何 @ComponentScan 中排除，否则将包含此配置，因为它将将成为 feign.Decoder，feign.Encoder，feign.Contract 等默认源。

name 和 url 属性也支持占位符。
1.2.1. SpringEncoder configuration在我们提供的 SpringEncoder 中，我们为二进制内容类型设置了 null 字符集，并未所有其他的设置了 UTF-8。
你可以通过设置 feign.encoder.charset-from-content-type 的值为 true来修改此行为，以从 Content-Type 头部 charset 获得字符集。
1.3. Timeout Handling我们可以在默认和有名客户端上配置超时。OpenFeign 可与两个超时参数一起使用：

connectTime
readTimeout

1.5. Feign Hystrix Support如果 Hystrix 在类路径，并且 feign.hystrix.enabled=true，Feign 将用熔断器包装所有方法。还提供返回一个 com.netflix.hystrix.HystrixCommand。这使你可以使用响应式模式。
1.6. Feign Hystrix Fallbacks1.10. Feign Inheritance SupportFeign 通过单继承接口支持样板 API。这允许你将通用操作分组为方便的基础接口。
UserService.java
public interface UserService &#123;    @RequestMapping(method = RequestMethod.GET, value =&quot;/users/&#123;id&#125;&quot;)    User getUser(@PathVariable(&quot;id&quot;) long id);&#125;

UserResource.java
@RestControllerpublic class UserResource implements UserService &#123;&#125;

UserClient.java
package project.user;@FeignClient(&quot;users&quot;)public interface UserClient extends UserService &#123;&#125;

1.3. Timeout Handling我们可以在默认和有名客户端上配置 timeout 属性。OpenFeign 用这两个 timeout 参数进行工作：

connectTimeout 防止由于较长的服务端处理时间导致的阻塞。
readTimeout 在连接建立的时候使用，并且当返回响应花费太久的时候会触发


如果服务没有运行或者不可用，数据包可能以连接被拒绝结束。通信以错误信息或者后背方式结束。如果 connectTimeout 设置非常低，这就有可能在 connectTimeout 之前就结束通信。执行查找以及接收这样的数据包的时间可能会产生较大一部分延迟。可以基于涉及到 DNS 查找的远程主机修改该值。

当启用 Hystrix 后，超时配置默认是 1000 毫秒。因此，它可能发生在我们前面配置的客户端超时之前。增加该超时，防止发生这种情况。
feign:  client:    config:      default:        connectTimeout: 5000        readTimeout: 5000  hystrix:    enabled: truehystrix:  command:    default:      execution:        timeout:          enabled: true        isolation:          thread:            timeoutInMilliseconds: 60000


当启用 Hystrix 的 timeout 且它的 timeout 设置得比 feign client 更长时，HystrixTimeoutException 会包装一个 feign 异常。否则，唯一的区别就是异常的原因。HystrixTimeoutException 的目的是包装先发生的任何运行时异常，并抛出自身实例。

1.5. Feign Hystrix Support如果 Hystrix 在类路径中，且 feign.hystrix.enabled=true，Feign 将使用熔断器包装所有的方法。还可以返回一个 HystrixCommand。
1.12. Feign logging为每个 Feign 客户端创建了一个 logger。默认情况下，logger 的名字是用于创建 Feign 客户端的接口的完全限定类名。Feign 日志仅仅响应 DEBUG 级别。
application.yml
logging.level.project.user.UserClient: DEBUG

你可以为每个客户端配置的 Logger.Level 对象，告诉 Feign 多少要记录。选项如下：

NONE，不记录日志（DEFAULT）
BASIC，仅仅记录请求方法，URL，响应状态码，以及执行时间
HEADERS，记录基本信息，以及请求头和响应头
FULL，记录来自请求或响应的头部

1.13. Feign @QueryMap support]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>OpenFeign</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring CORS 配置</title>
    <url>/2022/09/19/Framework/Java/Spring-Framework/Spring-CORS-%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[@Configuration //加配置注解可以扫描到public class WebConfig implements WebMvcConfigurer&#123;         //跨域请求配置    @Override    public void addCorsMappings(CorsRegistry registry) &#123;        WebMvcConfigurer.super.addCorsMappings(registry);        registry.addMapping(&quot;/**&quot;)// 对接口配置跨域设置                .allowedHeaders(&quot;*&quot;)// 允许任何头                .allowedMethods(&quot;POST&quot;,&quot;GET&quot;)// 允许方法（post、get等）                .allowedOrigins(&quot;*&quot;)// 允许任何域名使用                .allowCredentials(true);    &#125;     &#125;]]></content>
  </entry>
  <entry>
    <title>AbstractContext refresh 方法流程</title>
    <url>/2022/07/22/Framework/Java/Spring-Framework/AbstractContext-refresh-%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[AbstractContext refresh 方法流程1. refresh 总体流程IoC 容器刷新的方法是由 AbstractApplicationContext.refresh 实现，方法如下: 
public void refresh() throws BeansException, IllegalStateException &#123;    synchronized (this.startupShutdownMonitor) &#123;        // 1. 为 refresh 准备上下文（与 finish 相对）        prepareRefresh();        // Tell the subclass to refresh the internal bean factory.        // 2. 通知子类，refresh 其内部的 beanFactory        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();        // Prepare the bean factory for use in this context.        // 3. 准备 Bean Factory        prepareBeanFactory(beanFactory);        try &#123;            // Allows post-processing of the bean factory in context subclasses.            // 4. 在 Context 的子类中可以后置处理 Bean Factory            postProcessBeanFactory(beanFactory);            // Invoke factory processors registered as beans in the context.            // 5. 调用以 Bean 形式注册在 Context 中的 BeanFactoryPostProcessor            // 官方这句注释有些不准确，因为其中会调用 AbstractContext 内部的几个 internal BeanFactoryPostProcessor            invokeBeanFactoryPostProcessors(beanFactory);            // Register bean processors that intercept bean creation.            // 6. 注册 bean post processor            registerBeanPostProcessors(beanFactory);            // Initialize message source for this context.            // 7. 为 context 初始化消息资源            initMessageSource();            // Initialize event multicaster for this context.            // 8. 为 Context 初始化时间多播器            initApplicationEventMulticaster();            // Initialize other special beans in specific context subclasses.            // 9. 在特定的 context 子类中初始化其他的特殊 bean            onRefresh();            // Check for listener beans and register them.            // 10. 检查 Listener Bean 并注册            registerListeners();            // Instantiate all remaining (non-lazy-init) singletons.            // 11. 实例化所有剩下来的单例            finishBeanFactoryInitialization(beanFactory);            // Last step: publish corresponding event.            // 12. 最后一步：发布相关事件            finishRefresh();        &#125;        catch (BeansException ex) &#123;            if (logger.isWarnEnabled()) &#123;                logger.warn(&quot;Exception encountered during context initialization - &quot; +                        &quot;cancelling refresh attempt: &quot; + ex);            &#125;            // Destroy already created singletons to avoid dangling resources.            destroyBeans();            // Reset &#x27;active&#x27; flag.            cancelRefresh(ex);            // Propagate exception to caller.            throw ex;        &#125;        finally &#123;            // Reset common introspection caches in Spring&#x27;s core, since we            // might not ever need metadata for singleton beans anymore...            resetCommonCaches();        &#125;    &#125;&#125;
2. refresh 步骤2.1. prepareRefresh该方法执行的是 refresh 之前的预处理操作
protected void prepareRefresh() &#123;    // 1. 设置值、状态    this.startupDate = System.currentTimeMillis(); // 记录启动时间为当前时间    this.closed.set(false); // 记录关闭状态为 false    this.active.set(true); // 记录启动状态为 true    if (logger.isInfoEnabled()) &#123;        logger.info(&quot;Refreshing &quot; + this);    &#125;    // 2. 初始化属性资源的空方法，留给子类覆盖    // 在上下文环境中初始化一些占位符属性资源    // 该方法 AbstractApplicationContext 是一个空实现，留给子类去自定义实现    initPropertySources();    // 3. 创建并获取 Environment 对象，验证需要的属性文件    // 验证被标记为 required 的属性    // see ConfigurablePropertyResolver#setRequiredProperties    getEnvironment().validateRequiredProperties();    // 4. 早期事件的集合    // 一旦多转换器可用，就发布    this.earlyApplicationEvents = new LinkedHashSet&lt;&gt;();&#125;

如果是 Web 环境，会覆盖这种行为：
protected void prepareRefresh() &#123;    // 清除缓存    this.scanner.clearCache();    super.prepareRefresh();&#125;

2.1. obtainFreshBeanFactory通知子类，refresh 其内部的 beanFactory
protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;    // 该方法是个抽象类，由子类实现    // 1. 对于 GenericApplicationContext，仅仅是设置了一个序列化 ID    refreshBeanFactory();    // 该方法是个抽象类，有子类实现    // 2. 对于 GenericApplicationContext，将内部的 DefaultListableBeanFactory 返回    return getBeanFactory();&#125;

如果子类是 GenericApplicationContext，实现的代码清单如下：
protected final void refreshBeanFactory() throws IllegalStateException &#123;    // 设置刷新标记    if (!this.refreshed.compareAndSet(false, true)) &#123;        throw new IllegalStateException(                &quot;GenericApplicationContext does not support multiple refresh attempts: just call &#x27;refresh&#x27; once&quot;);    &#125;    // 设置一个序列 ID    this.beanFactory.setSerializationId(getId());&#125;


AbstractApplicationContext
AbstractRefreshableApplicationContext
AbstractXmlApplicationContext
ClassPathXmlApplicationContext
FileSystemXmlApplicationContext




GenericApplicationContext
ServletWebServerApplicationContext





2.3. prepareBeanFactory源码注解上有一句话：Configure the factory’s standard context characteristics, such as the context’s ClassLoader and post-processors —— 配置工程的标准上下文特性，例如上下文的类加载器以及后置处理器（BeanPostProcessor）。包括：

设置 Bean ClassLoader
设置 BeanExpressionResolver
设置 PropertyEditorRegistrar
添加 BeanPostProcessor
设置忽略的依赖接口
注册可解析依赖
注册 Bean
…

protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;    // Tell the internal bean factory to use the context&#x27;s class loader etc.    // 设置类加载器    beanFactory.setBeanClassLoader(getClassLoader());    // 表达式解析器    beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));    beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));    // Configure the bean factory with context callbacks.    // 添加部分的 bean 后置处理器    beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));    // 设置忽略的依赖接口，即这些接口的实现类不会通过接口类型自动注入    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);    // BeanFactory interface not registered as resolvable type in a plain factory.    // MessageSource registered (and found for autowiring) as a bean.    // 注册可以解析的依赖    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);    beanFactory.registerResolvableDependency(ResourceLoader.class, this);    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);    beanFactory.registerResolvableDependency(ApplicationContext.class, this);    // Register early post-processor for detecting inner beans as ApplicationListeners.    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));    // Detect a LoadTimeWeaver and prepare for weaving, if found.    if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));        // Set a temporary ClassLoader for type matching.        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));    &#125;    // Register default environment beans.    // 注册 Environment    if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());    &#125;    // 注册 SystemProperties，一个 Map&lt;String, Object&gt;    if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());    &#125;    // 注册 SystemEnvironment，一个 Map&lt;String, Object&gt;    if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());    &#125;&#125;

2.4. postProcessBeanFactoryAbstractApplicationContext 提供了一个空实现，留给子类具体实现
以下是  ServletWebServerApplicationContext 的实现：
protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;    // 添加 BeanPostProcessor    beanFactory.addBeanPostProcessor(new WebApplicationContextServletContextAwareProcessor(this));    // 忽略依赖接口，不会自动绑定    beanFactory.ignoreDependencyInterface(ServletContextAware.class);    registerWebApplicationScopes();&#125;


2.5. invokeBeanFactoryPostProcessors调用 BeanFactoryPostProcessor。总体来看调用逻辑分为两块：先处理 BeanDefinitionRegistryPostProcessor，然后处理 BeanFactoryPostProcessor。

BeanDefinitionRegistryPostProcessor 也属于 BeanFactoryPostProcessor

例如，这里会调用 ConfigurationClassPostProcessor 处理 @Configuration 类。

ConfigurationClassPostProcessor 属于 BeanDefinitionRegistryPostProcessor

protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123;    // Bean Factory 后置处理器注册的委托组件    // 委托其调用后置处理器    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());    // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime    // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)    if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));    &#125;&#125;

以下是 PostProcessorRegistrationDelegate 调用逻辑:
参数 beanFactoryPostProcessors 一般是：

CachingMetadataReaderFactoryPostProcessor
ConfigurationWarningsPostProcessor
PropertySourceOrderingPostProcessor

public static void invokeBeanFactoryPostProcessors( ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) &#123;    // Invoke BeanDefinitionRegistryPostProcessors first, if any.    // 首先调用 BeanDefinitionRegistryPostProcessor    // 即 Bean Definition 注册表    // 这个数据结构 processedBeans 用于存储已经处理过的 Bean，防止重复处理    Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;();    if (beanFactory instanceof BeanDefinitionRegistry) &#123;        BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;        List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;();        List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;();        for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;            if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123;                BeanDefinitionRegistryPostProcessor registryProcessor =                        (BeanDefinitionRegistryPostProcessor) postProcessor;                // 进行后置处理                registryProcessor.postProcessBeanDefinitionRegistry(registry);                registryProcessors.add(registryProcessor);            &#125;            else &#123;                regularPostProcessors.add(postProcessor);            &#125;        &#125;        // Do not initialize FactoryBeans here: We need to leave all regular beans        // uninitialized to let the bean factory post-processors apply to them!        // Separate between BeanDefinitionRegistryPostProcessors that implement        // PriorityOrdered, Ordered, and the rest.        // 这个数据结构 currentRegistryProcessors 用于存储每一波的 Processor        List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;();                // 获得所有的 BeanDefinitionRegistryPostProcessor        String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);        // 1. 首先，调用实现了 PriorityOrdered 的 BeanDefinitionRegistryPostProcessor        for (String ppName : postProcessorNames) &#123;            if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));                // 防止重复处理                processedBeans.add(ppName);            &#125;        &#125;        // 排序        sortPostProcessors(currentRegistryProcessors, beanFactory);        registryProcessors.addAll(currentRegistryProcessors);        // 执行        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);        currentRegistryProcessors.clear();        // 2. 然后，类似地，调用实现了 Ordered 接口的 BeanDefinitionRegistryPostProcessor        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);        for (String ppName : postProcessorNames) &#123;            // 由于 PriorityOrdered 也是 Ordered，因此这里需要借助 processedBeans 结构防止重复处理            if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));                processedBeans.add(ppName);            &#125;        &#125;        sortPostProcessors(currentRegistryProcessors, beanFactory);        registryProcessors.addAll(currentRegistryProcessors);        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);        currentRegistryProcessors.clear();        // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.        // 3. 最后调用所有其他 BeanDefinitionRegistryPostProcessor 直到没有一个        // 因为有可能 BeanDefinitionRegistryPostProcessor 还会注册 BeanDefinitionRegistryPostProcessor        boolean reiterate = true;        while (reiterate) &#123;            reiterate = false;            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);            for (String ppName : postProcessorNames) &#123;                if (!processedBeans.contains(ppName)) &#123;                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));                    processedBeans.add(ppName);                    // 假设这里 BeanDefinitionRegistryPostProcessor 的会注册新的 BeanDefinitionRegistryPostProcessor                    // 因此需要重新迭代                    reiterate = true;                &#125;            &#125;            // 最后一次迭代，currentRegistryProcessors 空的            sortPostProcessors(currentRegistryProcessors, beanFactory);            registryProcessors.addAll(currentRegistryProcessors);            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);            currentRegistryProcessors.clear();        &#125;        // Now, invoke the postProcessBeanFactory callback of all processors handled so far.        // 现在调用 postProcessBeanFactory（上面调用的都是 postProcessBeanDefinitionRegistry）        invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);        invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);    &#125;    else &#123;        // Invoke factory processors registered with the context instance.        invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);    &#125;    // Do not initialize FactoryBeans here: We need to leave all regular beans    // uninitialized to let the bean factory post-processors apply to them!    // 这里开始处理 BeanFactoryPostProcessor    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);    // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,    // Ordered, and the rest.    List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();    List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();    List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();    for (String ppName : postProcessorNames) &#123;        if (processedBeans.contains(ppName)) &#123;            // skip - already processed in first phase above            // 跳过，因为 BeanDefinitionRegistryPostProcessor 就是 BeanFactoryPostProcessor，已经在前面处理过了        &#125;        else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;            priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));        &#125;        else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;            orderedPostProcessorNames.add(ppName);        &#125;        else &#123;            nonOrderedPostProcessorNames.add(ppName);        &#125;    &#125;    // 1. 首先，调用实现了 PriorityOrdered 的 BeanFactoryPostProcessors    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);    invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);    // 2. 接下来，调用实现了 Ordered 的 BeanFactoryPostProcessors    List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;(orderedPostProcessorNames.size());    for (String postProcessorName : orderedPostProcessorNames) &#123;        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));    &#125;    sortPostProcessors(orderedPostProcessors, beanFactory);    invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);    // 3. 最后，调用所有其他的 BeanFactoryPostProcessor    List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());    for (String postProcessorName : nonOrderedPostProcessorNames) &#123;        nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));    &#125;    invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);    // Clear cached merged bean definitions since the post-processors might have    // modified the original metadata, e.g. replacing placeholders in values...    beanFactory.clearMetadataCache();&#125;

2.6. registerBeanPostProcessors注册 BeanPostProcessor。最终实际会注册到 BeanFactory（AbstractBeanFactory）的 beanPostProcessors 结构中，该数据类型为一个 List&lt;BeanPostProcessor&gt;：

不同类型的 BeanPostProcessor 在 getBean 的执行时机是不是一样的。

MergedBeanDefinitionPostProcessor 存放在 internalPostProcessors
protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123;    // 委托注册    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);&#125;

public static void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123;    // 获得所有的 BeanPostProcessor    // 默认的可能有：    // 1. org.springframework.context.annotation.internalAutowiredAnnotationProcessor    // 2. org.springframework.context.annotation.internalCommonAnnotationProcessor    // 3. org.springframework.context.annotation.internalPersistenceAnnotationProcessor    // 4. org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor    // 5. configurationPropertiesBeans    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);    // Register BeanPostProcessorChecker that logs an info message when    // a bean is created during BeanPostProcessor instantiation, i.e. when    // a bean is not eligible for getting processed by all BeanPostProcessors.    int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;    beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));    // Separate between BeanPostProcessors that implement PriorityOrdered,    // Ordered, and the rest.    List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();    List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;();    List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();    List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();    // 遍历所有的 BeanPostProcessor    for (String ppName : postProcessorNames) &#123;        if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;            // 如果实现了 PriorityOrdered 接口, getBean 触发创建 bean            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);            priorityOrderedPostProcessors.add(pp);            if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;                internalPostProcessors.add(pp);            &#125;        &#125;        else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;            // 如果实现了 Ordered 接口            orderedPostProcessorNames.add(ppName);        &#125;        else &#123;            nonOrderedPostProcessorNames.add(ppName);        &#125;    &#125;    // 1. 首先，注册实现了 PriorityOrdered 接口的 BeanPostProcessor    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);    // 2. 接下来，注册实现了 Ordered 接口的 BeanPostProcessors    List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();    for (String ppName : orderedPostProcessorNames) &#123;        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);        orderedPostProcessors.add(pp);        if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;            internalPostProcessors.add(pp);        &#125;    &#125;    sortPostProcessors(orderedPostProcessors, beanFactory);    registerBeanPostProcessors(beanFactory, orderedPostProcessors);    // 3. 注册所有常规的 BeanPostProcessor，即没有实现任何优先级接口    List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();    for (String ppName : nonOrderedPostProcessorNames) &#123;        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);        nonOrderedPostProcessors.add(pp);        if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;            internalPostProcessors.add(pp);        &#125;    &#125;    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);    // Finally, re-register all internal BeanPostProcessors.    // 4. 最终，重新注册所有内部的 BeanPostProcessor    sortPostProcessors(internalPostProcessors, beanFactory);    registerBeanPostProcessors(beanFactory, internalPostProcessors);    // Re-register post-processor for detecting inner beans as ApplicationListeners,    // moving it to the end of the processor chain (for picking up proxies etc).    // 注册 ApplicationListenerDetector    // 作用：    // 在 Bean 创建完成后检查是否是 ApplicationListener    // 如果是，则添加到容器的 applicationListeners 中    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));&#125;

2.7. initMessageSource国际化功能；消息绑定；消息解析
protected void initMessageSource() &#123;	ConfigurableListableBeanFactory beanFactory = getBeanFactory();	// 检查是否包含 &quot;messageSource&quot; 的 bean	if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;		this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);		// Make MessageSource aware of parent MessageSource.		if (this.parent != null &amp;&amp; this.messageSource instanceof HierarchicalMessageSource) &#123;			HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;			if (hms.getParentMessageSource() == null) &#123;				// Only set parent context as parent MessageSource if no parent MessageSource				// registered already.				hms.setParentMessageSource(getInternalParentMessageSource());			&#125;		&#125;		if (logger.isTraceEnabled()) &#123;			logger.trace(&quot;Using MessageSource [&quot; + this.messageSource + &quot;]&quot;);		&#125;	&#125;	else &#123;		// Use empty MessageSource to be able to accept getMessage calls.		DelegatingMessageSource dms = new DelegatingMessageSource();		dms.setParentMessageSource(getInternalParentMessageSource());		this.messageSource = dms;		beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);		if (logger.isTraceEnabled()) &#123;			logger.trace(&quot;No &#x27;&quot; + MESSAGE_SOURCE_BEAN_NAME + &quot;&#x27; bean, using [&quot; + this.messageSource + &quot;]&quot;);		&#125;	&#125;&#125;

2.8. initApplicationEventMulticaster初始化事件派发器。一般情况下都是容器给我们默认创建一个 SimpleApplicationEventMulticaster。
protected void initApplicationEventMulticaster() &#123;	ConfigurableListableBeanFactory beanFactory = getBeanFactory();	if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;		this.applicationEventMulticaster = beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);	&#125;	else &#123;		// 不存在则创建一个 SimpleApplicationEventMulticaster		this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);		beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);	&#125;&#125;

2.9. onRefreshAbstractApplicationContext 的空实现，留给子类个性化实现
2.10. registerListeners注册 ApplicationListener，向之前初始化的 ApplicationEventMulticaster 中注册大量的监听器。
protected void registerListeners() &#123;    // Register statically specified listeners first.    // 首先，静态地注册特定的 Listener    for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;        getApplicationEventMulticaster().addApplicationListener(listener);    &#125;    // Do not initialize FactoryBeans here: We need to leave all regular beans    // uninitialized to let post-processors apply to them!    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);    for (String listenerBeanName : listenerBeanNames) &#123;        getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);    &#125;    // Publish early application events now that we finally have a multicaster...    Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents;    this.earlyApplicationEvents = null;    if (!CollectionUtils.isEmpty(earlyEventsToProcess)) &#123;        for (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;            getApplicationEventMulticaster().multicastEvent(earlyEvent);        &#125;    &#125;&#125;

2.11. finishBeanFactoryInitialization初始化所有剩下的（非懒加载）单例 Bean
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;    // Initialize conversion service for this context.    // 类型转换    if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;        beanFactory.setConversionService(                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));    &#125;    // Register a default embedded value resolver if no bean post-processor    // (such as a PropertyPlaceholderConfigurer bean) registered any before:    // at this point, primarily for resolution in annotation attribute values.    // 值解析器    if (!beanFactory.hasEmbeddedValueResolver()) &#123;        beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));    &#125;    // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);    for (String weaverAwareName : weaverAwareNames) &#123;        getBean(weaverAwareName);    &#125;    // Stop using the temporary ClassLoader for type matching.    beanFactory.setTempClassLoader(null);    // Allow for caching all bean definition metadata, not expecting further changes.    beanFactory.freezeConfiguration();    // Instantiate all remaining (non-lazy-init) singletons.    // 实例化所有剩余的（非懒加载）单例    beanFactory.preInstantiateSingletons();&#125;

下面的方法对剩余的 bean 进行了创建，其实 getBean 就是隐式包含一种对 bean 的创建。
public void preInstantiateSingletons() throws BeansException &#123;    if (logger.isTraceEnabled()) &#123;        logger.trace(&quot;Pre-instantiating singletons in &quot; + this);    &#125;    // Iterate over a copy to allow for init methods which in turn register new bean definitions.    // While this may not be part of the regular factory bootstrap, it does otherwise work fine.    // 所有的 Bean Definition 信息    List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);    // Trigger initialization of all non-lazy singleton beans...    for (String beanName : beanNames) &#123;        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);        // 必须是非抽象、单例、非懒加载        if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;            // 判断是否是 FactoryBean（是否实现了 FactoryBean）            if (isFactoryBean(beanName)) &#123;                Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);                if (bean instanceof FactoryBean) &#123;                    FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;                    boolean isEagerInit;                    if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;                        isEagerInit = AccessController.doPrivileged(                                (PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,                                getAccessControlContext());                    &#125;                    else &#123;                        isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;                                ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());                    &#125;                    if (isEagerInit) &#123;                        getBean(beanName);                    &#125;                &#125;            &#125;            else &#123;                getBean(beanName);            &#125;        &#125;    &#125;    // Trigger post-initialization callback for all applicable beans...    // 后置初始化回调所有的 Bean    for (String beanName : beanNames) &#123;        Object singletonInstance = getSingleton(beanName);        if (singletonInstance instanceof SmartInitializingSingleton) &#123;            SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;            if (System.getSecurityManager() != null) &#123;                AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;                    smartSingleton.afterSingletonsInstantiated();                    return null;                &#125;, getAccessControlContext());            &#125;            else &#123;                smartSingleton.afterSingletonsInstantiated();            &#125;        &#125;    &#125;&#125;


2.12. finishRefresh完成 refresh 执行的操作
protected void finishRefresh() &#123;    // Clear context-level resource caches (such as ASM metadata from scanning).    clearResourceCaches();    // Initialize lifecycle processor for this context.    initLifecycleProcessor();    // Propagate refresh to lifecycle processor first.    getLifecycleProcessor().onRefresh();    // 发布容器刷新完毕的事件    publishEvent(new ContextRefreshedEvent(this));    // Participate in LiveBeansView MBean, if active.    LiveBeansView.registerApplicationContext(this);&#125;
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Bean @Autowired 与 JSR-250 @Resource</title>
    <url>/2022/07/19/Framework/Java/Spring-Framework/Spring-Core-@Resource-%E4%B8%8E-@Autowired/</url>
    <content><![CDATA[Spring Bean @Autowired 与 JSR-250 @Resource@Autowired由 Spring 提供的注解，依赖注入的过程由 AutowiredAnnotationBeanPostProcessor 执行。
通常这一步骤发生在 populateBean 流程之中，使用特定的 InstantiationAwareBeanPostProcessor 进行属性注入
@Resource由 JSR-250 中提供的注解，依赖注入的过程由 CommonAnnotationBeanPostProcessor 执行。
通常这一步骤发生在 populateBean 流程之中，使用特定的 InstantiationAwareBeanPostProcessor 进行属性注入

如果 @Resource 指定了 name，则按照 name 查找 Bean，找到则注入；找不到抛出异常
如果 @Resource 没有指定 name，通过 Java 反射得到 Field 属性 name，找不到则按照类型匹配


由于显式指定了 @Resource 的 name，因此在找不到的情况下必须抛出异常，这可能是人为的疏漏；如果没有指定 name，那么容器会智能地按照属性名、类型地顺序依次寻找。

protected Object autowireResource(BeanFactory factory, LookupElement element, @Nullable String requestingBeanName)        throws NoSuchBeanDefinitionException &#123;    Object resource;    Set&lt;String&gt; autowiredBeanNames;    // 此处的 element.name 以及在构造器中赋值    String name = element.name;    if (factory instanceof AutowireCapableBeanFactory) &#123;        AutowireCapableBeanFactory beanFactory = (AutowireCapableBeanFactory) factory;        DependencyDescriptor descriptor = element.getDependencyDescriptor();        if (this.fallbackToDefaultTypeMatch &amp;&amp; element.isDefaultName &amp;&amp; !factory.containsBean(name)) &#123;            autowiredBeanNames = new LinkedHashSet&lt;&gt;();            resource = beanFactory.resolveDependency(descriptor, requestingBeanName, autowiredBeanNames, null);            if (resource == null) &#123;                throw new NoSuchBeanDefinitionException(element.getLookupType(), &quot;No resolvable resource object&quot;);            &#125;        &#125;        else &#123;            resource = beanFactory.resolveBeanByName(name, descriptor);            autowiredBeanNames = Collections.singleton(name);        &#125;    &#125;    else &#123;        resource = factory.getBean(name, element.lookupType);        autowiredBeanNames = Collections.singleton(name);    &#125;    if (factory instanceof ConfigurableBeanFactory) &#123;        ConfigurableBeanFactory beanFactory = (ConfigurableBeanFactory) factory;        for (String autowiredBeanName : autowiredBeanNames) &#123;            if (requestingBeanName != null &amp;&amp; beanFactory.containsBean(autowiredBeanName)) &#123;                beanFactory.registerDependentBean(autowiredBeanName, requestingBeanName);            &#125;        &#125;    &#125;    return resource;&#125;]]></content>
      <tags>
        <tag>Spring Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Framework Data Access</title>
    <url>/2022/08/26/Framework/Java/Spring-Framework/Spring-Framework-Data-Access/</url>
    <content><![CDATA[Data Access
1. Transaction Management1.1. Advantages of the Spring Framework’s Transaction Support Model1.1.1. Global Transactions1.2. Understanding the Spring Framework Transaction AbstractionSpring 事务抽象的关键在于事务策略概念。事务策略被定义在 TransactionManager，特别是，PlatformTransactionManager 用于命令式事务管理和 ReactiveTransactionManager 用于响应式事务管理。
PlatformTransactionManager 类似 Spring Framework IoC 容器的其他 bean。这种好处是，让 Spring Framework 事务称为一个抽象，即使你使用 JTA。你可以比直接使用 JTA 更轻松地测试事务代码。
同样，在 Spring 中，可以被任何 PlatformTransactionManager 接口额方法抛出的 TransactionException 是未检查的（也就是继承于 RuntimeException）。事务基础架构的错误总是致命的。在罕见的情况下，应用程序的代码可以从事务发生的故障中恢复，开发人员仍然可以选择 catch 和处理 TransactionException。
TransactionDefinition 接口指定如下内容：

Propagation：通常，在一个事务范围中的所有代码运行在那个事务中。但是，如果当一个事务上下文已经存在时，运行了一个事务方法，则可以指定这种行为。例如，代码可以继续运行在现有事务中（通常的情况），或者暂停已存在的事务，创建一个新的事务。
Isolation：隔离级别。该事务从其他事务的工作中隔离的程度。
Timeout：超时。在超时之前该事务可以运行的时间，并且会自动由事务底层机制回滚。
Read-only status：你可以在代码读取但不修改数据时使用只读状态。在某些情况下，只读事务时有用的优化，如 Hibernate。

这些设置反映了标准的事务概念。
1.4. Declarative Transaction Management
大多数 Spring 框架用户选择声明式事务管理。此选项对应用程序代码影响最小，是最符合非侵入式轻量容器的理想方式。

基于 Spring 面向切面编程（AOP），Spring 框架的声明式事务管理是可能的。但是，由于事务切面代码随着 Spring Framework 发布而来，并且可以在样板中使用，AOP 的概念没有必要理解为充分利用这段代码。
Spring Framework 的声明式事务管理类似于 EJB CMT，因此你可以指定事务行为到单个方法级别。如有必要，你可以在事务上下文中调用 setRollBackOnly()。
1.4.1. Understanding the Spring Framework’s Declarative Transaction Implementation仅仅使用 @Transactional 注解是没有用的，还需要添加 @EnableTransactionManagement 到配置类中。
掌握 Spring Framework 声明式事务支持最重要的概念是通过 AOP 代理开启的支持和由元数据（XML 或者 注解）驱动的 transactional advice。AOP 和事务元数据的组合产生了 AOP 代理，其使用 TransactionInterceptor 与适当的 TransactionManager 实现来驱动围绕方法调用事务。
Spring 框架的 TransactionInterceptor 为命令式和响应式编程模型提供事务管理。拦截器通过检查方法返回类型来检测所需的事务管理。
1.4.6. Using @Transactional除了基于注解的声明式方式进行事务配置之外，你还可以使用基于注解的方式。直接在 Java 代码中声明事务语义上更贴近受影响的代码。
使用在类级别上，表示注解默认作用域声明类的所有方法（包括子类）。或者，每个方法可以被单独注解。注意，类级别的注解不会使用祖先类到类的层次结构；在这样的场景中，需要在本地重新声明，一边参与子类级注解。
在 xml 配种，标签 &lt;tx:annotation-driven/&gt;提供相似的简便方式：
&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;


如果你想绑定的 TransactionManager 名称就是 transactionManager，你可以省略配置 &lt;tx:annotation-driven/&gt; 标签中的 transaction-manager 属性；否则你不得不指定 transaction-manager 属性。


@Transactional Settings@Transactional 注解是指定接口，类或者方法必须具有事务语义。默认的 @Transactional 设置如下：

传播类型 PROPAGATION_REQUIRED
隔离级别 ISOLATION_DEFAULT
事务是读写型
事务超时默认为底层事务系统的默认超时时间，如果不支持超时，则没有
任何 RuntimeException 触发回滚，任何检查型 Exception 并不会。

&amp;nbsp;
Custom Composed Annotations1.4.7. Transaction Propagation本节描述 Spring 中事务传播的一些语义。请注意，本节不是对事务传播本身的介绍。相反，它详细描述了 Spring 中关于事务传播的一些语义。
在 Spring 管理的事务中，要注意物理事务和逻辑事务之间的区别，以及传播设置如何应用的区别。
Understanding PROPAGATION_REQUIRED

PROPAGATION_REQUIRED 强制执行一个物理事务，如果不存在事务，则本地为当前范围开启事务，或者参与定义为更大范围的已经存在的外部事务。在同一个线程内的公用调用栈安排中，这是一个很好的默认值（例如，一个委托给几个仓库方法的服务门面，其中所有的底层资源都必须参与服务级别事务）
当传播设置为 PROPAGATION_REQUIRED 时，会为每个设置应用的方法创建一个逻辑事务范围。每个此类逻辑事务范围可以单独决定仅回滚状态，外部事务范围逻辑上独立于内部事务范围。在标准的 PROPAGATION_REQUIRED 行为下，所有这些范围都映射相同的物理事务。内部事务范围的仅回滚标记确实会影响到外部事务实际提交的机会。
Understanding PROPAGATION_REQUIRES_NEW相较于 PROPAGATION_REQUIRED，PROPAGATION_REQUIRES_NEW 总是为每个受影响的事务范围使用独立的物理事务，从不参与到外部范围的现有事务中去。在这种安排下，底层资源事务是不同的，因此，可以独立提交、回滚，外部事务不受内部事务回滚状态影响，并且内部事务的锁在完成后立即释放。这种独立的内部事务也可以声明自己的隔离级别，超时，以及是否只读，而不继承外部事物的特征。
Understanding PROPAGATION_NESTEDPROPAGATION_NESTED 使用一个具有多个可以回滚保存点的物理事务。这种部分回滚让内部事务范围触发其范围内的回滚，并且即使某些操作已经回滚，外部事务仍能够继续物理事务。这个设置通常映射到 JDBC 保存点，因此它只适用于 JDBC 资源事务。参见 Spring 的 DataSourceTransactionManager
1.5.3. Using the TransactionManagerUsing the PlatformTransactionManager对于强制性的事务，你可以直接使用 org.springframework.transaction.PlatformTransactionManager 来管理事务。为此，将你要使用的 PlatformTransactionManager 的实现类传递给你的 bean。然后，通过使用 TransactionDefinition 和 TransactionStatus 对象，你可以启动，回滚以及提交事务。
Using the ReactiveTransactionManager当使用响应式事务时，你可以直接使用 org.springframework.transaction.ReactiveTransactionManager 管理你的事务。
1.6. Choosing Between Programmatic and Declarative Transaction Management当你具有少量的事务操作时，编程式事务管理通常是个不错的主意。
&amp;nbsp;
2. DAO Support2.1. Consistent Exception HierarchySpring 提供了特定异常到自己异常类层次结构的转换。该类层次结构将 DataAccessException 作为根异常。
3. Data Access with JDBC3.1. Choosing an Approach for JDBC Database Access你可以选择及中方来构建 JDBC 数据库访问基础。除了三种 JdbcTemplate 之外，一个新的 SimpleJdbcInsert 和 SimpleJdbcCall 方法优化了数据库元数据，并且 RDBMS 对象风格采取了一种更面向对象的方式，类似于 JDO 查询设计。

JdbcTemplate 是经典且最流行的 Spring JDBC 方式。这种 “最低级别” 的方法和所有其他封装的方法使用 JdbcTemplate
NamedParameterJdbcTemplate 包装了一个 JdbcTemplate 以提供命名参数而不是传统的 JDBC ? 占位符。当你的 SQL 语句有多个参数时，这种方法提供了更好的文档性且易于使用。
SimpleJdbcInsert 和 SimpleJdbcCall 优化了数据库元数据来限制必要配置的数量。这种方法简化了编码，你只需要提供表名称，或者存储过程名称，并且提供一个参数与列名匹配的映射。

3.3. Using the JDBC Core Classes to Control Basic JDBC Processing and Error Handling3.3.1. Using JdbcTemplateJdbcTemplate 是 JDBC core 包下的核心类。它处理资源的创建与释放，这可以帮助你避免一些常见的错误，比如忘记关闭连接。它执行核心 JDBC 工作流的基本任务（如语句的创建和执行），让应用程序代码来提供 SQL 和获取结果集。
JdbcTemplate 可以做如下的事情：

运行 SQL 查询
更新语句以及存储过程调用
执行 ResultSet 的迭代，以及提取返回参数值的结果
捕获 JDBC 异常，并将其转换为定义在 org.springframework.dao 包下的更通用，更具信息意义的异常层次

当你使用 JdbcTemplate 时，你只需要实现一个回调接口，给出明确定义的约定。给定一个 JdbcTemplate 类提供的 Connection，PreparedStatementCreator 回调接口会创建一个 预编译的语句，提供了 SQL 以及任何必要的参数。CallableStatementCreator 接口也是如此，它创建可调用的语句。RowCallbackHandler 接口从 ResultSet 的每一行中提取值。
你可以在你的 DAO 实现中通过给予一个 DataSource 的引用直接实例化 JdbcTempalte 并使用；或者，你可以配置它到 Spring IoC 容器里，并将其作为一个 bean 引用给 DAO。

DataSource 应当总是配置为一个 Spring Ioc 容器中的 bean。

此类发出的所有 SQL 都以 debug 级别的日志记录下来，
Querying (SELECT)Updating (INSERT, UPDATE, and DELETE) with JdbcTemplate3.3.3. Using SQLExceptionTranslatorSQLExceptionTranslator 是一个接口，用于 SQLExceptions 和 Spring 的 DataAccessException 之间进行转换。
SQLErrorCodeSQLExceptionTranslator 是 SQLExceptionTranslator 默认的实现。此实现使用特定的供应商代码，比 SQLState 更精确。错误代码转换基于名为 SQLErrorCodes 的 JavaBean 类中保存的代码。此类由 SQLErrorCodesFactory 创建和填充，是基于 sql-error-codes.xml 的配置文件的内容创建的工厂。
]]></content>
  </entry>
  <entry>
    <title>Spring Framework Integration</title>
    <url>/2022/07/27/Framework/Java/Spring-Framework/Spring-Framework-Integration/</url>
    <content><![CDATA[Integration
Message ConversionWebMvcConfigurationSupport 内含默认的 Converter
BufferedImageHttpMessageConverter 返回图片
@RequestMapping(path = &quot;/image/&#123;id&#125;&quot;, produces = MediaType.IMAGE_JPEG_VALUE)public BufferedImage getImage(@PathVariable Integer id) throws Exception &#123;    Weather weather = weatherMapper.getById(id);    return ImageIO.read(weather.getPicture());&#125;


6. MailSpring Boot 的使用方式：
(1) 配置并将 JavaMailSender 注入到 IOC 容器，类似一个 Mail 工厂配置，可以 getSession，也可以 createMimeMessage
@Configurationpublic class JavaMailConfig &#123;    @Bean(name = &quot;javaMailSender&quot;)    public JavaMailSenderImpl javaMailSender() &#123;        JavaMailSenderImpl javaMailSender = new JavaMailSenderImpl(); // 唯一的实现        javaMailSender.setHost(&quot;smtp.qq.com&quot;); // 设置 SMTP 主机        javaMailSender.setUsername(&quot;945086245@qq.com&quot;);        javaMailSender.setPassword(&quot;password&quot;);        javaMailSender.setDefaultEncoding(&quot;UTF-8&quot;);        return javaMailSender;    &#125;&#125;

(2) 使用 javaMailSender 发送。MimeMessageHelper 类似 Builder 设计，但是没有做链式调用。
MimeMessage mimeMessage = javaMailSender.createMimeMessage();MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true);mimeMessageHelper.setFrom(&quot;945086245@qq.com&quot;); // 发送人mimeMessageHelper.setTo(email); // 接收人mimeMessageHelper.setSubject(&quot;验证码&quot;);mimeMessageHelper.setText(&quot;您的验证码是: 9836, 如非本人操作请忽视。&quot;);javaMailSender.send(mimeMessage);

7. Task Execution and SchedulingSpring Framework 分别使用 TaskExecutor 和 TaskScheduler 接口为异步执行和任务调度提供了抽象。Spring 还具有那些支持线程池的接口实现或在应用程序服务器环境中委托 CommonJ。最终，通用接口之间的这些实现的使用抽象出了 Java SE5，Java SE 6 以及 Java EE 环境的差异。
Spring 还具有支持使用 Timer 调度的集成类，以及 Quartz Scheduler。你可以通过使用 FactoryBean，可选的分别对 Timer 或者 Trigger 实例的引用设置这两个调度器。此外，用于 Quartz 调度器和 Timer 的便利类是可用的，它让你调用现存的目标对象的方法（类似于普通的 MethodInvokingFactoryBean 操作）。
7.1. The Spring TaskExecutor AbstractionExecutor 是 JDK 用于线程池概念的名称。之所以叫 “executor” 是因为实际上不能保证底层的实现就是池。一个 executor 可以是单线程，甚至是同步的。Spring 的抽象隐藏了 Java SE 和 Java EE 环境之间的实现细节。
Spring 的 TaskExecutor 接口与 java.util.concurrent.Executor 接口相同。实际上，最初其主要存在的原因就是在使用线程池的时候抽象出对 Java 5 的需求。该接口只有一个方法（execute(Runnable task)），该方法接受给予线程池的语义和配置的任务。
7.1.1. TaskExecutor TypesSpring 包含了许多预置的 TaskExecutor 实现。很有可能，你永远不需要实现自己的类。Spring 提供的变体如下：

SyncTaskExecutor: 此实现不会异步运行调用。相反，每个调用都发生在调用线程中。它主要用于不需要多线程的情况，例如在简单的测试用例中。

ThreadPoolTaskExecutor: 此实现最常用。它暴露了用于配置 java.util.concurrent.ThreadPoolExecutor 的 Bean 属性，并将其包装在 TaskExecutor 中。如果你需要适应其他类型的 java.util.concurrent.Executor，我们建议你改用 ConcurrentTaskExecutor。


7.1.2. Using a TaskExecutorSpring 的 TaskExecutor 实现被用作简单的 Java Bean。在下面的示例中，我们定义了一个使用 ThreadPoolTaskExecutor 的 Bean，异步地打印一组消息：
import org.springframework.core.task.TaskExecutor;public class TaskExecutorExample &#123;    private class MessagePrinterTask implements Runnable &#123;        private String message;        public MessagePrinterTask(String message) &#123;            this.message = message;        &#125;        public void run() &#123;            System.out.println(message);        &#125;    &#125;    private TaskExecutor taskExecutor;    public TaskExecutorExample(TaskExecutor taskExecutor) &#123;        this.taskExecutor = taskExecutor;    &#125;    public void printMessages() &#123;        for(int i = 0; i &lt; 25; i++) &#123;            taskExecutor.execute(new MessagePrinterTask(&quot;Message&quot; + i));        &#125;    &#125;&#125;

如你所见，你没有从池中检索线程并自己执行，而是将你的 Runnable 添加到队列中。然后 TaskExecutor 使用其内部规则来决定任务何时运行。
为了配置 TaskExecutor 使用的规则，我们将公开简单的 Bean 属性：
&lt;bean id=&quot;taskExecutor&quot; class=&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;&gt;    &lt;property name=&quot;corePoolSize&quot; value=&quot;5&quot;/&gt;    &lt;property name=&quot;maxPoolSize&quot; value=&quot;10&quot;/&gt;    &lt;property name=&quot;queueCapacity&quot; value=&quot;25&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;taskExecutorExample&quot; class=&quot;TaskExecutorExample&quot;&gt;    &lt;constructor-arg ref=&quot;taskExecutor&quot;/&gt;&lt;/bean&gt;

7.2. The Spring TaskScheduler Abstraction除了 TaskExecutor 抽象外，
7.3. Annotation Support for Scheduling and Asynchronous Execution7.3.2. The @Scheduled annotation你可以将 @Scheduled 注解和触发器元数据一起添加到方法中。例如，下面的方法每 5 秒钟调用一次，具有固定的延迟，这意味着周期是从前面调用的完成时间计算出来的: 
@Scheduled(fixedDelay=5000)public void doSomething() &#123;    // something that should run periodically&#125;


tips fixedDelay 属性比较好理解，如果任务执行时间为 3 秒，那么到第 8 秒才会执行第二个任务。

如果需要固定速率的执行，可以更改注解中指定的属性名。下面的方法每 5 秒钟调用一次（在每次调用的连续开始时间之间测量）:
@Scheduled(fixedRate=5000)public void doSomething() &#123;    // something that should run periodically&#125;


tips fixedRate 意味着你的任务以固定的速率启动，但是可能会阻塞。当你任务执行时间较短，低于 fixedRate 时，任务按照固定的速率正常执行；当你的任务执行时间较长，大于 fixedRate 时，下一个任务由于前面的任务没有执行完毕会进入阻塞状态，在前一个任务执行完毕之后立即执行。

8. Cache Abstraction8.1. Understanding the Cache AbstractionBuffer 和 Cache
一般地，buffer 可以翻译为缓冲区，用于高速与低速的实体之间的中间存储，缓冲区至少对知晓它的一方是可见的。
cache 可以翻译为缓存，根据定义是隐藏的，任何一方都不知晓。
Spring 提供了一些缓存抽象的实现：

SimpleCacheConfiguration
EhCacheCacheConfiguration
GenericCacheConfiguration
RedisCacheConfiguration
…

SpringBoot CacheAutoConfiguration 中使用 @Import 导入了 CacheConfigurationImportSelector.class，其中导入了枚举类 CacheType 中所有的缓存类型。
SimpleCacheConfiguration
底层使用 concurrentMap 实现，见 SimpleCacheConfiguration  注入 ConcurrentMapCacheManager。ConcurrentMapCacheManager  属性 dynamic 可以配置 cacheName 是否可以动态生成，默认为 true。
8.2. Declarative Annotation-based CachingSpring 缓存抽象提供了一组 Java 注解：

@Cacheable：触发缓存填充
@CacheEvict：触发缓存驱逐
@CachePut：在不干扰方法执行的情况下更新缓存
@Caching：重新组合要应用于方法的多个缓存操作
@CacheConfig：在类级别共享一些常见的缓存相关设置

8.2.1. The @Cacheable Annotation


注解属性
说明



value &#x2F; cacheNames
缓存的名字


key
缓存数据使用的 key，默认使用方法参数


keyGenerator
自定义 key 生成器，实现 KeyGenerator


cacheManager
指定缓存管理器


condition
指定符合条件的情况下才缓存


unless
缓存的否定条件


sync
是否使用异步模式


Default Key Generationkey 默认采用 SimpleKeyGenerator 生成。以方法参数为标识。
Synchronized CachingSpring Core 框架的 CacheManager 实现都支持 sync。其他缓存库未必。
Available Caching SpEL Evaluation ContextCache SpEL 可用元数据，具体见官方表。
8.2.2. The @CachePut Annotation每次都调用方法，缓存结果。
8.2.3. The @CacheEvict annotation清空缓存
8.2.6. Enabling Caching Annotations@Configuration@EnableCachingpublic class AppConfig &#123;&#125;

8.3. JCache (JSR-107) Annotations从 Spring 4.1 开始，Spring 缓存抽象完全支持 JCache 注解
8.3.1. Feature Summary


Spring
JSR-107
备注



@Cacheable
@CacheResult



@CachePut
@CachePut



@CacheEvict
@CacheRemove



@CacheEvict(allEntries&#x3D;true)
@CacheRemoveAll



@CacheConfig
@CacheDefaults



JCache 的 CacheResolver 概念上与 Spring CacheResolver 接口相同，只是 JCache 仅支持单个 Cache。默认，Simple 实现会根据注解上的名称检索要使用的 Cache，如果注解上没有指定名称，则会自动生成一个默认值。
8.3.2. Enabling JSR-107 Support如果类路径同时存在 JSR-107 API 和 spring-context-support，@EnableCaching 和 cache:annotation-driven 都会自启用 JCache。
]]></content>
  </entry>
  <entry>
    <title>Spring ListableBeanFactory</title>
    <url>/2022/10/28/Framework/Java/Spring-Framework/Spring-ListableBeanFactory/</url>
    <content><![CDATA[&lt;T&gt; Map&lt;String, T&gt; getBeansOfType(Class&lt;T&gt; type, boolean includeNonSingletons, boolean allowEagerInit)        throws BeansException;


策略设计模式的使用: 
目前你需要实现一些邮件正文的生成，令他们由不同的业务类去实现，这些业务类提供一个统一的接口，比如: EmailBodyProvider。这些 EmailBodyProvider 必须提供一个标识符以供查询。
public interface EmailBodyProvider &#123;    Long getId();    String getEmailBody(Long applyId);    /**     * 根据操作类型获取具体实现类     *     * @param formId 表单ID     * @return IJsbAssetEmailApplyInfoQueryBiz     */    static EmailBodyProvider getInstance(Long id) &#123;        Map&lt;String, EmailBodyProvider&gt; map = ContextUtil.getContext().getBeansOfType(EmailBodyProvider.class, false, false);        for (Map.Entry&lt;String, EmailBodyProvider&gt; entry : map.entrySet()) &#123;            if (Objects.equals(formId, entry.getValue().getId())) &#123;                return entry.getValue();            &#125;        &#125;        throw new IllegalArgumentException(&quot;can not find IJsbAssetEmailApplyInfoQueryBiz implement instance&quot;);    &#125;&#125;

假如现在有一些实现类: Business1EmailBodyProvider、Business2EmailBodyProvider
]]></content>
  </entry>
  <entry>
    <title>Spring MVC DispatcherServlet 处理请求的过程</title>
    <url>/2022/07/22/Framework/Java/Spring-Framework/Spring-MVC-DispatcherServlet-%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[Spring MVC DispatcherServlet 处理请求的过程代码清单protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;    HttpServletRequest processedRequest = request;    HandlerExecutionChain mappedHandler = null;    boolean multipartRequestParsed = false;    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);    try &#123;        ModelAndView mv = null;        Exception dispatchException = null;        try &#123;            // 检查是否为 Multipart，底层根据 Content-Type            // 这里看似 check（检查），其实还有转换（包装）请求，返回 MultipartHttpServletRequest            processedRequest = checkMultipart(request);            multipartRequestParsed = (processedRequest != request);            // Determine handler for the current request.            // 确定当前请求的 handler            // 此处本质上返回的是 handler 的包装 HandlerExecutionChain            mappedHandler = getHandler(processedRequest);            if (mappedHandler == null) &#123;                noHandlerFound(processedRequest, response);                return;            &#125;            // Determine handler adapter for the current request.            // 确定当前请求的 handler 适配器            // 因为 handler 是个 Object，它不可能具有处理请求的方法，需要适配            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());            // Process last-modified header, if supported by the handler.            String method = request.getMethod();            boolean isGet = HttpMethod.GET.matches(method);            if (isGet || HttpMethod.HEAD.matches(method)) &#123;                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());                if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;                    return;                &#125;            &#125;            // 前置处理，应用一些拦截器，如果返回 false，则不再处理，或者抛出异常被 catch            if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;                return;            &#125;            // Actually invoke the handler.            // 实际调用 handler            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());            if (asyncManager.isConcurrentHandlingStarted()) &#123;                return;            &#125;            applyDefaultViewName(processedRequest, mv);            // 后置处理，应用一些拦截器            mappedHandler.applyPostHandle(processedRequest, response, mv);        &#125;        catch (Exception ex) &#123;            dispatchException = ex;        &#125;        catch (Throwable err) &#123;            // As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,            // making them available for @ExceptionHandler methods and other scenarios.            dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err);        &#125;        // 包括调用 HandlerInterceptor.afterCompletion        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);    &#125;    catch (Exception ex) &#123;        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);    &#125;    catch (Throwable err) &#123;        triggerAfterCompletion(processedRequest, response, mappedHandler,                new NestedServletException(&quot;Handler processing failed&quot;, err));    &#125;    finally &#123;        if (asyncManager.isConcurrentHandlingStarted()) &#123;            // Instead of postHandle and afterCompletion            if (mappedHandler != null) &#123;                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);            &#125;        &#125;        else &#123;            // Clean up any resources used by a multipart request.            if (multipartRequestParsed) &#123;                cleanupMultipart(processedRequest);            &#125;        &#125;    &#125;&#125;


具体流程getHandler找到合适的 HandlerMapping ，把请求映射为 HandlerExecutionChain 对象（其中包含一个类型为 Object 的 handler 对象）
默认情况下，Spring 提供了 5 个默认的 HandlerMapping，分别是：

RequestMappingHandlerMapping
BeanNameUrlHandlerMapping
RouterFunctionMapping
SimpleUrlHandlerMapping
WelcomePageHandlerMapping

比较常用的就是 RequestMappingHandlerMapping，一般用于 @RequestMapping 注解；SimpleUrlHandlerMapping，一般用于映射静态资源。
getHandlerAdapter找到 handler 的适配器。
由于 handler 没有一个统一的接口，因此需要寻找合适的适配器。

即使 handler 设计一个统一的接口，在统一处理的时候也要写大量的 if else 根据具体的实现类进行逻辑匹配。

]]></content>
      <tags>
        <tag>Spring Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Framework Core 翻译</title>
    <url>/2022/05/09/Framework/Java/Spring-Framework/Spring-Framework-Core/</url>
    <content><![CDATA[Core1. The IoC Container这一章主要讲述 Spring 的 IoC 容器，也就是 Inversion of Control container。
1.1. Introduction to the Spring IoC Container and Beans本章涵盖了控制反转（IoC）原理的 Spring Framework 实现。IoC 也被称为依赖注入（DI）。依赖注入是这样一个过程，对象定义它们的依赖仅通过构造器参数，工厂方法参数，在对象实例构造完毕或者从工厂方法返回之后设置属性。然后，容器在创建 bean 时注入这些依赖。这个过程通过使用类的直接构造或者例如服务定位器模式的机制，从根本上反转（因此得名控制反转）了 bean 本身控制其依赖的初始化或者定位。

作者的话 IoC 是 Inversion of Control 的缩写；DI 是 Dependency Injection 的缩写

org.springframework.beans 和 org.springframework.context 是 Spring IoC 容器的基础包。BeanFactory 接口提供了管理任意类型对象的高级配置机制。ApplicationContext 是 BeanFactory 的子接口，添加了：

与 Spring AOP 功能更容易集成
消息资源处理（用于国际化）
事件发布
应用程序层特定上下文，例如用于 Web 应用程序中的 WebApplicationContext

简而言之，BeanFactory 提供了配置框架和基础功能，并且 ApplicationContext 添加了更多企业特定的功能。ApplicationContext 是 BeanFactory 的完整超集，仅仅用于本章 Spring IoC 容器的描述。有关使用 BeanFactory 而不是 ApplicationContext 的更多信息，参见 The BeanFactory

官网中，主要描述的也是 ApplicationContext。

在 Spring 中，构成应用骨架并由 Spring IoC 容器管理的对象称之为 bean。bean 是由 Spring IoC 容器实例化，组装和管理的对象。一个 bean 只是你应用程序中的众多对象之一。bean 以及其中的依赖项反映在供容器使用的配置元数据中。
1.2. Container Overvieworg.springframework.context.ApplicationContext 代表 Spring IoC 容器，负责实例化、配置、组装 bean。通过读取配置元数据，容器获取那些需要实例化、配置、组装的对象的说明。配置元数据表现为 XML，Java 注解，Java 代码。它让你表达出组成你应用的对象，以及这些对象之间丰富的相互依赖性。
Spring 提供了一些 ApplicationContext 接口的实现。在独立应用程序中，通常创建 ClassPathXmlApplicationContext 或者 FileSystemXmlApplicationContext 实例。虽然 XML 一直是一种定义元数据的传统格式，但可以通过提供少量 XML 配置来声明启用其他元数据格式（Java 注解，Java 代码）的支持。它使你可以表达构成你应用程序的对象，以及这些对象之间丰富的相互依赖关系。
Spring 提供了 ApplicationContext	 接口的几种实现。在独立应用程序中，通常创建一个 ClassPathXmlApplicationContext 或者 FileSystemXmlApplicationContext。虽然 XML 是定义配置元数据的传统格式，但是你可以通过提供少量的 XML 配置来声明开启对于这些传统元数据格式的支持，指示容器使用 Java 配置或者代码作为元数据格式。
在大多数应用程序方案中，无需明确的用户代码即可实例化一个或多个 Spring IoC 容器的实例。例如，在 Web 应用程序方案中，应用程序的 web.xml 文件中的样例 web 描述符 XML 简单八行就足够了。如果你使用 Spring Tools for Eclipse，你可以轻松地点几下鼠标或者敲键盘来创建此样板配置。
下图展示了 Spring 工作方式的高级视图。你的应用程序类与配置元数据结合起来，以便于在 ApplicationContext 创建并初始化之后，你可以拥有一个完全配置化的可执行的系统或应用程序。
1.2.1. Configuration Metadata如前面图所示，Spring IoC 容器消耗某种形式的配置元数据。配置元数据表现出你如何告诉 Spring 容器去实例化，配置，组装你应用程序中的对象。


组装可以认为是一种依赖注入。


传统上，配置元数据以简单而直观的 XML 格式提供，这是本章用于传达 Spring IoC 容器关键概念和特色的大多数方式。

基于 XML 的元数据并不是唯一的配置元数据格式。Spring IoC 容器本身与配置元数据实际编写的格式完全分离。如今，许多开发人员选择为他们的 Spring 应用使用基础 Java 的配置

有关与 Spring 容器一起使用的其他形式的元数据信息，参见：

Annotation-based configuration: Spring 2.5 引入了基于注解的配置元数据支持
Java-based configuration: 从 Spring 3.0 开始，Spring JavaConfig 项目提供的许多功能称为 Core Spring Framework 的一部分。因此，你可以使用 Java 而不是 XML 文件来定义你应用程序类之外的 bean。要使用这些新功能，见 @Configuration，@Bean，@Import，以及 @DependsOn 注解

Spring 配置包含至少一个，且通常不止一个容器必须管理的 bean 定义。基于 XML 的配置元数据将这些 bean 以 &lt;bean/&gt; 元素配置在顶级 &lt;beans/&gt; 元素中。Java 配置通常使用 @Configuration 类中的 @Bean 注解的方法。
以下示例展示了基于 XML 的配置元数据的基本结构：
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;          &lt;!-- collaborators and configuration for this bean go here --&gt;    &lt;/bean&gt;    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;        &lt;!-- collaborators and configuration for this bean go here --&gt;    &lt;/bean&gt;    &lt;!-- more bean definitions go here --&gt;&lt;/beans&gt;

id 属性是标识单个 bean 定义的字符串class 属性定义了 bean 的类型，并且使用完全限定类名。
1.2.2. Instantiating a Container提供给 ApplicationContext 构造器的一个或多个位置路径是资源字符串，它使得容器能够从各种外部资源加载配置元数据，例如本地文件系统，Java CLASSPATH 等。
ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);

Composing XML-based Configuration Metadata让 bean 定义涵盖多个 XML 文件可能很有用。通常，每个单独的 XML 配置文件代表你的架构中的一个逻辑层或者模块。
你可以使用 ApplicationContext 构造器从所有这些 XML 片段中加载 bean 定义。该构造器接收多个 Resource 路径，如前一节所示。另外，请使用一个或多个 &lt;import/&gt; 元素从另一个（些）文件中加载 bean 定义。以下示例显示了如何做：
&lt;beans&gt;    &lt;import resource=&quot;services.xml&quot;/&gt;    &lt;import resource=&quot;resources/messageSource.xml&quot;/&gt;    &lt;import resource=&quot;/resources/themeSource.xml&quot;/&gt;    &lt;bean id=&quot;bean1&quot; class=&quot;...&quot;/&gt;    &lt;bean id=&quot;bean2&quot; class=&quot;...&quot;/&gt;&lt;/beans&gt;

在前面的例子中，外部 bean 定义是从这三个文件加载的：services.xml，messageSource.xml 以及 themeSource.xml。所有路径均相对于执行 import 的定义文件，因此 services.xml 必须执行 import 的文件在相同的目录或者类路径位置，而 messageSource.xml 和 themesource.xml 必须位于 import 文件位置下的 resources 位置中。如你所见，前导的斜杠被忽略了。但是，鉴于这些路径是相对的，最好不要使用斜杠。依据 Spring Schema，所导入的文件内容，包括顶级 &lt;beans/&gt; 元素，必须是有效的 XML bean 定义。

使用一个 “..&#x2F;“ 相对路径引用父目录的文件是可以的，但是并不推荐。这样做会产生对当前应用程序之外的文件的依赖。特别地，这种引用对于 classpath: URL（例如，classpath:../services.xml）也不建议，其中运行时解析过程选择 “最近” 的类路径根，然后查看其父目录。类路径配置更改可能导致选择其他的错误的路径。你可以始终使用完全限定资源地址，而不是相对路径：例如，file:C:/config/services.xml 或者 classpath:/config/services.xml。但是，请注意，你将应用程序的配置耦合到特定的绝对路径。通常，最好对这种绝对路径持有一个间接取值 —— 例如，通过在运行时根据 JVM 系统属性解析的占位符 “${…}”

命名空间本身提供了 import 指令功能。除了普通 bean 定义之外，还可以在 Spring 提供的 XML 命名空间的选择中获得更多配置功能 —— 例如，context 和 util 命名空间。
The Groovy Bean Definition DSL先省略
1.2.3. Using the ContainerApplicationContext 是一个高级工厂接口，能够维护各种各样 bean 及其依赖的注册表 。通过使用 T getBean(String name, Class&lt;T&gt; requiredType) 方法，你可以检索 你的 bean 实例。
ApplicationContext 使你可以读取 bean 定义并访问它们，如以下示例所示：
// create and configure beansApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);// retrieve configured instancePetStoreService service = context.getBean(&quot;petStore&quot;, PetStoreService.class);// use configured instanceList&lt;String&gt; userList = service.getUsernameList();

最灵活的变体形式是 GenericApplicationContext 组合 Reader 委托，例如：
GenericApplicationContext context = new GenericApplicationContext();new XmlBeanDefinitionReader(context).loadBeanDefinitions(&quot;services.xml&quot;, &quot;daos.xml&quot;);context.refresh();


作者的话 这种方式避免配置加载与 ApplicationContext 耦合

然后，你可以使用 getBean 来检索 bean 实例。ApplicationContext 接口还有一些其他的方法用于检索 bean，但是理想情况下，你的应用程序代码绝不应该使用它们。实际上，你的应用程序代码一点都不应该调用 getBean() 方法，因此一点都不依赖于 Spring API。例如，Spring 和 Web 框架的集成，通过元数据声明对 bean 的依赖，进而通过 Web 框架来获取 bean。
1.3. Bean OverviewSpring IoC 容器管理一个或多个 bean。这些 bean 是用你提供给容器的配置元数据所创建的（例如，以 XML &lt;bean/&gt; 定义形式）。
在容器之中，这些 Bean Definition 都会以 BeanDefinition 对象形式表现，其中包含（除其他信息）以下元数据：

完全限定类名，实际上也就是需要实例化的类
bean 行为配置元素，指示 bean 在容器的行为，例如：scope，生命周期回调 initMethodName、destroyMethodName 等
依赖项（DependsOn）。
设置在新建对象的其他设置（PropertyValues）。比如，池的大小, 连接的数量。

该元数据转化为构成每个 Bean Definition 的一组属性。下表描述了这些属性：



Property
Explained in…​



Class
Instantiating Beans


Name
Naming Beans


Scope
Bean Scopes


Constructor arguments
Dependency Injection


Properties
Dependency Injection


Autowiring mode
Autowiring Collaborators


Lazy initialization mode
Lazy-initialized Beans


Initialization method
Initialization Callbacks


Destruction method
Destruction Callbacks


1.3.1. Naming Beans每个 Bean 可以有一个或多个标识符。这些标识符必须在托管 Bean 的容器中是唯一的。通常，一个 Bean 只有一个标识符。但是，如果需要多个，其余视为别名。
在基于 XML 的配置元数据，你可以使用 id 属性，name 属性，或者两个一起来指定 bean 的标识符。id 属性允许你指定一个标识。按照约定，这些名字是字母或数字组合，例如：myBean, someService 等。
如果你想引入其他别名，你也可以指定 name 属性，使用 , 或者 ; 或者空格进行分割。

在 Spring 3.1 之前 id 属性被定义为 xsd:ID 类型，可能受制于一定的字符。Spring 3.1 之后，它被定义为 xsd:string 类型。注意，尽管不再由 XML 解析器强制执行 bean id 唯一性，但仍然由容器强制执行。

你不必为 bean 即提供 id 又提供 name。如果你有其中一个没有明确提供，容器会生成一个唯一的名字。但是，如果你想使用名称引用 bean，通过 ref 元素，或者服务定位器风格查找，你必须提供一个 name。

Bean Naming Conventions
该约定是，当命名 Bean 时，使用用于实例字段名称的标准 Java 约定。即，Bean 的名字以小写字母开头，并从那里开始以驼峰格式。此类名称的示例包括 `accountManager`，`accountService`，`userDao`，`loginController` 等。

Aliasing a Bean outside the Bean Definition在一个 bean 定义本身中，你可以通过 id 属性指定最多 1 个名称，以及在 name 属性中任意数量的其他名称，为 bean 提供不止一个名称。这些名称可以等效的 bean 别名，并且对于某些场景很有用，例如，让应用程序中的每个组件通过使用特定于该组件本身的 bean name 来引用通用的依赖。

如果你使用 Java 配置，可以使用 @Bean 注解提供别名。

1.3.2. Instantiating BeansBean Definition 本质上可以认为是创建一个或多个对象的配方。当需要时，容器会查找有名 bean 的配方，并使用该 Bean Definition 封装的配置元数据来创建（或者是获取）一个实际的对象。
如果你使用的是基于 XML 配置元数据，指定 &lt;bean/&gt; 元素的 class 属性作为对象的类型。class 属性（BeanDefinition 实例中的 Class 属性）通常是必需的。
Instantiation with a Constructor当你通过构造器方式创建 bean 时，所有一般的类都可以为 Spring 所用，并与 Spring 兼容。也就是说，开发的类无需实现特定的接口或者以特定方式进行编码。简单地指定 bean 的 class 就足够了。但是，根据你用于该特定 bean 的 IoC 类型，你可能需要一个默认（空）构造器。
Spring IoC 容器几乎可以管理你想要管理的任何类。它不仅仅局限于管理真正的 Java Bean。大多数 Spring 用户更愿意在容器中使用实际的 Java Bean，具有一个默认（无参）构造器，以及适当的属性 Setter 和 Getter。你也可以在容器中有更多特别的非 bean 风格的类。例如，如果你需要使用绝对不符合 Java Bean 规范的旧连接池，Spring 也可以管理它。
使用基于 XML 的配置元数据，你可以按照如下方式指定 bean 的 class：
&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;/&gt;&lt;bean name=&quot;anotherExample&quot; class=&quot;examples.ExampleBeanTwo&quot;/&gt;

有关向构造函数提供参数的机制的详细信息（如果需要），并在对象构造后设置对象实例属性，请参见 Injecting Dependencies。
Instantiation with a Static Factory Method使用静态工厂方法创建 bean 时，class 属性指定静态工厂方法的类，factory-method 属性指定静态方法名。主要用于遗留代码中的静态工厂方法：
&lt;bean id=&quot;clientService&quot;    class=&quot;examples.ClientService&quot;    factory-method=&quot;createInstance&quot;/&gt;
Instantiation by Using an Instance Factory Method实例工厂创建 bean 方法
&lt;!-- the factory bean, which contains a method called createInstance() --&gt;&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;    &lt;!-- inject any dependencies required by this locator bean --&gt;&lt;/bean&gt;&lt;!-- the bean to be created via the factory bean --&gt;&lt;bean id=&quot;clientService&quot;    factory-bean=&quot;serviceLocator&quot;    factory-method=&quot;createClientServiceInstance&quot;/&gt;

一个工厂方法可以包含多个工厂方法。
Determining a Bean’s Runtime Type1.4. Dependencies典型的企业应用程序并不会只包含一个对象（就是 Spring 里的 Bean）。即使是最简单的应用，也会有一些对象共同协作，以一个连贯的应用呈现给终端用户他们所看到的东西。下一节说明你如何从定义许多单独的 Bean Definition 到一个完整实现的应用程序，其中对象相互合作达到目的。
1.4.1. Dependency Injection依赖注入，对象通过构造函数参数、工厂方法的参数，或者在对象构造完毕之后设置到对象实例上的属性，或者工厂方法的返回值。
依赖注入存在两种主要的变体：

基于构造函数的依赖注入
基于 Setter 的依赖注入

Constructor-based Dependency Injection基于构造函数的依赖注入是通过容器调用具有多个参数的构造函数来完成，每个参数代表一个依赖项。
Constructor Argument Resolution构造函数参数解析通过参数类型匹配。如果 bean 定义的构造函数参数中不存在潜在的歧义，那么在 bean 定义中定义的构造函数参数的顺序就是当 bean 实例化时提供给构造器的参数的顺序。
Constructor argument type matching如果使用 type 属性显式指定构造函数参数类型，则容器可以使用简单类型的类型匹配。
&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;    &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt;    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;42&quot;/&gt;&lt;/bean&gt;


&amp;nbsp;Constructor argument index解决构造函数参数歧义：可以通过 index 属性指定构造函数参数的索引（从 0 开始）。
&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;    &lt;constructor-arg index=&quot;0&quot; value=&quot;7500000&quot;/&gt;    &lt;constructor-arg index=&quot;1&quot; value=&quot;42&quot;/&gt;&lt;/bean&gt;


Constructor argument name可以使用 name 属性消除构造器参数歧义。
&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;    &lt;constructor-arg name=&quot;years&quot; value=&quot;7500000&quot;/&gt;    &lt;constructor-arg name=&quot;ultimateAnswer&quot; value=&quot;42&quot;/&gt;&lt;/bean&gt;

类似 MyBats 的 @Param，你需要将启用代码的 debug 编译，否则 Spring 无法找到参数名。

如果不希望使用 debug 编译，则使用 @ConstructorProperties 指定构造器参数名。
@ConstructorProperties(&#123;&quot;years&quot;, &quot;ultimateAnswer&quot;&#125;)public ExampleBean(int years, String ultimateAnswer) &#123;    this.years = years;    this.ultimateAnswer = ultimateAnswer;&#125;


Setter-based Dependency Injection理论上来说，基于 Setter 的依赖注入是容器在调用无参构造函数或者无参静态工厂方法实例化 bean 之后，再调用 bean 的 setter 方法完成。
ApplicationContext 对于它管理的 bean，支持基于构造器的依赖注入，也支持基于 setter 的依赖注入。它还支持，在已经通过构造器注入了一些依赖之后，继续用 setter 注入依赖。
可以用 BeanDefinition 的形式配置依赖项，将其与 PropertyEditior 实例结合使用以将属性从一种格式转换为另一种格式。但是，一般不这样使用编程方式工作，而是用 XML 的 bean 定义，注解，或者 @Configuration + @Bean 方式。然后这些源转换成 BeanDefinition 的实例，用于加载 Spring IoC 容器。
Dependency Resolution Process容器执行 Bean 依赖解析如下：

创建 ApplicationContext 并使用描述所有 Bean 的配置元数据初始化。配置元数据可以以 XML，Java 代码，或者注解方式指定。
对于每个 Bean，它的依赖项以属性，构造器参数，或者静态工厂方法（如果你使用它而不是普通构造器）参数的形式表示。实际创建 Bean 时，这些依赖项将提供给 Bean。
每个属性或者构造器参数是要设置的值的实际定义，或者是对容器中另一个 Bean 的引用
每个属性或者构造器参数从指定格式转换为该属性或者构造器参数的实际类型。默认地，Spring 可以将字符串格式转换为所有内置类型，如 int，long，String，boolean 等。

1.4.2. Dependencies and Configuration in Detail你可以定义 bean 属性，构造器参数作为引用其他被管理的 bean，或者作为内联值。Spring 的基于 XML 配置元数据支持在 &lt;property/&gt; 以及 &lt;constructor-arg/&gt; 之中的子元素类型。
Straight Values (Primitives, Strings, and so on)&lt;property/&gt; 元素的属性 value 将一个属性或者构造器参数指定为一个人可读的表现形式。Spring 的 conversion service 用于将这些值从 String 转换为属性或者参数的实际类型。以下示例展示了各种值的设置：
&lt;bean id=&quot;myDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;    &lt;!-- results in a setDriverClassName(String) call --&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mydb&quot;/&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;misterkaoli&quot;/&gt;&lt;/bean&gt;

你还可以配置 java.util.Properties 示例，如下：
&lt;bean id=&quot;mappings&quot;    class=&quot;org.springframework.context.support.PropertySourcesPlaceholderConfigurer&quot;&gt;    &lt;!-- typed as a java.util.Properties --&gt;    &lt;property name=&quot;properties&quot;&gt;        &lt;value&gt;            jdbc.driver.className=com.mysql.jdbc.Driver            jdbc.url=jdbc:mysql://localhost:3306/mydb        &lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;

The idref elementideref 元素是一种错误校验方式，将容器中另一个 bean 的 id 传递给 &lt;constructor-arg/&gt; 或者 &lt;property/&gt; 元素。
&lt;bean id=&quot;theTargetBean&quot; class=&quot;...&quot;/&gt;&lt;bean id=&quot;theClientBean&quot; class=&quot;...&quot;&gt;    &lt;property name=&quot;targetName&quot;&gt;        &lt;idref bean=&quot;theTargetBean&quot;/&gt;    &lt;/property&gt;&lt;/bean&gt;
上面的 bean 定义片段等价于下面的：
&lt;bean id=&quot;theTargetBean&quot; class=&quot;...&quot; /&gt;&lt;bean id=&quot;client&quot; class=&quot;...&quot;&gt;    &lt;property name=&quot;targetName&quot; value=&quot;theTargetBean&quot;/&gt;&lt;/bean&gt;

第一个形式比第二个更好，因为使用 idref 标记允许容器在部署期间验证所引用的有名 bean 是否实际存在。
1.4.3. Using depends-on如果一个 Bean 是另一个 Bean 的依赖项，那通常意味着该 Bean 被设置为另一个 Bean 的属性。通常，你可以在基于 XML 的配置元数据中使用 &lt;ref/&gt; 元素来完成此操作。但是，有时候 Bean 之间的依赖不太直接。一个例子是，需要触发类中的静态初始化器，例如数据库驱动程序注册。depends-on 属性可以显式强制在使用该元素（depends-on）的 Bean 初始化之前，初始化一个或多个 bean。下面的示例使用 depends-on 属性来表达对单个 bean 的依赖性：
&lt;bean id=&quot;beanOne&quot; class=&quot;ExampleBean&quot; depends-on=&quot;manager&quot;/&gt;&lt;bean id=&quot;manager&quot; class=&quot;ManagerBean&quot; /&gt;

要表达对多个 bean 的依赖性，请提供 Bean 名称的列表作为依赖性属性的值（逗号，空格，分号是有效的分隔符）：
&lt;bean id=&quot;beanOne&quot; class=&quot;ExampleBean&quot; depends-on=&quot;manager,accountDao&quot;&gt;    &lt;property name=&quot;manager&quot; ref=&quot;manager&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;manager&quot; class=&quot;ManagerBean&quot; /&gt;&lt;bean id=&quot;accountDao&quot; class=&quot;x.y.jdbc.JdbcAccountDao&quot; /&gt;

1.4.4. Lazy-initialized Beans默认地，ApplicationContext 实现类会迅速创建并配置所有的单例 bean，这作为初始化过程的一部分。通常，这种预启动是可取的，因为可以立即发现配置或者环境中的错误，而不是几个小时，甚至几天之后才发现。当这种行为不可取时，你可以通过将 Bean Definition 标记为懒初始化来防止对单例 bean 的预实例化。懒初始化 bean 告诉 IoC 容器首次请求时要创建一个 bean 实例，而不是在启动时创建一个 bean 实例。
在 XML 中，此行为由 &lt;bean/&gt; 元素上的 lazy-init 属性控制，如下示例所示：
&lt;bean id=&quot;lazy&quot; class=&quot;com.something.ExpensiveToCreateBean&quot; lazy-init=&quot;true&quot;/&gt;&lt;bean name=&quot;not.lazy&quot; class=&quot;com.something.AnotherBean&quot;/&gt;

当前面的配置被 ApplicationContext 消费时，在 ApplicationContext 启动时，lazy bean 不会迅速地预启动，然而 not.lazy bean 会迅速地预实例化。
但是，当一个懒初始化 bean 是一个非懒初始化的单例 bean 的依赖时，ApplicationContext 在启动时会创建初始化 bean，因为它必须满足单例的依赖性。懒初始化 bean 被注入到别的非懒初始化的单例 bean 中。
你还可以通过使用 &lt;beans/&gt; 元素上的 default-lazy-init 属性来控制容器级别的懒初始化，如以下示例所示：
&lt;beans default-lazy-init=&quot;true&quot;&gt;    &lt;!-- no beans will be pre-instantiated... --&gt;&lt;/beans&gt;

1.4.5. Autowiring CollaboratorsSpring 容器可以自动绑定协作 Bean 之间的关系。你可以让 Spring 自动地通过审查 ApplicationContext 的内容为你的 Bean 解析协作者的话（其他 Bean）。自动绑定有如下优势：

自动绑定可以大大减少指定属性或者构造器参数的需求。
自动绑定可以随着对象的进化更新配置。

Limitations and Disadvantages of Autowiring考虑自动绑定的局限性和劣势：

在 property 和 constructor-arg 设置上的显式依赖总是会覆盖自动绑定。你不能自动绑定简单属性，例如原生类型，Strings，以及 Classes。这种限制是设计如此的。
自动绑定不如显式绑定精确。虽然，如前面表格所述，Spring 在可能有产生无法预测结果的歧义情况下，小心地避免猜测。你由 Spring 管理的对象之间的关系不再明确记录。
那些能够从 Spring 容器中生成文档的工具可能无法获得自动绑定信息
可能容器中多个 Bean Definition 都可以匹配待绑定的 Setter 方法或者构造器参数指定的类型。对于数字，集合，或者 Map 实例，这未必是个问题。但是，对于期望单个值得依赖，这种歧义无法解决。如果没有唯一得 Bean Definition，则会抛出异常。1.4.6. Method Injection在大多数应用场景中，多数的 bean 都是单例。当一个单例 bean 需要与另一个单例 bean 协作，或者一个非单例 bean 需要与另一个非单例 bean 协作，你通常会定义其中一个 bean 为另一个的属性来处理依赖关系。当 bean 的生命周期不同时，就会出现问题。假设单例 bean A 需要使用非单例（prototype）bean B，也许是在 A 的每个方法调用上。容器只会创建单例 bean A 一次，因此，只有一个机会可以设置属性 。不可能每次需要时容器都为 bean A 提供一个新的 bean B 实例。


作者的话 官方的意思应该是 bean A 的方法调用都需要一个全新的 bean B，而不是复用同一个，但是在遵循控制反转的规则下，又无法每次需要时从容器中得到一个全新的 bean B。

解决方案是放弃一些控制反转。你可以让 bean A 实现 ApplicationContextAware 接口来感知容器，并且，每当 bean A 需要的时候，通过调用容器的 getBean(&quot;B&quot;) 请求（通常是新的）一个 bean B 实例。
1.5. Bean Scopes当你创建一个 Bean Definition 时，你就是创建了一个用于创建该 Bean Definition 定义的 class 实例的配方。Bean Definition 时一个配方的想法很重要，因为它意味着，如 class 一样，你可以从一个配方中创建许多对象实例。
Spring Framework 支持 6 个范围，其中四个仅在使用 web-aware ApplicationContext



Scope
Description



singleton
（默认值）对于每个 Spring IoC 容器，将单个 Bean Definition 范围示为单个对象实例


prototype
将单个 Bean Definition 范围示为任意数量的对象实例


request
将单个 Bean Definition 作用于单个 HTTP 请求的生命周期。也就是说，每个 HTTP 请求都有自己的 Bean 实例，该实例是在单例 Bean Definition 后面创建的。只有在支持 Web 的 SpringApplicationContext 上下文中才有效。


session
将单个 Bean Definition 作用于 HTTP Session 的生命周期。只有在支持 Web 的 Spring 的 ApplicationContext 上下文中才有效。


application
将单个 Bean Definition 作用于 ServletContext 的生命周期。只有在支持 Web 的 Spring 的 ApplicationContext 的上下文中才有效


websocket
将单例 Bean Definition 作用于 WebSocket 的生命周期。只有在支持 Web 的 Spring 的 ApplicationContext 上下文中才有效。


1.5.1. The Singleton Scope1.5.4. Request, Session, Application, and WebSocket Scopesrequest，session，application，websocket 作用域只有在使用 Web 感知的 Spring 的 ApplicationContext 实现（例如，XmlWebApplicationContext）时才可用。
Request scope考虑以下关于 Bean Definition 的 XML 配置:
&lt;bean id=&quot;loginAction&quot; class=&quot;com.something.LoginAction&quot; scope=&quot;request&quot;/&gt;

Spring 容器通过对每个 HTTP 请求使用 loginAction Bean Definition 来创建 LoginAction Bean 的新实例。也就是说，loginAction Bean 的作用域是 HTTP 请求级别。你可以随心所欲地更改创建的实例的内部状态，因为从同一个 loginAction Bean Definition 创建的其他实例不会看到这些状态的改变。他们对每个请求都比较特别。当请求完成处理时，作用域为该请求的 Bean 将被丢弃。
当使用注解驱动组件或者 Java 配置时，@RequestScope 注解将组件分配给 request 作用域。下面的例子说明了如何做到这一点:
@RequestScope@Componentpublic class LoginAction &#123;    // ...&#125;




1.6. Customizing the Nature of a BeanSpring Framework 提供了许多可用的接口来自定义 bean 的性质。本节将它们分组为如下：

Lifecycle Callbacks
ApplicationContextAware and BeanNameAware
Other Aware Interfaces

1.6.1. Lifecycle Callbacks要与 Bean 生命周期的容器管理交互，你可以实现 Spring 的 InitializingBean 和 DisposableBean 接口。该容器为前者调用 afterPropertiesSet()，为后者调用调用 destroy()，这使得在 bean 的初始化和销毁时执行某些操作。

作者的话 InitializingBean 方法的调用是通过创建 bean 的过程中由 AbstractAutowireCapableBeanFactory 调用 invokeInitMethods 方法实现的，该方法除了调用接口实现的方法，还可以触发自定义 init 方法的调用

在内部，Spring Framework 使用 BeanPostProcessor 实现类来处理任何它能找到的回调接口，并调用适当的方法。如果你需要自定义功能或者其他 Spring 默认没有提供的生命周期行为，则可以自己实现一个 BeanPostProcessor。更多信息，参见 Container Extension Points。

作者的话 准确来说，是由 CommonAnnotationBeanPostProcessor 来调用生命周期方法的，而 CommonAnnotationBeanPostProcessor 又是 InitDestroyAnnotationBeanPostProcessor 的子类，后者实现了调用逻辑。

除了初始化和销毁的回调外，被 Spring 管理的对象还可以实现 Lifecycle 接口，以便于这些对象能够参与由容器自己的生命周期驱动的启动和关闭过程。
Lifecycle 回调接口在本节中有描述。
减少与 Spring 的耦合，JSR-250 最佳实践：

@PostConstruct
@PreDestroy

不想使用 JSR-250，可以考虑：

init-method
destroy-method

Spring 使用 BeanPostProcessor 实现来处理找到的任何回调接口并调用适当的方法。可以自定义功能。
Initialization Callbacksorg.springframework.beans.factory.InitializingBean 接口让 bean 可以在容器设置所有必要的属性之后执行初始化工作。InitializingBean 接口指定了一个方法：
void afterPropertiesSet() throws Exception;

我们建议你不要使用 InitializingBean 接口，因为它不必要地将代码耦合到 Spring。另外，我们建议使用 @PostConstruct 注解或者指定一个 POJO 初始化方法。对于基于 XML 的配置元数据，你可以使用 init-method 属性来指定一个返回值为 void，没有参数签名的方法。对于 Java 配置，你可以使用 @Bean 的 initMethod 属性。考虑如下示例：

作者的话 如果你没有指定返回值为 void 的无参方法，那么就会启动抛出异常。


作者的话 如果你对调用初始化回调方法顺序并没有严格的需求，那么你完全可以用 @PostConstruct 注解来完成，从而忽视 init 方法或者 InitializingBean 接口。而且，@PostConstruct 注解方法可以配置多个，init 方法或者 InitializingBean 只能指定一个。

&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.ExampleBean&quot; init-method=&quot;init&quot;/&gt;

public class ExampleBean &#123;    public void init() &#123;        // do some initialization work    &#125;&#125;

上面的示例的效果几乎与下面示例效果完全相同：
&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.AnotherExampleBean&quot;/&gt;

public class AnotherExampleBean implements InitializingBean &#123;    @Override    public void afterPropertiesSet() &#123;        // do some initialization work    &#125;&#125;

但是，前面两个示例中的第一个不会将代码与 Spring 耦合。
Destruction Callbacks实现 DisposableBean 接口可以让 bean 在容器销毁它时执行回调。
给 destroy-method 或者 default-destroy-method 赋予特殊值 (inferred) 会进行方法推断，如：java.io.Closeable，java.lang.AutoCloseable 的实现方法。
&amp;nbsp;
Default Initialization and Destroy Methods在 &lt;beans&gt; 指定属性：

default-init-method
default-destroy-method

此属性可以被 &lt;bean&gt; 的属性 init-method 和 destroy-method 覆盖
Combining Lifecycle Mechanisms为同一个 bean 配置多个生命周期机制，具有不同的初始化方法，调用如下：

@PostConstruct 方法
InitializingBean.afterPropertiesSet() 方法
自定义配置的 init() 方法

销毁方法类似：

@PreDestroy
DisposableBean.destroy()
自定义配置的 destroy()

Startup and Shutdown CallbacksLifecycle 接口为那些有自己生命周期需求的对象定义了必要的方法（例如启动或停止某些后台处理过程）：
public interface Lifecycle &#123;    void start();    void stop();    boolean isRunning();&#125;

任何被 Spring 管理的对象都可以实现 Lifecycle 接口。然后，当 ApplicationContext 本身接收启动和停止信号时，它会汇总定义在该上下文中的所有 Lifecycle 实现类的调用。它通过委托给 LifecycleProcessor 做到这一点，如下列表所示：
public interface LifecycleProcessor extends Lifecycle &#123;    void onRefresh();    void onClose();&#125;

注意，LifecycleProcessor 本身就是 Lifecycle 接口的扩展。它还添加了两个其他的方法，用于响应上下文的刷新和关闭。

注意，常规的 org.springframework.context.Lifecycle 接口明确的启动和停止通知的简单合同，并不意味着在上下文刷新事件内自动启动。要对特定 bean 的自动启动（包括启动阶段）进行细粒度的控制，考虑实现 org.springframework.context.SmartLifecycle。

启动和关闭调用的顺序可能很重要。如果任何两个对象之间存在”依赖”关系，则依赖侧在其依赖之后启动，并且在其依赖之前停止。但是，有时候直接依赖性是未知的。你可能只知道某种类型的对象应该在其他类型对象之前开始。在这种情况下，SmartLifecycle 接口定义了另一个选项，即在父接口上定义的 getPhase() 方法。如下几列展示了 Phased 接口的定义：
public interface Phased &#123;    int getPhase();&#125;
以下几行展示了 SmartLifecycle 接口的定义：
public interface SmartLifecycle extends Lifecycle, Phased &#123;    boolean isAutoStartup();    void stop(Runnable callback);&#125;

启动时，最低阶段的对象首先启动。停止时，遵循反向顺序。因此，实现 SmartLifecycle 及其 getPhase() 方法返回 Integer.MIN_VALUE 将是第一个启动，最后一个停止的对象。
Shutting Down the Spring IoC Container Gracefully in Non-Web Applications
本节仅适用于非 Web 应用。当关闭相关的 Web 应用时，Spring 基于 Web 的 ApplicationContext 实现已经有了适当的代码，可以优雅地关闭 Spring IoC 容器。

1.6.2. ApplicationContextAware and BeanNameAware当 ApplicationContextAware 创建一个实现了 org.springframework.context.ApplicationContextAware 接口的对象实例时，会提供一个 ApplicationContext 的引用给该实例。下面几行展示了 ApplicationContextAware 接口的定义：
public interface ApplicationContextAware &#123;    void setApplicationContext(ApplicationContext applicationContext) throws BeansException;&#125;

因此，bean 可以通过 ApplicationContext 接口或者通过将引用转换到该接口的已知子类（例如 ConfigurableApplicationContext，其暴露了额外的功能），从而程序化地操纵创建它们的 ApplicationContext。一种用法是对其他 bean 的程序化检索。有时候这种功能很有用。但是，总的来说你应该避免它，因为它将代码耦合到 Spring，并且不遵循 IoC 风格，此时将合作者的话作为属性提供给 bean。ApplicationContext 的其他方法提供了对文件资源的访问，发布应用事件，以及访问 MessageSource。这些附加功能在 Additional Capabilities of the ApplicationContext 中进行了描述。
自动绑定时对获得 ApplicationContext 的引用的另一种替代方式。传统的 constructor 以及 byType 自动绑定模式可以分别为构造函数参数或者 setter 方法参数提供 ApplicationContext 类型的依赖。为了获得更多灵活性，包括自动绑定字段以及多参数方法的能力，请使用基于注解的自动绑定特性。如果你这样做了，并且字段，构造器，或者方法携带了@Autowired 注解，那么ApplicationContext 将自动绑定到一个字段，构造器参数，或者期望 ApplicationContext 类型的方法参数。更多信息，参见 Using @Autowired。

使用 @Autowired 获得 ApplicationContext

当 ApplicationContext 创建了一个实现 org.springframework.beans.factory.BeanNameAware 接口的类时，它会给该类提供定义在其关联对象定义中的名称引用。下面几行展示了 BeanNameAware 接口的定义：
public interface BeanNameAware &#123;    void setBeanName(String name) throws BeansException;&#125;


在普通 bean 属性填充之后，但是在例如 InitializingBean，afterPropertiesSet，或者自定义的 init-method 初始化回调之前调用该回调。

作者的话 所以，顺序应该是填充属性（populate），Aware 回调，init 回调。

1.6.3. Other Aware Interfaces除了 ApplicationContextAware 和 BeanNameAware（前面讨论过）之外，Spring 还提供了广泛的 Aware 回调接口，使得 bean 向容器指示它们需要一定的基础架构依赖。正如一般规则，名称表示依赖类型。下表总结了最重要的几个 Aware 接口：



Name
Injected Dependency
Explained in…​



ApplicationContextAware




ApplicationEventPublisherAware




BeanClassLoaderAware




BeanFactoryAware




BeanNameAware




BootstrapContextAware




LoadTimeWeaverAware




MessageSourceAware




NotificationPublisherAware




ResourceLoaderAware




ServletConfigAware




ServletContextAware




1.7. Bean Definition InheritanceBean Definition 可以包含许多配置信息，包括构造器参数，属性值，特定于容器的信息，例如初始化方法，静态工厂方法名等。子 Bean Definition 从父 Definition 继承配置数据。子 Definition 可以覆盖一些值，或者根据需要添加其他值。使用父子 Bean Definition 可以节约大量键入。有效地，这是一种模板。
如果你以编程的方式使用 ApplicationContext 接口，那么子 Bean Definition 以 ChildBeanDefinition 类标表示。大多数用户在这一层不与它们合作。相反，它们在类中声明式配置 Bean Definition，例如 ClassPathXmlApplicationContext。当你使用基于 XML 的配置元数据时，你可以通过使用 parent 属性来指示子 Bean Definition，将父 bean 指定为该属性的值。下面的示例展示了怎么做：
&lt;bean id=&quot;inheritedTestBean&quot; abstract=&quot;true&quot;        class=&quot;org.springframework.beans.TestBean&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;parent&quot;/&gt;    &lt;property name=&quot;age&quot; value=&quot;1&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;inheritsWithDifferentClass&quot;        class=&quot;org.springframework.beans.DerivedTestBean&quot;        parent=&quot;inheritedTestBean&quot; init-method=&quot;initialize&quot;&gt;      &lt;property name=&quot;name&quot; value=&quot;override&quot;/&gt;    &lt;!-- the age property value of 1 will be inherited from parent --&gt;&lt;/bean&gt;


1.8. Container Extension Points通常，应用程序开发者不必子类化 ApplicationContext 实现类。取而代之的是，可以通过插入特殊集成接口实现来扩展 Spring IoC 容器。接下来几节描述了这些集成接口。
1.8.1. Customizing Beans by Using a BeanPostProcessorBeanPostProcessor 接口定义了一些回调方法，你可以实现它们来提供自己的实例化逻辑（或者覆盖容器默认的），依赖解析逻辑等。如果你要在 Spring 容器完成实例化，配置，初始化 bean 之后，实现一些自己的逻辑，则可以插入一个或多个自定义的 BeanPostProcessor 实现。
你可以配置多个 BeanPostProcessor 实例，并且通过设置 order 属性控制这些 BeanPostProcessor 实例执行顺序。你只有在 BeanPostProcessor 实现 Ordered 接口时才能设置此属性。如果你编写自己的 BeanPostProcessor，则也应该考虑实现 Ordered 接口。有关更多信息，请参阅 BeanPostProcessor 和 Ordered 接口的 javadoc。另请参见 programmatic registration of BeanPostProcessor instances.

如果要更改实际的 bean 实例，则需要使用 BeanPostProcessor。虽然，技术上可以通过 BeanFactoryPostProcessor 实现（如：beanFactory.get()），但是这样会导致 bean 过早实例化，违反了标准的容器生命周期。而且，这会产生副作用，如：绕过 bean 的后置处理。

org.springframework.beans.factory.config.BeanPostProcessor 接口刚好由 2 个回调方法组成。当这样的类以 post-processor 注册到容器中时，post-processor 在容器初始化方法调用之前，且在任何 bean 初始化回调之后，都会从容器中获得回调。Post Processor 可以对 bean 实例进行任何操作，包括完全忽略回调。一个 Bean Post Processor 通常检查回调接口，或者可能包装带有代理的 bean。一些 Spring AOP 基础架构类以 Bean Post Processor 进行实现，以提供代理包装逻辑
ApplicationContext 自动检测实现了 BeanPostProcessor 接口的定义在配置元数据中的任何 bean。ApplicationContext 将这些 bean 注册为后置处理器，以便以后再 bean 创建时可被调用。Bean Post Processor 可以与其他任何 bean 以相同的方式部署到容器中。
请注意，当通过在 Configuration 类上使用 @Bean 工厂方法声明 BeanPostProcessor 时，工厂方法的返回类型应该时实现类本身，或者至少是 org.springframework.beans.factory.config.BeanPostProcessor 接口，清晰表明该 bean 的后置处理性质。否则，ApplicationContext 在完全创建它之前将无法通过类型自动检测到。由于需要尽早实例化 BeanPostProcessor 才能应用于上下文中其他 bean 的初始化，因此这种早期类型检测至关重要。

作者的话 如果你的 BeanPostProcessor 不仅实现了 BeanPostProcessor 还实现了其他接口或者继承了其他类，那么 @Bean 返回类型必须使用 BeanPostProcessor 否则 Spring 无法识别到

具体的底层代码可以阅读 AbstractAutowireCapableBeanFactory#initializeBean()，其中在调用 invokeInitMethods() 方法的前后分别调用了 applyBeanPostProcessorsBeforeInitialization() 和 applyBeanPostProcessorsAfterInitialization()。



常见的 BeanPostProcessor
描述



CommonAnnotationBeanPostProcessor
用于执行 @PostConstruct @PreDestroy 注解的方法


AutowiredAnnotationBeanPostProcessor
用于自动注入 @Autowired @Value @Inject


Example: Hello World, BeanPostProcessor-styleExample: The AutowiredAnnotationBeanPostProcessor使用回调接口或者注解，配合自定义的 BeanPostProcessor 实现是扩展 Spring IoC 容器的常见手段。一个例子是 Spring AutowiredAnnotationBeanPostProcessor —— 这是 BeanPostProcessor 的一个实现类，其与 Spring 分布和 @Autowired 注解字段，Setter 方法，以及任意配置方法一起
1.8.2. Customizing Configuration Metadata with a BeanFactoryPostProcessorBeanFactoryPostProcessor 是一个扩展点。BeanFactoryPostProcessor 与 BeanPostProcessor 语义类似，但有一个主要区别：BeanFactoryPostProcessor 对 bean 配置元数据进行操作。Spring Ioc 容器允许 BeanFactoryPostProcessor 读取配置元数据，并且可以在实例化除了 BeanFactoryPostProcessor 任何 bean 之前修改这些配置元数据。

BeanDefinitionRegistryPostProcessor 是 BeanFactoryPostProcessor 的子接口。

可以配置多个 BeanFactoryPostProcessor 实例，并通过 order 属性来控制这些实例的运行顺序。如果编写自己的 BeanFactoryPostProcessor，也应该考虑实现 Ordered 接口。
为了应用这些改变到容器中的配置元数据，当 bean factory 后置处理器声明在 ApplicationContext 中时，它会自动执行。Spring 包含了许多预定义的 bean factory 后置处理器，比如 PropertyOverrideConfigurer 以及 PropertySourcesPlaceholderConfigurer。
1.9. Annotation-based Container Configuration
配置 Spring 注解比 XML 更好吗？
引入基于注解的配置出现了一个问题，即这种方式是否比 XML 更好。简短的答案是：看情况。具体就是，每种方法都有其优点和缺点，通常，开发人员决定哪种测策略更适合他们。由于他们的定义方式，注解在声明的时候提供许多上下文，使得配置更短，更简洁。但是，XML 擅于在不触及源代码以及重新编译的情况下，将组件关联起来。一些开发者更喜欢让关联接近源代码，而另一个开发者人为注解类不再是 POJO，此外，配置变得分散且难以控制。


Spring 2.0 引入 @Required 强化需要的属性

基于注解得配置提供了 XML 设置的可替代方案，该方案依赖于字节码元数据来绑定组件而不是声明。无需使用 XML 去描述 Bean 的绑定，开发者只需将配置移动到组件类本身，在相关的类，方法，或者字段声明上面使用注解。如 Example: The AutowiredAnnotationBeanPostProcessor 所述，结合注解使用 BeanPostProcessor 是扩展 Spring IoC 容器的通用方式。
1.9.1. @Required@Required 注解用于 bean 的 Setter 方法，如下示例：
public class SimpleMovieLister &#123;    private MovieFinder movieFinder;    @Required    public void setMovieFinder(MovieFinder movieFinder) &#123;        this.movieFinder = movieFinder;    &#125;    // ...&#125;


作者的话 该注解只能使用在方法上

该注解表示，受影响的 Bean 属性必须在配置期间填充属性，无论是通过 Bean Definition 中明确的属性值，还是自动绑定。如果受影响的属性并没有填充，则容器会抛出一个异常。这是考虑到尽早且明确的故障，以免以后 NullPointerException 实例或者此类的问题。我们依然建议你将断言放到 bean 类本身（例如，放入 init 方法）。这样做甚至可以当你在容器之外使用类时，也能强制需要的引用和值。

RequiredAnnotationBeanPostProcessor 必须注册为一个 bean，以支持 @Required 注解


作者的话 Spring Boot 默认是不注册 RequiredAnnotationBeanPostProcessor 的，因此需要手动导入，譬如使用 @Import


@Required 注解和 RequiredAnnotationBeanPostProcessor 在 Spring 框架 5.1 正式弃用，这是为了支持对必需的配置使用构造器注入（或者一个 InitializingBean.afterPropertiesSet() 自定义的实现，或者随着 Bean 属性 Setter 方法自定义的 @PostConstruct 方法。

1.9.2. Using @Autowired
在本节包含的示例中，你可以使用 JSR 330 的 @Inject 注解代替 Spring 的 @Autowired 注解。有关更多详情，参见此处。

你可以将 @Autowired 注解应用在构造器上，如下实例所示：
public class MovieRecommender &#123;    private final CustomerPreferenceDao customerPreferenceDao;    @Autowired    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;        this.customerPreferenceDao = customerPreferenceDao;    &#125;    // ...&#125;


从 Spring Framework 4.3 开始，如果目标 Bean 仅定义了一个构造器，则不再需要在该构造器上使用 @Autowired 注解。但是，如果有几个构造器可用，并且没有 primary 或者默认构造器，至少用 @Autowired 注解一个构造器，以便于指示容器用哪一个。

你也可以将 @Autowired 注解应用于传统的 Setter 方法，如下示例所示：
public class SimpleMovieLister &#123;    private MovieFinder movieFinder;    @Autowired    public void setMovieFinder(MovieFinder movieFinder) &#123;        this.movieFinder = movieFinder;    &#125;    // ...&#125;

你也可以将注解应用于具有任意名称和多个参数的方法，如下示例所示：
public class MovieRecommender &#123;    private MovieCatalog movieCatalog;    private CustomerPreferenceDao customerPreferenceDao;    @Autowired    public void prepare(MovieCatalog movieCatalog,            CustomerPreferenceDao customerPreferenceDao) &#123;        this.movieCatalog = movieCatalog;        this.customerPreferenceDao = customerPreferenceDao;    &#125;    // ...&#125;

你还可以将 @Autowird 应用在字段上，甚至混合构造器一起使用，如下示例所示：
public class MovieRecommender &#123;    private final CustomerPreferenceDao customerPreferenceDao;    @Autowired    private MovieCatalog movieCatalog;    @Autowired    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;        this.customerPreferenceDao = customerPreferenceDao;    &#125;    // ...&#125;

通过将 @Autowired 注解添加到字段或者期望数组类型的方法上，你可以指示 Spring 从 ApplicationContext 中提供所有特定类型的 Bean，如下示例所示：
public class MovieRecommender &#123;    @Autowired    private MovieCatalog[] movieCatalogs;    // ...&#125;

相同的也可以用在集合类型上，如下示例所示：
public class MovieRecommender &#123;    private Set&lt;MovieCatalog&gt; movieCatalogs;    @Autowired    public void setMovieCatalogs(Set&lt;MovieCatalog&gt; movieCatalogs) &#123;        this.movieCatalogs = movieCatalogs;    &#125;    // ...&#125;

甚至类型 Map 示例也可以自动绑定，只要期望的 Key 类型是 String。Map 的 value 包含所有期望类型的 Bean，kay 包含相关的 Bean 名称，如下示例所示：
public class MovieRecommender &#123;    private Map&lt;String, MovieCatalog&gt; movieCatalogs;    @Autowired    public void setMovieCatalogs(Map&lt;String, MovieCatalog&gt; movieCatalogs) &#123;        this.movieCatalogs = movieCatalogs;    &#125;    // ...&#125;

默认情况，当对于给定的注入点没有匹配的候选 Bean 可用时，自动绑定就会失败。在声明了数组，集合，或者 Map 情况下，期望至少有一个匹配的元素。
默认的行为是将注解的方法和字段视为必需的依赖。你可以如下示例所示，更改此行为，通过将其标记为非必需的（即，通过设置 @Autowired 属性 required 为 false），让框架跳过不满足的注入点：
public class SimpleMovieLister &#123;    private MovieFinder movieFinder;    @Autowired(required = false)    public void setMovieFinder(MovieFinder movieFinder) &#123;        this.movieFinder = movieFinder;    &#125;    // ...&#125;

如果一个非必需的方法依赖（或者在多参数情况下，有一个依赖）不可获得，那么该方法根本不会调用。在这种情况下，非必需的字段将根本不会被填充，保持默认值。
另外，你可以通过 Java 8 的 java.util.Optional 表达特定以来的非必需特性，如下示例所示：
public class SimpleMovieLister &#123;    @Autowired    public void setMovieFinder(Optional&lt;MovieFinder&gt; movieFinder) &#123;        ...    &#125;&#125;


@Autowired 用法：(1) 构造函数。若 bean 只有一个构造函数，则可不必。(2) setter 方法(3) 任意的方法(4) 字段(5) 数组、Collection、Map(6) java.util.Optional(7) BeanFactory，ApplicationContext，Environment，ResourceLoader，ApplicationEventPublisher，MessageSource 这些接口以及它们的扩展接口
指定类型数组、集合的顺序(1) org.springframework.core.Ordered(2) @Order 或者 @Priority 
@Autowired，@Inject、@Value、@Resource 会由 Spring 的 BeanPostProcessor 处理。因此，不能在自己的 BeanPostProcessor 或者 BeanFactoryPostProcessor 中使用这些注解（否则循环了）。
注入见：org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#postProcessProperties
1.9.3. Fine-tuning Annotation-based Autowiring with @Primary按照类型的自动绑定可能产生多个候选者，因此有必要使用更多的控制进行选择。其中一种方式就是使用 @Primary 注解。@Primary 注解表示，当多个 bean 候选者需要自动绑定到一个单值依赖上时，特定的 bean 应该给予优先权。如果多个候选者中存在一个主要的 bean，那么它将会自动绑定到值上。


BeanDefinition 接口方法 isPrimary() 正是描述了该 bean 是否具有优先权。
如果你注入了两个类型相同，且都标注了 @Primary 的 bean，而且通过类型获取单个 bean，那么将会抛出异常。具体逻辑见：DefaultListableBeanFactory#determinePrimaryCandidate



作者的话 该注解完全可以忽视，一般并不希望自动绑定出现歧义，或者直接使用 @Resource 进行准确绑定。

1.9.4. Fine-tuning Annotation-based Autowiring with Qualifiers当你需要在选择过程上有更多控制时，可以使用 @Qualifier 注解。你可以将 qualifier 的值与特定参数绑定，缩小类型匹配的集合，以便于能选出特定的那个 bean。
可以用于：字段、方法参数
@Autowired@Qualifier(&quot;main&quot;)private MovieCatalog movieCatalog;
@Autowiredpublic void prepare(@Qualifier(&quot;main&quot;) MovieCatalog movieCatalog, CustomerPreferenceDao customerPreferenceDao) &#123;    this.movieCatalog = movieCatalog;    this.customerPreferenceDao = customerPreferenceDao;&#125;



作为备用匹配，bean 的名称被当作默认的限定值。但是，即使你使用这个约定，通过名称引用一个 bean，@Autowired 本质上也是类型驱动注解，只是附带一个可选的语义限定符（在匹配类型的集合中缩小范围），并不能表示唯一一个 bean 的 id。
好的限定符应该表达一个与 bean ID 无关的特定组件的特征。


Qualifier 也可以适用于类型集合，比如 Set&lt;Object&gt;，这意味着限定者并不是唯一的，而是一个筛选条件。


如果你希望通过名称进行注解驱动注入，但不想使用 @Autowired，即使这是可以在类型匹配的候选者中选择对应名称的 bean，你可以使用 JSR-250 注解 @Resource，这是一个语义上定义为通过使用唯一名称标识特定组件的注解，与声明类型无关。


1.9.5. Using Generics as Autowiring Qualifiers除了显式使用 @Qualifier 注解，你可以使用 Java 泛型作为隐式的限定。
1.9.6. Using CustomAutowireConfigurerl1.9.7. Injection with @ResourceSpring 也支持 JSR-250 注解 @Resource，用于字段或者 bean 属性的 setter 方法。
@Resource 具有一个 name 属性。默认地，Spring 将该值当作被注入的 bean 的名字。


@Resource 注解不支持 static 字段。


如果没有指定 name，默认的名称将会从字段名或者 setter 方法中解析出来。没有显式地指定名称，类似于 @Autowired，@Resource 将查找主要地类型匹配而不是特定 名称，并且解析熟知的 BeanFactory, ApplicationContext, ResourceLoader, ApplicationEvenetPublisher, MessageSource 接口。
1.9.8. Using @Value@Value 典型的用法是注入外部的属性
使用位置：字段、方法参数

@Value(&quot;$&#123;catalog.name:defaultCatalog&#125;&quot;)，defaultCatalog 为默认值，用冒号隔开
@Value(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)，嵌套使用

Spring 默认是宽松解析，如果要严格解析，配置 PropertySourcesPlaceholderConfigurer，Spring Boot 是默认配置的（见 PropertyPlaceholderAutoConfiguration）。
1.9.9. Using @PostConstruct and @PreDestroyCommonAnnotationBeanPostProcessor 不仅能识别 @Resource 注解，还可以识别 JSR-250 生命周期注解：javax.annotation.PostConstruct 和 javax.annotation.PreDestroy。

在标准 JDK 6 到 JDK 8 中，@Resource, @PostConstruct, @PreDestroy 注解是其中的一部分。但是，整个 javax.annotation 包在 JDK 9 中与核心模块分开，并最终在 JDK 11 移除。如果需要，则应该通过 maven 中心获取 javax.annotation-api 组件，简单地添加到类路径中。

1.10. Classpath Scanning and Managed Components通过隐式地类路径扫描找到候选组件。候选组件是那些与过滤器标准相匹配的类，并且会有一个相关的 bean 定义被注册到容器中。这会消除使用 XML 执行 bean 定义的需求。取而代之的，你可以使用注解，AspectJ 类型表达式，或者你自己自定义的过滤器原则来挑选出注册到容器中的 bean 定义。
1.10.1. @Component and Further Stereotype Annotations@Repository 是那些具有仓库（也可以认为是 Data Access Object）作用的类的标记。
Spring 提供了更多注解：@Component, @Service, @Controller。@Component 对于任何 Spring 管理的组件来说，是一个通用注解。@Repository, @Service, @Controller 是 @Component 的特例。因此，你可以用 @Component 注解你的组件类，但是，通过用 @Repository, @Service, @Controller 注解，你的类可以更好地通过工具处理，或者与切面关联。
1.10.2. Using Meta-annotations and Composed AnnotationsSpring 提供的许多注解可以作为你自己代码的元注解，以供其他注解使用。
你可以组合元注解创建组合型注解。例如，@RestController 注解就是 Spring MVC 框架中，由 @Controller 和 @ResponseBody 组合而成。
1.10.3. Automatically Detecting Classes and Registering Bean DefinitionsSpring 可以自动检测刻板印象类，并注册相关的 BeanDefinition 实例到 ApplicationContext。例如，以下两个类有资格被自动检测到：
@Servicepublic class SimpleMovieLister &#123;    private MovieFinder movieFinder;    public SimpleMovieLister(MovieFinder movieFinder) &#123;        this.movieFinder = movieFinder;    &#125;&#125;

@Repositorypublic class JpaMovieFinder implements MovieFinder &#123;    // implementation elided for clarity&#125;

为了自动检测类并注册相关的 bean，需要将 @ComponentScan 添加到 @Configuraion 类上，其中，@ComponentScan 的 basePackages 属性是这些的共有父包。


你可以指定多个父包，以逗号（,）或者分号（;）或者空格分隔。


如果你使用 XML，则可以以如下代码替代：
&lt;context:component-scan base-package=&quot;org.example&quot;/&gt;

当你使用 &lt;component-scan/&gt; 元素时 ，AutowiredAnnotationBeanPostProcessor  和 CommonAnnotationBeanPostProcessor  两者会隐式地包含进来。


你可以通过包含 annotation-config，设置其值为 false 来禁用 AutowiredAnnotationBeanPostProcessor  和 CommonAnnotationBeanPostProcessor  的注册。


1.10.4. Using Filters to Customize Scanning默认地，本身是用 @Component 注解的类，会被检测作为候选组件。但是也可以配置过滤器。
1.10.5. Defining Bean Metadata within Components1.10.8. Providing Qualifier Metadata with Annotations1.11. Using JSR 330 Standard Annotations从 Spring 3.0 开始，Spring 为 JSR-330 标准注解（依赖注入）提供了支持。这些注解与 Spring 注解一样以相同的方式被扫描。要使用他们，你必须在类路径中持有相关的 jar 包。

如果你使用 maven，javax.inject 的 artifact 可以在标准 maven 仓库（https://repo1.maven.org/maven2/javax/inject/javax.inject/1/）直接获得。你可以将下面的依赖添加到 pom.xml：
&lt;dependency&gt;   &lt;groupId&gt;javax.inject&lt;/groupId&gt;   &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;   &lt;version&gt;1&lt;/version&gt;&lt;/dependency&gt;

1.11.1. Dependency Injection with @Inject and @Named为了代替 @Autowired，你可以使用 @javax.inject.Inject，如下所示：
import javax.inject.Inject;public class SimpleMovieLister &#123;    private MovieFinder movieFinder;    @Inject    public void setMovieFinder(MovieFinder movieFinder) &#123;        this.movieFinder = movieFinder;    &#125;    public void listMovies() &#123;        this.movieFinder.findMovies(...);        // ...    &#125;&#125;

与 @Autowired 一样，你可以在字段级别，方法级别，构造函数级别内使用 @Inject。此外，你可以将注入点声明为一个 Provider，从而可以按需访问较短的范围或者通过调用 Provider.get() 来懒惰地访问其他 Bean。以下的示例提供了前面示例的变体：
import javax.inject.Inject;import javax.inject.Provider;public class SimpleMovieLister &#123;    private Provider&lt;MovieFinder&gt; movieFinder;    @Inject    public void setMovieFinder(Provider&lt;MovieFinder&gt; movieFinder) &#123;        this.movieFinder = movieFinder;    &#125;    public void listMovies() &#123;        this.movieFinder.get().findMovies(...);        // ...    &#125;&#125;

如果你想使用注入依赖的限定名称，可以使用 @Named 注解，如下示例所示：
import javax.inject.Inject;import javax.inject.Named;public class SimpleMovieLister &#123;    private MovieFinder movieFinder;    @Inject    public void setMovieFinder(@Named(&quot;main&quot;) MovieFinder movieFinder) &#123;        this.movieFinder = movieFinder;    &#125;    // ...&#125;
与 @Autowired 一样，@Inject 也可以与 java.util.Optional 或者 @Nullable 一起使用。在这里甚至更合适，因为 @Inject 没有 require 属性。以下一对示例展示了如何使用 @Inject 和 @Nullable：
public class SimpleMovieLister &#123;    @Inject    public void setMovieFinder(Optional&lt;MovieFinder&gt; movieFinder) &#123;        // ...    &#125;&#125;


1.11.2. @Named and @ManagedBean: Standard Equivalents to the @Component Annotation你可以使用 @javax.inject.Named 或者 @javax.annotation.ManagedBean 代替 @Component，如下示例所示：
import javax.inject.Inject;import javax.inject.Named;@Named(&quot;movieListener&quot;)  // @ManagedBean(&quot;movieListener&quot;) could be used as wellpublic class SimpleMovieLister &#123;    private MovieFinder movieFinder;    @Inject    public void setMovieFinder(MovieFinder movieFinder) &#123;        this.movieFinder = movieFinder;    &#125;    // ...&#125;

使用 @Component 而不为组件指定名称非常常见。@Named 可以以类似的方式使用，如下示例所示：
import javax.inject.Inject;import javax.inject.Named;@Namedpublic class SimpleMovieLister &#123;    private MovieFinder movieFinder;    @Inject    public void setMovieFinder(MovieFinder movieFinder) &#123;        this.movieFinder = movieFinder;    &#125;    // ...&#125;

当你使用 @Named 或者 @ManagedBean 时，你可以以与使用 Spring 注解时完全相同方式进行组件扫描，如下示例所示：
@Configuration@ComponentScan(basePackages = &quot;org.example&quot;)public class AppConfig  &#123;    // ...&#125;


与 @Component 相反，JSR-330 @Named 和 JSR-250 @ManagedBean 注解是不可组合的。你应该使用 Spring 的刻板印象模型来构建自定义的注解。


作者的话 之所以无法构建自定义的组合注解，是因为 Spring 不会去检查你的自定义注解。见 ClassPathScanningCandidateComponentProvider 的 includeFilters。

1.11.3. Limitations of JSR-330 Standard Annotations当你使用标准注解时，你应该知道，有一些重要功能是不可用的，如下表所示：



Spring
java.inject.*
javax.inject restrictions &#x2F; comments



@Autowired
@Inject
@Inject 没有 required 属性。可以用 Java 8 的 Optional 替代


@Component
@Named &#x2F; @ManagedBean
JSR-330 未提供组合的模型，只是一种识别命名组件的方式


@Scope(“singleton”)
@Singleton
JSR-330 默认范围就像 Spring 的 prototype。但是，为了使其与 Spring 的一般默认值保持一致，声明在 容器中的 JSR-330 Bean 默认是 singleton。为了使用 singleton 意外的范围，你应该使用 Spring 的 @Scope 注解。javax.inject 也提供了一个 @Scope 注解。然而，这仅仅用于创建你自己的注解。


@Qualifier
@Qualifier &#x2F; @Named
javax.inject.Qualifier 仅仅是一个用于构建自定义 qualifier 的元注解。可以通过 javax.inject.Named 关联具体的 String 限定词（就像 Spring 带有一个值的 @Qualifier）


@Value
-
没有对等体


@Required
-
没有对等体


@Lazy
-
没有对等体


ObjectFactory
Provider



1.12. Java-based Container Configuration1.12.1. Basic Concepts: @Bean and @Configuration在 Spring 新的 Java 注解支持中的中央工件是 @Configuration 注解类以及 @Bean 注解方法。
@Bean 注解用于表明方法是实例化，配置和初始化一个由 Spring IoC 容器管理的新对象。对于那些熟悉 Spring &lt;bean/&gt; XML 配置的人，@Bean 注解扮演着与 &lt;bean/&gt; 元素相同的角色。
1.12.2. Instantiating the Spring Container by Using AnnotationConfigApplicationContextAnnotationConfigApplicationContext 在以下各节记录了 Spring 的 AnnotationConfigApplicationContext，在 Spring 3.0 引入。这种万能的 ApplicationContext 实现不仅能接收 @Configuration 类作为输入，而且能够接受 @Component 类以及 JSR-330 元数据注解的类。
当提供 @Configuration 类作为输入时，@Configuration 类本身被注册为 Bean Definition，并且在类中声明的所有 @Bean 方法也都会注册为 Bean Definition。
当 @Component 或者 JSR-330 注解的类作为输入时，它们会注册为 Bean Definition，并且在必要时，这些类中的依赖元数据，例如 @Autowired 或者 @Inject 都会被使用。
Simple Construction与实例化 ClassPathXmlApplicationContext 时使用 Spring XML 文件作为输入的方式相同，当你实例化一个 AnnotationConfigApplicationContext 时，你可以使用 @Configuration 类作为输入。这是考虑到完全无 XML 的 Spring 容器的使用，如下示例所示：
public static void main(String[] args) &#123;    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);    MyService myService = ctx.getBean(MyService.class);    myService.doStuff();&#125;

如前面说的，AnnotationConfigApplicationContext 不仅限于与 @Configuration 类一起使用。任意 @Component 或者 JSR-330 注解类都可以作为输入提供给构造器，如下示例所示：
public static void main(String[] args) &#123;    ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);    MyService myService = ctx.getBean(MyService.class);    myService.doStuff();&#125;
前面的示例假定 MyServiceImpl，Dependency1，以及 Dependency2 使用了 Spring 依赖注入注解，例如 @Autowired。
Building the Container Programmatically by Using register(Class&lt;?&gt;…​)你可以通过使用无参构造器实例化一个 AnnotationConfigApplicationContext，然后使用 register() 对其进行配置。当程序化地构建了一个 AnnotationConfigApplicationContext 这种方式特别有用。以下示例显示了如何做到：
public static void main(String[] args) &#123;    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();    ctx.register(AppConfig.class, OtherConfig.class);    ctx.register(AdditionalConfig.class);    ctx.refresh();    MyService myService = ctx.getBean(MyService.class);    myService.doStuff();&#125;


Enabling Component Scanning with scan(String…​)要启用组件扫描，你可以按以下方式注解 @Configuration 类：
@Configuration@ComponentScan(basePackages = &quot;com.acme&quot;) public class AppConfig  &#123;    ...&#125;

在前面的示例中，扫描 com.acme 包查找 @Component 注解的类，并且这些类以 Spring Bean Definition 的形式注册在容器中。AnnotationConfigApplicationContext 暴露了 scan(String...) 方法，以允许相同组件扫描功能，如下示例所示：
public static void main(String[] args) &#123;    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();    ctx.scan(&quot;com.acme&quot;);    ctx.refresh();    MyService myService = ctx.getBean(MyService.class);&#125;


Support for Web Applications with AnnotationConfigWebApplicationContextAnnotationConfigApplicationContext 的 WebApplicationContext 变体可用 AnnotationConfigWebApplicationContext。你在在配置 Spring ContextLoaderListener Servlet Listener，Spring MVC DispatcherServlet 等时候，使用此实现。下面的 web.xml 摘要配置了一个典型的 Spring MVC Web 应用（请注意 contextClass context-param 和 init-param 的使用）：
&lt;web-app&gt;    &lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext        instead of the default XmlWebApplicationContext --&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextClass&lt;/param-name&gt;        &lt;param-value&gt;            org.springframework.web.context.support.AnnotationConfigWebApplicationContext        &lt;/param-value&gt;    &lt;/context-param&gt;    &lt;!-- Configuration locations must consist of one or more comma- or space-delimited        fully-qualified @Configuration classes. Fully-qualified packages may also be        specified for component-scanning --&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;com.acme.AppConfig&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext            instead of the default XmlWebApplicationContext --&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextClass&lt;/param-name&gt;            &lt;param-value&gt;                org.springframework.web.context.support.AnnotationConfigWebApplicationContext            &lt;/param-value&gt;        &lt;/init-param&gt;        &lt;!-- Again, config locations must consist of one or more comma- or space-delimited            and fully-qualified @Configuration classes --&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;com.acme.web.MvcConfig&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/servlet&gt;    &lt;!-- map all requests for /app/* to the dispatcher servlet --&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;        &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;




1.12.3. Using the @Bean Annotation@Bean 是一种方法级注解，是 &lt;bean/&gt; 元素的等价。注解支持一些 &lt;bean/&gt; 提供的属性，例如：*init-method destroy-method autowiring name.
你可以在 @Configuration 注解类或者 @Component 注解类中使用 @Bean 注解。
Declaring a Bean要声明一个 Bean，你可以用使用 @Bean 注解一个方法。你可以使用此方法在 ApplicationContext 中注册一个 Bean Definition，其类型由方法返回值指定。默认地，Bean 名称与方法名称相同。以下示例展示了 @Bean 方法声明：
@Configurationpublic class AppConfig &#123;    @Bean    public TransferServiceImpl transferService() &#123;        return new TransferServiceImpl();    &#125;&#125;
前面的配置完全等同于以下 Spring XML：
&lt;beans&gt;    &lt;bean id=&quot;transferService&quot; class=&quot;com.acme.TransferServiceImpl&quot;/&gt;&lt;/beans&gt;

这两种声明都使一个名为 transferService 的 bean 在 ApplicationContext 中可获得，绑定到类型为 TransferServiceImpl 的对象实例上，如下文本图形所示：
transferService -&gt; com.acme.TransferServiceImpl

你也可以用接口（或者基类）返回值声明你的 @Bean 方法，如下示例所示：
@Configurationpublic class AppConfig &#123;    @Bean    public TransferService transferService() &#123;        return new TransferServiceImpl();    &#125;&#125;

但是，这将预先类型预测的可见性限制为指定的接口类型（TransferService）。然后，只有一次容器知道完全类型，被影响的单例已经被实例化。非懒惰单例 bean 根据其声明 order 初始化。因此，你可能看到不同类型的匹配结果，具体取决于其他组件试图通过非声明类型（例如 @Autowired TransferServiceImple，只有在实例化了 TransferService bean 之后才能解析）匹配。
Bean Aliasing正如 Naming Beans 讨论的，有时候希望给一个 bean 多个名字，也成为 bean 别名。
如果希望给 bean 赋予多个名称，或者称之为别名，你可以向 @Bean 的 name 属性传递一个字符串数组。为此，@Bean 注解的 name 属性接受一个字符串数组。以下示例显示了如何为一个 bean 设置许多别名：
@Configurationpublic class AppConfig &#123;    @Bean(&#123;&quot;dataSource&quot;, &quot;subsystemA-dataSource&quot;, &quot;subsystemB-dataSource&quot;&#125;)    public DataSource dataSource() &#123;        // instantiate, configure and return DataSource bean...    &#125;&#125;


1.12.4. Using the @Configuration annotation@Configuration 是一个类级别的注解，表明一个对象是 Bean Definition 的来源。@Configuration 类通过 public @Bean 注解方法声明 Bean。@Configuration 类上的 @Bean 方法的调用也可以用于定义 Bean 之间的依赖。
Injecting Inter-bean Dependencies当 Bean 依赖于另一个 Bean 时，表现为依赖让一个 Bean 方法调用另一个一样简单，如下示例所示：
@Configurationpublic class AppConfig &#123;    @Bean    public BeanOne beanOne() &#123;        return new BeanOne(beanTwo());    &#125;    @Bean    public BeanTwo beanTwo() &#123;        return new BeanTwo();    &#125;&#125;

在前面的示例中，beanOne 通过构造器注入接收一个对 beanTwo 的引用。

仅当 @Bean 方法声明在 @Configuration 类中时，这种声明 Bean 间依赖的方法才生效。你无法通过使用普通 @Component 类声明 Bean 间依赖。

Lookup Method Injection如前所述，lookup method injection 是你比较少用的高级功能。在单例 Bean 依赖于原型 Bean 时这很有用。使用 Java 进行此类配置提供了一种天然的方式用于实现这种模式。下面的例子展示了如何查找方法注入：
public abstract class CommandManager &#123;    public Object process(Object commandState) &#123;        // grab a new instance of the appropriate Command interface        Command command = createCommand();        // set the state on the (hopefully brand new) Command instance        command.setState(commandState);        return command.execute();    &#125;    // okay... but where is the implementation of this method?    protected abstract Command createCommand();&#125;

通过使用 Java 配置，你可以创建一个 CommandManager 子类，其中抽象方法 createCommand() 被覆盖以查找一个新的（prototype）Command 对象。下面的示例展示了如何做到：
@Bean@Scope(&quot;prototype&quot;)public AsyncCommand asyncCommand() &#123;    AsyncCommand command = new AsyncCommand();    // inject dependencies here as required    return command;&#125;@Beanpublic CommandManager commandManager() &#123;    // return new anonymous implementation of CommandManager with createCommand()    // overridden to return a new prototype Command object    return new CommandManager() &#123;        protected Command createCommand() &#123;            return asyncCommand();        &#125;    &#125;&#125;

1.12.5. Composing Java-based ConfigurationsSpring 的基于 Java 的配置特色让你可以组合注解，从而降低配置的复杂度。
Using the @Import Annotation就像在 Spring XML 文件中使用 &lt;import/&gt; 元素以帮助模块化配置，@Import 注解也允许你从另一个配置类加载 @Bean 定义，如下示例所示：
@Configurationpublic class ConfigA &#123;    @Bean    public A a() &#123;        return new A();    &#125;&#125;@Configuration@Import(ConfigA.class)public class ConfigB &#123;    @Bean    public B b() &#123;        return new B();    &#125;&#125;

这种功能的引入旨在简化容器实例化，只用准备一个你需要的类，而不是记住所有的 @Configuration

自从 Spring Framework 4.2，@Import 也支持引用普通 Component 类。当你不希望组件扫描时，这是比较有用的，通过少数几个配置类作为入口点，从而定义你需要的组件。

&amp;nbsp;@Import 支持以下几种用法：

导入普通 Bean
导入 ImportSelector 实现类
导入 ImportBeanDefinitionRegistrar 实现类

更多 @Import 用法参见 API
框架案例 MyBatis 的自动扫描 @Mapper 注入，@Import(AutoConfiguredMapperScannerRegistrar.class)
&amp;nbsp;
Conditionally Include @Configuration Classes or @Bean Methods有条件地启用或禁用完整的 @Configuration 类，甚至单个 @Bean 方法。最常用的是使用 @Profile。
@Profile 注解实际上是通过更灵活的称之为 @Conditional 的注解实现。@Conditional 注解表示：特定的 org.springframework.context.annotation.Condition 实现应该在 @Bean 注册之前作为参考。
Condition 的接口实现提供了一个 matches(...) 方法，它返回 true 或者 false。
Combining Java and XML ConfigurationSpring 的 @Configuration 类支持并不是为了完全取代 XML 配置。某些情况下，Spring XML 仍然是一种配置容器的理想方式。在 XML 比较方便或者必须使用的情况下，你可以选择：通过使用例如 ClassPathXmlApplicationContext 以 “XML为中心” 的方式实例化容器；或者以 “Java 为中心” 的方式实例化容器，使用 AnnotationConfigApplicationContext 以及 @ImportResource 注解导入所需的 XML
XML-centric Use of @Configuration Classes也许最好的方式是从 XML 中引导 Spring 容器，并以点对点的方式包含 @Configuration 类。例如，在一个使用 Spring XML 的大型的现有代码库中，很容易在需要的基础上创建 @Configuration 类，并将他们从现存的 XML 文件中包含进去。稍后在本节中，我们会介绍这种 “以 XML 为中心” 情况下使用 @Configuration 类的选项。
Declaring @Configuration classes as plain Spring &lt;bean/&gt; elements
记住，@Configuration 类最终是容器中的 Bean Definition。在本系列示例中，我们创建了一个名为 AppConfig 的 @Configuration，并以一个 &lt;bean/&gt; 定义将其包含进 system-test-config.xml 中。因为 &lt;context:annotaion-config/&gt; 已经开启，容器会识别 @Configuration 注解并正确处理 AppConfig 中声明的 @Bean 方法。
以下示例展示了 Java 中一个普通的配置类：
@Configurationpublic class AppConfig &#123;    @Autowired    private DataSource dataSource;    @Bean    public AccountRepository accountRepository() &#123;        return new JdbcAccountRepository(dataSource);    &#125;    @Bean    public TransferService transferService() &#123;        return new TransferService(accountRepository());    &#125;&#125;

以下示例展示了案例 system-test-config.xml 文件的部分：&#96;
&lt;beans&gt;    &lt;!-- enable processing of annotations such as @Autowired and @Configuration --&gt;    &lt;context:annotation-config/&gt;    &lt;context:property-placeholder location=&quot;classpath:/com/acme/jdbc.properties&quot;/&gt;    &lt;bean class=&quot;com.acme.AppConfig&quot;/&gt;    &lt;bean class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;

以下示例展示了可能的 jdbc.properties 文件：
jdbc.url=jdbc:hsqldb:hsql://localhost/xdbjdbc.username=sajdbc.password=

public static void main(String[] args) &#123;    ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath:/com/acme/system-test-config.xml&quot;);    TransferService transferService = ctx.getBean(TransferService.class);    // ...&#125;

Using &lt;context:component-scan&#x2F;&gt; to pick up @Configuration classes
[@Configuration Class-centric Use of XML with @ImportResource]在一些 @Configuration 类是配置容器的主要机制的应用中，仍然很可能有必要至少使用一些 XML。在这些情况下，你可以使用 @ImportResource，并按你所需定义 XML。这样做可以实现一种 “以 Java 为中心” 的方式配置容器，并将 XML 保持在最低限度。以下示例展示了如何使用 @ImportSource 注解来实现按需使用 XML 的 “以 Java 为中心” 的配置：
@Configuration@ImportResource(&quot;classpath:/com/acme/properties-config.xml&quot;)public class AppConfig &#123;    @Value(&quot;$&#123;jdbc.url&#125;&quot;)    private String url;    @Value(&quot;$&#123;jdbc.username&#125;&quot;)    private String username;    @Value(&quot;$&#123;jdbc.password&#125;&quot;)    private String password;    @Bean    public DataSource dataSource() &#123;        return new DriverManagerDataSource(url, username, password);    &#125;&#125;

properties-config.xml&lt;beans&gt;    &lt;context:property-placeholder location=&quot;classpath:/com/acme/jdbc.properties&quot;/&gt;&lt;/beans&gt;

jdbc.propertiesjdbc.url=jdbc:hsqldb:hsql://localhost/xdbjdbc.username=sajdbc.password=

public static void main(String[] args) &#123;    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);    TransferService transferService = ctx.getBean(TransferService.class);    // ...&#125;

1.13. Environment AbstractionEnvironment 接口是一个集成在容器中的抽象，它模型化了两个关键的应用程序环境方面：profiles 和 properties。
一个 profile 是一个有名的 Bean Definition 逻辑组，仅在给定的 profile 处于激活状态时，Bean Definition 才能注册到容器中。无论是以 XML 方式还是注解方式，bean 都可以分配给一个 profile。Environment 关于 profiles 的作用就是决定哪个 profile 当前是激活的，哪个 profiles 应该默认被激活。
属性在几乎所有应用程序都发挥着重要作用，并且可能来自各种源：属性文件，JVM 系统属性，系统环境变量，JNDI，Servlet 上下文参数，ad-hoc Properties 对象，Map 对象等。Environment 对象对于属性的作用就是提供用户一个方便的服务接口，用于配置属性源以及从中解析属性。
1.13.1. Bean Definition ProfilesBean Definition profile 在核心容器中提供了一种机制，可以在不同环境中注册不同的 bean。”environment” 一词对于不同用户来说可能意味着不同的事物，该功能有助于许多用例，例如：
考虑在实际需要 DataSource 的应用的第一个用例。在测试环境中，配置可能类似于下面：
@Beanpublic DataSource dataSource() &#123;    return new EmbeddedDatabaseBuilder()        .setType(EmbeddedDatabaseType.HSQL)        .addScript(&quot;my-schema.sql&quot;)        .addScript(&quot;my-test-data.sql&quot;)        .build();&#125;

Using @Profile@Profile 注解允许你指示当一个或多个指定 profile 激活时，一个组件才有资格注册。
@Profile 也可以在方法级别声明，这样仅包括了配置类的一个特定 bean。
XML Bean Definition ProfilesXML 对应的是 &lt;bean/&gt; 元素的 profile 属性。我们前面的示例配置可以以两个 XML 文件的方式重写，如下：
&lt;beans profile=&quot;development&quot;    xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;    xsi:schemaLocation=&quot;...&quot;&gt;    &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt;        &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/schema.sql&quot;/&gt;        &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/test-data.sql&quot;/&gt;    &lt;/jdbc:embedded-database&gt;&lt;/beans&gt;

&lt;beans profile=&quot;production&quot;    xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;    xsi:schemaLocation=&quot;...&quot;&gt;    &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:comp/env/jdbc/datasource&quot;/&gt;&lt;/beans&gt;
也可以避免拆分，并在同一个文件中嵌套 &lt;beans/&gt; 元素，如下示例所示：
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;    xsi:schemaLocation=&quot;...&quot;&gt;    &lt;!-- other bean definitions --&gt;    &lt;!-- 嵌套 --&gt;    &lt;beans profile=&quot;development&quot;&gt;        &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt;            &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/schema.sql&quot;/&gt;            &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/test-data.sql&quot;/&gt;        &lt;/jdbc:embedded-database&gt;    &lt;/beans&gt;    &lt;beans profile=&quot;production&quot;&gt;        &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:comp/env/jdbc/datasource&quot;/&gt;    &lt;/beans&gt;&lt;/beans&gt;

Activating a Profile可以以多种方式激活 profile：

Environment API 方式
spring.profiles.active

最简单的是使用 ApplicationContext 的 Environment API 以编程方式激活：
ctx.getEnvironment().setActiveProfiles(&quot;development&quot;);ctx.getEnvironment().setActiveProfiles(&quot;profile1&quot;, &quot;profile2&quot;);

还可以通过 spring.profiles.active 属性激活配置文件，可以通过系统环境变量，JVM 系统属性，web.xml 中的 servlet 上下文参数，甚至是在 JNDI 中的条目指定。spring.profiles.active 可以接受以逗号（,）分割的 profile 名称列表。
-Dspring.profiles.active=&quot;profile1,profile2&quot;

Default Profile默认的 profile 表示默认启用的 profile。考虑如下示例：
@Configuration@Profile(&quot;default&quot;)public class DefaultDataConfig &#123;    @Bean    public DataSource dataSource() &#123;        return new EmbeddedDatabaseBuilder()            .setType(EmbeddedDatabaseType.HSQL)            .addScript(&quot;classpath:com/bank/config/sql/schema.sql&quot;)            .build();    &#125;&#125;

如果没有激活任何 profile，dataSource 会被创建。你可以将其视为为一个或多个 Bean 提供默认定义的一种方式。如果启用了任意 profile，默认的 profile 不再使用。
你可以通过在 Environment 上使用 setDefaultPrfiles() 或者声明式地使用 spring.profiles.default 来修改默认 profile 的名称。
1.13.2. PropertySource AbstractionSpring 的 Environment 抽象在属性源的可配置层次结构上提供了搜索操作。考虑下面的代码清单：
ApplicationContext ctx = new GenericApplicationContext();Environment env = ctx.getEnvironment();boolean containsMyProperty = env.containsProperty(&quot;my-property&quot;);System.out.println(&quot;Does my environment contain the &#x27;my-property&#x27; property? &quot; + containsMyProperty);

在前面的片段中，我们看到了一种高级方法，其询问 Spring 是否为当前环境定义了 my-property 属性。为了回答这个问题，Environment 对象会对一组 PropertySource 对象执行搜索。PropertySource 是任何键值对源的简单抽象，并且 Spring 的 StandardEnvironment 配置了两个 PropertySource 对象 —— 一个代表 JVM 系统属性集（System.getProperties()），一个代表系统环境变量集（System.getenv()）。

这些默认的属性源存在于 StandardEnvironment，用于独立应用。StandardServletEnvironment 填充了其他默认的属性源，包括 Servlet Config 以及 Servlet Context 参数。它可以选择性的启用 JndiPropertySource。详细信息参见 javadoc。

具体而言，当你使用 StandardEnvironment 时，如果在运行时具有 my-property 系统属性或者 my-property 环境变量，调用 env.containsProperty(&quot;my-property&quot;) 就会返回 true。

执行搜索是分层次的。默认地，系统属性优先于环境变量。因此，如果在调用 env.getProperty(&quot;my-property&quot;) 期间 my-property 属性在两个地方都发生了赋值，系统属性值会”胜利”并返回。请注意，属性值并不会合并，而是完全被前面的条目覆盖。对于通用的 StandardServletEnvironment，完整的层次结构如下，优先级最高的在最顶端：

ServletConfig 参数（如果适用，例如，在 DispatcherServlet 上下文的情况下）
ServletContext 参数（web.xml 上下文参数条目）
JNDI 环境变量（java:comp/env/ 条目）
JVM 系统属性（-D 命令行参数）
JVM 系统环境（操作系统环境变量）


最重要的是，整个机制都是可配置的。也许你有一个自定义的属性源，要将其继承到此搜索中。为此，实现并实例化你自己的 PropertySource 并将其添加到当前 Environment 的 PropertySources 集合中。下面示例展示了怎么做：
ConfigurableApplicationContext ctx = new GenericApplicationContext();MutablePropertySources sources = ctx.getEnvironment().getPropertySources();sources.addFirst(new MyPropertySource());

在前面的代码中，在搜索中以高优先级添加了 MyPropertySource。如果它包含 my-property 属性，属性会被检测并返回，支持其他任何 PropertySource 中的任何 my-property 属性。MutablePropertySources API 暴露了许多方法，这些方法允许精确地操纵属性源集合。
1.13.3. Using @PropertySource@PropertySource 注解提供了一种便捷的声明式机制，用于将 PropertySource 添加到 Spring 的 Environment 中。
给定一个名为 app.properties 的文件，包含键值对 testbean.name=myTestBean，下面的 @Configuration 类使用 @PropertySource，以这种方式调用 testBean.getName() 返回 myTestBean：
@Configuration@PropertySource(&quot;classpath:/com/myco/app.properties&quot;)public class AppConfig &#123;    @Autowired    Environment env;    @Bean    public TestBean testBean() &#123;        TestBean testBean = new TestBean();        testBean.setName(env.getProperty(&quot;testbean.name&quot;));        return testBean;    &#125;&#125;

出现在 @PropertySource 中的任何 $&#123;...&#125; 占位符都会用已经注册到 Environment 中的属性源集合进行解析，如下示例所示：
@Configuration@PropertySource(&quot;classpath:/com/$&#123;my.placeholder:default/path&#125;/app.properties&quot;)public class AppConfig &#123;    @Autowired    Environment env;    @Bean    public TestBean testBean() &#123;        TestBean testBean = new TestBean();        testBean.setName(env.getProperty(&quot;testbean.name&quot;));        return testBean;    &#125;&#125;

假定 my.placeholder 存在于已经注册的属性源之一（例如，系统属性或者环境变量）中，占位符会被解析为相关值。如果不存在，那么 default/path 会被作为默认值。如果未指定默认值，且属性无法解析，将会抛出 IllegalArgumentException。
1.13.4. Placeholder Resolution in Statements过去，只针对 JVM 系统属性或者环境变量，元素上的占位符可以被解析。现在已不再这样。因为 Environment 抽象是集成在容器中的，因此很容易通过它来路由占位符的解析。这意味着你可以以任何你喜欢的方式配置解析流程。你可以通过系统属性或者环境变量更改搜索优先级，或者完全移除它们。你还可以适当地添加自己的属性资源。
具体而言，无论 customer 属性定义在哪儿，只要在 Environment 中可获得，下面的语句就可以工作：
&lt;beans&gt;    &lt;import resource=&quot;com/bank/service/$&#123;customer&#125;-config.xml&quot;/&gt;&lt;/beans&gt;

1.14. Registering a LoadTimeWeaverSpring 使用 LoadTimeWeaver 当类加载到 Java 虚拟机时，动态转换这些类。
要启动加载时编织，你可以将 @EnableLoadTimeWeaving 添加到你的 @Configuration 类，如以下示例所示：
@Configuration@EnableLoadTimeWeavingpublic class AppConfig &#123;&#125;
另外，对于 XML 配置，你可以使用 context:load-time-weaver 元素：
&lt;beans&gt;    &lt;context:load-time-weaver/&gt;&lt;/beans&gt;
一旦配置为 ApplicationContext，任何在该 ApplicationContext 中的 bean 都可以实现 LoadTimeWeaverAware，从而接收到加载时 weaver 示例的引用。
1.15. Additional Capabilities of the ApplicationContext1.15.1. Internationalization using MessageSource1.15.2. Standard and Custom EventsApplicationContext 中的事件处理功能通过 ApplicationEvent 类以及 ApplicationListener 接口提供。如果一个实现了 ApplicationListener 接口的 bean 部署到上下文中，那么每次 ApplicationEvent 发布到 ApplicationContext 时，该 bean 会被通知。本质上，这是一种标准的观察者模式。
Spring 提供的标准事件：

ContextRefreshedEvent
ContextStartedEvent
ContextStoppedEvent
ContextClosedEvent
RequestHandledEvent
ServletRequestHandledEvent

Annotation-based Event Listeners在一个 bean 的方法上通过使用 @EventListener 注解注册一个事件监听器。
方法签名声明事件监听的类型。事件的类型可以通过泛型参数缩小范围，只要实际事件类型在其实现架构中解析你的泛型参数。
如果方法应该监听多个事件，或者你不想定义参数，那么可以在注解上指定事件类型。
可以通过 condition 属性定义一个 SpEL 表达式来添加更多的运行时过滤效果。
Asynchronous Listeners如果你希望异步地处理某个事件，那你可以使用常规的 @Async 注解。
Ordering Listeners如果你需要在另一个监听器之前调用某个监听器，则你可以添加 @Order 注解至方法声明，如下示例所示：
@EventListener@Order(42)public void processBlockedListEvent(BlockedListEvent event) &#123;    // notify appropriate parties via notificationAddress...&#125;


Generic Events你可以使用泛型来进一步定义事件的架构。例如，使用 EntityCreatedEvent&lt;T&gt;，其中 T 表示创建的实际实体类型。
1.16. The BeanFactoryBeanFactory API 为 Spring IoC 功能提供了基础。它的特定约定主要用于与 Spring 的其他部分以及第三方框架集成，并且它的 DefaultListableBeanFactory 实现是更高级别的 GenericApplicationContext 容器的委托。
BeanFactory 和相关接口（如 BeanFactoryAware, InitializingBean, DisposableBean）是其他框架的重要集成点。不需要任何注解或者反射，它们可以非常高效地在容器和组件之间通信。应用程序级别的 bean 可以使用相同的回调接口，但是通常会通过注解或者程序配置的方式进行声明式的依赖注入。
请注意，核心 BeanFactory API 级别和它的 DefaultLisableBeanFactory 实现都没有对配置格式或者任何待使用的组件注解做出规定。所有的风格都通过扩展（如：XmlBeanDefinitionReader 和 AutowiredAnnotationBeanPostProcessor）进行，并在共享的作为核心元数据表现形式的 BeanDefinition 对象上操作。这就是使 Spring 容器如此灵活且可扩展的本质。
1.16.1. BeanFactory or ApplicationContext?在 ApplicationContext 中（如 GenericApplicationContext 实现），可以根据 bean name 或者 bean type（特别是后置处理器） 找到 bean，然而，普通的 DefaultListableBeanFactory 与任何特殊 bean 无关。

自从 SpringFramework 4.3，如果目标 bean 只定义了一个构造器，那么不再需要指定 @Autowired 注解，见4.3更新日志

2. Resources2.1. Introduction不幸地是，Java 标准的 java.net.URL 类和用于各种各样 URL 前缀的标准处理器不足以访问所有的低级资源。例如，没有标准化的 URL 实现可以用于访问需要从类路径或者相对于 ServletContext 的资源。虽然可以为特定的 	URL 前缀注册新的处理器（类似于目前用于注入 http: 前缀的处理器），但这通常非常复杂，并且 URL 接口仍然缺乏一些理想的功能，例如检查被指向的资源存在性。
2.2. The Resource InterfaceSpring 的 Resource 接口旨在成为一个用于抽象访问低级资源的更强大的接口。以下列举了 Resource 接口的定义：
public interface Resource extends InputStreamSource &#123;    boolean exists();    boolean isOpen();    URL getURL() throws IOException;    File getFile() throws IOException;    Resource createRelative(String relativePath) throws IOException;    String getFilename();    String getDescription();&#125;

如 Resource 接口所示的定义，它扩展了 InputStreamSource 接口。以下列出了 InputStreamSource 接口的定义：
public interface InputStreamSource &#123;    InputStream getInputStream() throws IOException;&#125;

Resource 接口中一些最重要的方法是：

getInputStream(): 定位并打开资源，返回一个输入流以从资源中读取。预计每次调用都会返回新的输入流。调用者的职责就是关闭流。
exists(): 返回一个 boolean 指示该资源是否真正以物理形式存在。
isOpen(): 返回一个 boolean 标识该资源是否标识一个打开流的句柄。如果是 true，则不能多次读取 InputStream，并且必须仅读取一次，然后关闭避免资源泄露。除了 InputStreamResource，所有常规资源实现都会返回 false。
getDescription(): 返回此资源的描述，用于使用资源时的错误输出。这通常是完全限定文件名或者资源的实际 URL。

其他方法可以让你获得代表资源的实际 URL 或者 File 对象（如果基础实现兼容且支持该功能）。
2.3. Built-in Resource Implementations2.3.1. UrlResourceUrlResource 包装了 java.net.URL。可以用于访问通常用 URL 访问的任何对象，例如文件、HTTP 目标、FTP 目标等。所有 URL 都有标准化的字符串表现形式，因此使用适当的标准化前缀来指示一种 URL 类型。这包括 file: 用于访问文件系统路径, http: 用于访问通过 HTTP 协议的资源, ftp: 用于访问通过 FTP 的资源等。
UrlResource 由 Java 代码通过显式地使用 UrlResource 构造器创建，但是当你调用持有一个 String 参数标识路径的 API 方法时，通常会隐式地创建。对于后一种情况，Java Bean PropertyEditor 最终决定要创建哪种类型的资源。
2.3.2. ClassPathResource2.3.3. FileSystemResource这是用于 java.io.File 和 java.nio.file.Path 处理的 Resource 实现。它支持以 File 和 URL 方式解析。
2.3.5. InputStreamResource2.4. The ResourceLoaderResourceLoader 接口意味着由那些可以返回 Resource 实例的对象实现。下面的清单展示了 ResourceLoader 接口的定义：
public interface ResourceLoader &#123;    Resource getResource(String location);&#125;

所有 Application Context 都实现了 ResourceLoader 接口。因此，所有 Application Context 可以被用于获取 Resource 实例。
当你在特定应用上下文调用 getResource()，并且指定的位置路径没有特定前缀时，你将会获得适合特定 Application Context 的 Resource 类型。例如，假设以下代码段是针对 ClassPathXmlApplicationContext 实例运行的：
Resource template = ctx.getResource(&quot;some/resource/path/myTemplate.txt&quot;);

对于 ClassPathXmlApplicationContext，该代码返回 ClassPathResource。如果相同的方法运行在 FileSystemXmlApplicationContext 实例上，将会返回 FileSystemResource。对于 WebApplicationContext，将会返回 ServletContextResource。类似地，将会返回适合于每个上下文的对象。
结果，你可以以适合于特定 Application Context 的方式加载资源。
下表总结了讲 String 对象转换为 Resource 对象的策略。



Prefix
Example
Explanation



classpath:
classpath:com/myapp/config.xml
从类路径加载


file:
file:///data/config.xml
从文件系统以 URL 加载


http:
https://myserver/logo.png
以 URL 加载


(none)
/data/config.xml
依赖于底层 ApplicationContext


2.5. The ResourceLoaderAware interfaceResourceLoaderAware 接口是一个特殊的回调接口，它标识了那些期望提供以 ResourceLoader 接口的组件。下面的清单展示了 ResourceLoaderAware 接口的定义：
public interface ResourceLoaderAware &#123;    void setResourceLoader(ResourceLoader resourceLoader);&#125;


2.7. Application Contexts and Resource Paths本节涵盖了如何使用资源创建应用上下文，包括与 XML 工作的快捷方式，如何使用通配符，以及其他细节。
2.7.1. Constructing Application ContextsApplicationContext 的构造器通常将一个字符串或者字符串数组作为资源路径，例如构成上下文定义的 XML 文件。
当这样的路径没有前缀时，将会从该路径构建特定的 Resource 类型，并用于加载依赖及适配于特定 Application Context 的 Bean Definition。例如，考虑以下示例，该示例创建 ClassPathXmlApplicationContext：
ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;conf/appContext.xml&quot;);
bean 定义将会从类路径加载，因为使用了 ClassPathResource。
ApplicationContext ctx = new FileSystemXmlApplicationContext(&quot;conf/appContext.xml&quot;);

如果在路径上使用特殊的 classpath 前缀，或者标准的 URL 前缀，将会覆盖默认的 Resource 类型。
ApplicationContext ctx =    new FileSystemXmlApplicationContext(&quot;classpath:conf/appContext.xml&quot;);

Constructing ClassPathXmlApplicationContext Instances — ShortcutsClassPathXmlApplicationContext 暴露出许多构造器，以便于实例化应用上下文。基本思想是：你可以只提供一个字符串数组，该数组包含 XML 文件名（无前导路径信息），并提供一个 Class。然后，ClassPathXmlApplicationContext 就能从提供的 Class 中推断出路径信息。
public ClassPathXmlApplicationContext(String path, Class&lt;?&gt; clazz) throws BeansException &#123;	this(new String[] &#123;path&#125;, clazz);&#125;


上述描述也就是根据当前类进行相对路径查找。

3. Validation, Data Binding, and Type ConversionSpring Boot 2.3 不再包含 validation，见 github
将校验视为业务逻辑有利也有弊，Spring 提供了一种用于校验（以及数据绑定）的设计，这并不会排除其中任何一个。具体而言，验证不应该与 Web 层绑定，并且应该容易本地化，且应该有可能插入任何可用的验证器。考虑到这些问题，Spring 提供了一个 Validator 约定，它在每个应用层都是即基础又高度可用。
数据绑定对于让用户的输入动态绑定到应用程序的域模型（或者是任何拟用于处理用户输入的对象）非常有用。Spring 提供了恰当的名为 DataBinder 来做到这一点。Validator 和 DataBinder 组成了 validation 包，该包主要用于但不局限于 web 层。
BeanWrapper 是 Spring 框架中的一个基本概念，在许多地方都有使用。但是，你可能无需直接使用 BeanWrapper。但是，由于这是一个参考文档，所以我们认为需要进行一些解释。我们在本章解释 BeanWrapper，因为如果你要使用它，你很可能在尝试将数据绑定到对象上时这样做。
Spring 的 DataBinder 和低级 BeanWrapper 都使用 PropertyEditorSupport 实现类去解析和格式化属性值。PropertyEditor 和 PropertyEditorSupport 类型是 Java Bean 规范的一部分，也会在本章解释。
*** JavaBean 的校验Java Bean 增加 @Valid 注解，或者 @Validated 注解。 @Validated 支持分组
public HttpBody login(@RequestBody @Valid LoginVO loginVO) &#123;&#125;
*** 普通参数校验增加 @Valid 注解以及校验规则，同时 Controller 增加 @Validated 注解
@RestController@Validatedpublic class UserController &#123;	public HttpBody sendVerificationCode(@Valid @Email(message = &quot;邮箱格式错误&quot;) @PathVariable String to) &#123; &#125;&#125;
3.1. Validation by Using Spring’s Validator InterfaceSpring 提供了一个 Validator 接口，你可以用它来校验对象。Validator 接口通过使用 Errors 对象工作，以便在验证时，验证器可以将校验的失败报告给 Errors 对象。
考虑如下的一个小型数据对象示例：
public class Person &#123;    private String name;    private int age;    // the usual getters and setters...&#125;

接下来的示例通过实现 org.springframework.validation.Validator 接口的两个方法来为 Person 类提供验证行为：

supports(Class): 该 Validator 可以验证 Class 的实例吗？
validate(Object, org.springframework.validation.Errors): 验证给定的对象，如果发生验证错误，使用给定的 Errors 对象进行注册。

实现 Validator 非常简单，尤其当你了解 Spring Framework 提供的 ValidationUtils 帮助类。以下示例为 Persion 示例实现了 Validator：
public class PersonValidator implements Validator &#123;    /**     * This Validator validates only Person instances     */    public boolean supports(Class clazz) &#123;        return Person.class.equals(clazz);    &#125;    public void validate(Object obj, Errors e) &#123;        ValidationUtils.rejectIfEmpty(e, &quot;name&quot;, &quot;name.empty&quot;);        Person p = (Person) obj;        if (p.getAge() &lt; 0) &#123;            e.rejectValue(&quot;age&quot;, &quot;negativevalue&quot;);        &#125; else if (p.getAge() &gt; 110) &#123;            e.rejectValue(&quot;age&quot;, &quot;too.darn.old&quot;);        &#125;    &#125;&#125;

ValidationUtils 类上的静态方法 rejectIfEmpty(..) 用于当 name 属性为 null 或者空字符串时进行拒绝。
虽然可以实现单个 Validator 类来验证复合对象中的每个嵌套对象，但最好将每个嵌套对象类的验证逻辑封装在其自己的 Validator 实现中。一个复合对象的简单例子是 Customer，其由两个 String 属性（first 和 second name）以及一个复杂对象 Address 组成。Address 对象可以独立于 Customer 对象使用，因此实现了一个独立的 AddressValidator。如果你希望你的 CustomerValidator 重用 AddressValidator 类中包含的逻辑，无需求助于复制粘贴，你可以在 CustomerValidator 中依赖注入或者实例化一个 AddressValidator，如下示例所示：
public class CustomerValidator implements Validator &#123;    private final Validator addressValidator;    public CustomerValidator(Validator addressValidator) &#123;        if (addressValidator == null) &#123;            throw new IllegalArgumentException(&quot;The supplied [Validator] is &quot; +                &quot;required and must not be null.&quot;);        &#125;        if (!addressValidator.supports(Address.class)) &#123;            throw new IllegalArgumentException(&quot;The supplied [Validator] must &quot; +                &quot;support the validation of [Address] instances.&quot;);        &#125;        this.addressValidator = addressValidator;    &#125;    /**     * This Validator validates Customer instances, and any subclasses of Customer too     */    public boolean supports(Class clazz) &#123;        return Customer.class.isAssignableFrom(clazz);    &#125;    public void validate(Object target, Errors errors) &#123;        ValidationUtils.rejectIfEmptyOrWhitespace(errors, &quot;firstName&quot;, &quot;field.required&quot;);        ValidationUtils.rejectIfEmptyOrWhitespace(errors, &quot;surname&quot;, &quot;field.required&quot;);        Customer customer = (Customer) target;        try &#123;            errors.pushNestedPath(&quot;address&quot;);            ValidationUtils.invokeValidator(this.addressValidator, customer.getAddress(), errors);        &#125; finally &#123;            errors.popNestedPath();        &#125;    &#125;&#125;


3.2. Resolving Codes to Error Messages我们讨论了数据绑定和验证。本节涵盖了于验证错误相关的输出消息。在上一章节的示例中，我们拒绝 name 和 age 字段。如果我们想使用 MessageSource 输出错误消息，则我们可以使用拒绝字段时提供的错误码来完成。当你调用 rejectValue 或者来自 Errors 接口的其他  reject 方法之一时，底层实现不仅仅会注册你传递的错误码，而且会注册许多额外的错误码。MessageCodesResolver 决定了 Errors 接口注册哪些错误码。默认地，使用 DefaultMessageCodesResolver，它不仅仅注册你赋予的错误码的消息，而且还会注册包含你传递给拒绝方法的字段名的消息。因此，如果你通过使用 rejectValue(&quot;age&quot;, &quot;too.darn.old&quot;)
3.3. Bean Manipulation and the BeanWrapperorg.springframework.beans 包遵循 Java Bean 标准。一个 Java Bean 是一个具有默认无参构造器，并且遵循命名约定的类，其中（举个例子）一个属性名为 bingoMadness 有一个 Setter 方法 setBingoMadness(..) 以及一个 Getter 方法 getBingoMadness()。有关 Java Bean 和规范的更多信息，参见 javabeans
在 bean 包中非常重要的类是 BeanWrapper 接口及其相应的实现（BeanWrapperImpl）。正如 Javadoc 引用的那样，BeanWrapper 提供了 set 和 get 属性值（单个或者批量）的功能，获取属性描述符和查询属性，以确定它们是可读还是可写的。此外，BeanWrapper 提供了对嵌套属性的支持，使子属性的属性设置为无限的深度。BeanWrapper 还提供了添加标准 Java Bean PropertyChangeListeners 以及 VetoableChangeListeners 的能力，无需在目标类中的代码支持。最后的但同样重要的是，BeanWrapper 提供了设置索引属性的支持。BeanWrapper 通常不直接使用应用程序代码，而是由 DataBinder 以及 BeanFactory 使用。
BeanWrapper 的工作方式见名知意：它包装 Bean 在该 Bean 上执行操作，例如设置和检索属性。
3.3.1. Setting and Getting Basic and Nested PropertiesSet 和 Get 属性是通过 BeanWrapper 的重载方法变体 setPropertyValue 和 getPropertyValue 完成的。详细信息参见它们的 Javadoc。下表展示了这些约定的一些例子：



Expression
Explanation



name
表示关联着 getName() 或者 isName() 以及 setName(..) 方法的属性 name


account.name



account[2]



account[COMPANYNAME]



以下两个示例类使用 BeanWrapper 去 Get 和 Set 属性：
public class Company &#123;    private String name;    private Employee managingDirector;    public String getName() &#123;        return this.name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Employee getManagingDirector() &#123;        return this.managingDirector;    &#125;    public void setManagingDirector(Employee managingDirector) &#123;        this.managingDirector = managingDirector;    &#125;&#125;

public class Employee &#123;    private String name;    private float salary;    public String getName() &#123;        return this.name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public float getSalary() &#123;        return salary;    &#125;    public void setSalary(float salary) &#123;        this.salary = salary;    &#125;&#125;

下面的代码片段展示了一些，关于如何检索和操纵实例化的 Companies 和 Employees 某些属性：
BeanWrapper company = new BeanWrapperImpl(new Company());// setting the company name..company.setPropertyValue(&quot;name&quot;, &quot;Some Company Inc.&quot;);// ... can also be done like this:PropertyValue value = new PropertyValue(&quot;name&quot;, &quot;Some Company Inc.&quot;);company.setPropertyValue(value);// ok, let&#x27;s create the director and tie it to the company:BeanWrapper jim = new BeanWrapperImpl(new Employee());jim.setPropertyValue(&quot;name&quot;, &quot;Jim Stravinsky&quot;);company.setPropertyValue(&quot;managingDirector&quot;, jim.getWrappedInstance());// retrieving the salary of the managingDirector through the companyFloat salary = (Float) company.getPropertyValue(&quot;managingDirector.salary&quot;);

3.4. Spring Type Conversion3.7. Java Bean ValidationSpring Framework 为 Java Bean Validation API 提供了支持。
3.7.1. Overview of Bean ValidationBean Validation 通过约束声明和 Java 应用的元数据提供了一种通用的验证方式。要使用它，你可以用声明式验证约束注解域模型，之后这些约束在运行时会被强制执行。有内置的约束，你也可以定义你自己的自定义约束。
考虑以下示例，该实例展示了一个具有两个属性的简单 PersonForm 模型：
public class PersonForm &#123;    private String name;    private int age;&#125;

Bean Validation 让你可以声明约束，如下示例所示：
public class PersonForm &#123;    @NotNull    @Size(max=64)    private String name;    @Min(0)    private int age;&#125;

然后，Bean Validation validator 基于声明的约束验证该类实例。
3.7.2. Configuring a Bean Validation ProviderSpring 为 Bean Validation API 提供了完全的支持，包括 Bean Validation provider 作为一个 Spring bean 的引导。这让你可以在你的应用任何需要验证的地方注入 javax.validation.ValidatorFactory 或者 javax.validation.Validator。
你可以使用 LocalValidatorFactoryBean 配置一个默认 Validator 作为 Spring Bean，如下示例所示：
import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;@Configurationpublic class AppConfig &#123;    @Bean    public LocalValidatorFactoryBean validator() &#123;        return new LocalValidatorFactoryBean();    &#125;&#125;

Injecting a ValidatorLocalValidatorFactoryBean 实现了 javax.validation.ValidatorFactory 和 javax.validation.Validator 以及 Spring 的 org.springframework.validation.Validator。你可以注入这些接口中的任何一个到你需要调用校验逻辑的 Bean 中。
如果你更喜欢直接使用 Bean Validation API，你可以注入 javax.validation.Validator 的引用，如下示例所示：
import javax.validation.Validator;@Servicepublic class MyService &#123;    @Autowired    private Validator validator;&#125;

Configuring Custom Constraints每个 Bean 验证约束由两部分组成：

@Constraint 注解，声明了约束及其可配置的属性
javax.validation.ConstraintValidator 接口的实现类，实现了约束的行为

Spring-driven Method ValidationAdditional Configuration Options3.7.3. Configuring a DataBinder4. Spring Expression Language (SpEL)Spring 表达式语言（简称 SpEL）是一种功能强大的表达式语言，支持在运行时查询和操作对象图。该语言的语法类似于 Unified EL，但提供了额外的特性、最显著的方法调用和基本字符串模板功能。
虽然还有其他几种可用的 Java 表达式语言—— OGNL，MVEL，以及 JBoss EL，但仅举几个例子，创建 Spring 表达式语言是为了向 Spring 社区提供一种受良好支持的表达式语言，该语言可以在 Spring 产品组合中的所有产品中使用。它的语言特性是由 Spring 投资组合中的项目需求驱动的，包括在 Spring Tools For Eclipse 中队代码完成支持的工具需求。也就是说，SpEL 基于一种与技术无关的 API，它允许在需要时集成其他表达式语言实现。
4.1. Evaluation本节介绍了 SpEL 接口及其表达式语言的简单使用。完整的语言参考可以在 Language Reference.
以下代码介绍了 SpEL API，以解析字符串表达式 Hello World.
ExpressionParser parser = new SpelExpressionParser();Expression exp = parser.parseExpression(&quot;&#x27;Hello World&#x27;&quot;); String message = (String) exp.getValue();

你最有可能使用的 SpEL 类和接口位于 org.springframework.expression 包及其子包中，例如 spell.support。
ExpressionParser 接口负责解析表达式字符串。在前面的例子中，表达式字符串是由周围的单引号表示的字符串字面量。Expression 接口负责计算前面定义的表达式字符串。调用 parser.parseExpression 和 exp.getValue 时，可能抛出两个异常，分别是ParseException 和 EvaluationException。
SpEL 支持广泛的特性
5. Aspect Oriented Programming with Spring面向切面编程（AOP）提供了另一种关于编程结构的思考方式，以对面向对象编程（OOP）进行补充。OOP 中关键的模块化单元是类，而 AOP 中，模块化单元是切面。切面使横跨多个类和对象切入的关注点（例如事务管理）模块化成为可能。（此类关注点通常在 AOP 的文献中称为“横切”关注点。）
Spring 的关键组件之一就是 AOP 框架。尽管 Spring IoC 容器不依赖于 AOP（意味着，如果你不想用，你就不必使用 AOP），但是 AOP 补充了 Spring IoC，提供了一个功能强大的中间件解决方案。

Spring AOP 和 AspectJ pointcuts
Spring 要不通过使用基于 schema 的方式，要不通过 `@AspectJ` 注解风格提供了简易且强大的写入自定义切点的方式。这两种方式都提供了完全的类型 Advice 并且 AspectJ 切点语言的使用同时也是用 Spring AOP 进行编织。
本章讨论了基于 schema 以及基于 @AspectJ 的 AOP 支持。下一章将讨论低级的 AOP 支持。

AOP 在 Spring Framework 中能做什么：

提供声明式企业服务。最重要的此类服务是声明式事务管理
让用户实现自定义切面，用 AOP 补充他们的 OOP

5.1. AOP Concepts让我们通过定义一些核心 AOP 概念和术语开始。这些术语不是 Spring 特有的。不幸地是，AOP 术语不是特别直观。但是，如果 Spring 使用自己的术语，那将更加令人困惑。

Aspect：切面，一个横跨多个类的模块化。事务管理是企业 Java 应用程序中横切问题很好的例子。在 Spring AOP 中，切面是通过使用常规类或者基于 @Aspect 注解的常规类。
Join point：连接点，执行程序期间的一个点，可以是一个方法的执行或者一个异常的处理。在 Spring AOP 中，连接点就是代表一个方法的执行。
Advice：通知，一个切面在特定连接点采取的行动。不同类似的通知包括 around，before，after。许多 AOP 框架，包括 Spring，将 advice 模型为一个拦截器，并在连接点周围维护一系列拦截器。
Pointcut：切入点，匹配连接点的谓词。advice 与 pointcut 表达式关联，并且在切点匹配的任何 join point 执行。由 pointcut 表达式匹配的 join point 的概念是 AOP 的重点。默认，Spring 使用 AspectJ pointcut 表达式语言。
Introduction（引入）：代表一个类声明额外的方法或字段。Spring AOP 让你可以将新的接口（以及相关实现）引入任何通知对象。例如，你可以使用一个 introduction 使 Bean 实现一个 IsModified 接口，以简化缓存。（一个 introduction 在 AspectJ 社区中称为类内声明）
Target object：由一个或多个切面通知的对象。
AOP proxy：由 AOP 框架创建的对象，以实现切面约定（通知方法执行等）。在 Spring 框架中，AOP 代理可以是 JDK 动态代理或者是 CGLIB 代理。
Weaving：将切面与其他应用类或对象链接，以创建一个通知对象。这可以在编译时（例如。使用 AspectJ 编译器），加载时，或者运行时完成。像其他纯 Java AOP 框架一样，Spring AOP 在运行时进行编织。

Spring AOP 包括下面通知类型：

Before advice
After returning advice
After throwing advice
After (finally) advice
Around advice

5.3. AOP ProxiesSpring AOP 默认使用标准 JDK 动态代理作为 AOP 代理。这使得可以代理任何接口（或者一组接口）。
Spring AOP 也可以使用 CGLIB 代理，这对于代理一些类而非接口是很有必要的。默认地，如果业务对象没有实现接口，则使用 CGLIB。由于最好的实践是面向接口编程而非面向类编程，业务类通常实现一个或多个业务接口。当你需要通知一个未声明在任何接口的方法时，或者需要将代理对象作为固定类型传递给一个方法时，可以强制使用 CGLIB。
5.4. @AspectJ support5.4.1. Enabling @AspectJ Support要在 Spring 配置中使用 @AspectJ 切面，你需要启用 Spring 支持，以基于 @AspectJ 切面配置 Spring AOP，并根据 Bean 是否被这些切面增强而自动代理。通过自动代理，我们的意思是，如果 Spring 确定某个 Bean 被一个或多个切面增强，它会自动为该 Bean 生成一个代理来拦截方法调用，并确保增强按需运行。 
可以通过 XML 或者 Java 风格配置启用 @AspectJ 支持。在这两种情况下，你还需要确保 AspectJ 的 aspectjweaver.jar 库在应用程序（版本 1.8 及以上）的类路径下。这个库可以在 AspectJ 发行版的 lib 目录或者 Maven 中央仓库找到。
Enabling @AspectJ Support with Java Configuration要使用 Java @Configuration 启用 @Aspect 支持，添加 @EnabloeAspectJAutoProxy 注解，如下面的示例所示: 
@Configuration@EnableAspectJAutoProxypublic class AppConfig &#123;&#125;


Enabling @AspectJ Support with XML Configuration要通过基于 XML 的配置启用 @Aspect 支持，使用 aop:aspectj-autoproxy 元素，如下面的示例所示: 
&lt;aop:aspectj-autoproxy/&gt;
这假设你使用模式支持，正如 XML 基于模式配置中描述的那样。有关如何导入 aop 命名空间中的标记，请参见 the AOP schema。
5.4.2. Declaring an Aspect启用 @AspectJ 支持之后，Spring 会自动检测在应用上下文定义的具有 @Aspect 切面（有 @Aspect 注解）类的任何 Bean，并用于配置 Spring AOP。接下来两个例子展示了一个不是特别有用的切面的所需要的最小定义。
这两个示例中的第一个展示了应用上下文中的一个常规的 Bean 定义，它指向一个具有 @Aspect 注解的 Bean 类型。
&lt;bean id=&quot;myAspect&quot; class=&quot;org.xyz.NotVeryUsefulAspect&quot;&gt;    &lt;!-- configure properties of the aspect here --&gt;&lt;/bean&gt;


这两个示例中的第二个示例展示了 NotVeryUsefulAspect 类型的定义，该定义使用 org.aspectj.lang.annotation.Aspect 注解;
package org.xyz;import org.aspectj.lang.annotation.Aspect;@Aspectpublic class NotVeryUsefulAspect &#123;&#125;

与任何其他类相同，切面（使用 @Aspect 注解的类）可以有方法和字段。他们也可以包含切点，通知，和引入（类型间）声明。

通过组件扫描自动检测切面你可以将切面类注册为 Spring XML 配置中常规的 Bean，或者通过类路径扫描自动检测它们——与任何其他 Spring 管理的 Bean 相同。但是，注意 @Aspect 注解不足以在类路径中进行自动检测。为此，你需要添加一个单独的 @Component 注解（或者，根据 Spring 组件扫描器的规则，添加一个符合条件的自定义原型注解）。


用其他切面增强切面?在 Spring AOP 中，切面本身不能成为来自其他切面的增强目标。类上的 @Aspect 注解将其标记为切面，因此，将其排除在自动代理之外。

5.4.3. Declaring a Pointcut切入点可以确定感兴趣的连接点，从而让我们控制通知的运行时机。Spring AOP 仅仅支持方法 Spring bean 的方法执行连接点，因此你可以考虑 Spring bean 上的方法执行匹配的切入点。
切入点的声明有两个部分：

签名，包括名称和任何参数
切点表达式，精确指定哪些方法的执行是我们所感兴趣的

在 @AspectJ 注解风格的 AOP 中，切入点的签名由常规的方法定义提供，切入表达式由 @Pointcut 注解表示。
构成 @Pointcut 注解值的切入点表达式时常规的 AspectJ 5 切入点表达式。
Supported Pointcut DesignatorsSpring AOP 支持以下 AspectJ 切入点指示符用于切入点表达式：

execution：用于匹配方法执行连接点。
within：
this
target
args
@target
@args
@within
@annotation

Spring AOP 还支持一个名为 bean 的 PCD。该 PCD 允许你将连接点的匹配限定为特定名称的 Spring bean 或者一组名称的 Spring bean（使用通配符）。
Combining Pointcut Expressions你可以通过 &amp;&amp;, ||, ! 来组合切入点表达式。你也可以按名称引用切入点表达式。
@Pointcut(&quot;execution(public * *(..))&quot;)private void anyPublicOperation() &#123;&#125; @Pointcut(&quot;within(com.xyz.myapp.trading..*)&quot;)private void inTrading() &#123;&#125; @Pointcut(&quot;anyPublicOperation() &amp;&amp; inTrading()&quot;)private void tradingOperation() &#123;&#125; 


5.4.4. Declaring Advice通知和切入点表达式有关，然后在切入点匹配的方法 before，after 或者 around 执行。
Before Advice@Aspectpublic class BeforeExample &#123;    @Before(&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()&quot;)    public void doAccessCheck() &#123;    &#125;&#125;

After Returning Advice当匹配的方法执行正常返回时，After returning advice 将会执行。
有时候，你需要在通知体里面访问实际的返回值。你可以使用 @AfterReturning 绑定返回值，如下：
@Aspectpublic class AfterReturningExample &#123;    @AfterReturning(        pointcut=&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()&quot;,        returning=&quot;retVal&quot;)    public void doAccessCheck(Object retVal) &#123;        // ...    &#125;&#125;
属性 returning 中的名称必须与通知方法的参数名称相匹配。当方法执行返回时，返回值会传递给通知方法中相关的参数。returning 还限制只能匹配那些特定类型的返回值（本例中，Object 匹配任何返回值）
After Throwing Advice当匹配的方法以抛出异常的方式结束时，after throwing advice 会运行。
通常，你希望仅当给定类型的异常抛出时，运行某个通知，而且你也需要在通知体中访问该异常。你可以使用 throwing 属性进行限制匹配，并且绑定抛出的异常到通知参数。
@Aspectpublic class AfterThrowingExample &#123;    @AfterThrowing(        pointcut=&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()&quot;,        throwing=&quot;ex&quot;)    public void doRecoveryActions(DataAccessException ex) &#123;        // ...    &#125;&#125;
属性 throwing 中的名称必须与通知方法的参数名称相匹配。当方法是因为抛出异常而结束时，异常会传递给通知方法中相关的参数。throwing 也可以限制仅仅匹配方法执行过程中特定的异常（比如这里的 DataAccessException）。
&amp;nbsp;
After (Finally) Advice当匹配的方法执行退出时，After(finally) advice 会运行。通过 @After 注解声明。必须准备号 After 通知以处理正常和异常的返回条件。通常，它用于释放资源等。

注意 @AfterThrowing 并不表示通用的异常处理。@AfterThrowing 通知方法仅仅应该从连接点接收异常，而不是从伴随的 @After &#x2F; @AfterReturning 方法。

&amp;nbsp;
Around Advice环绕通知围绕着被匹配方法的执行。在方法执行前后，它均有机会工作，并确定何时，如何，甚至是否方法实际上是否要运行。如果你需要以线程安全的方式（例如，启动和停止计时器）在方法执行前后共享状态，通常需要时候 Around 通知。
官方建议 总是使用功能最小的通知形式来满足需求，即，如果需要前置通知，那么就不用使用环绕通知。
环绕通知使用 @Around 注解声明。通知方法的第一个参数必须是 ProceedingJoinPoint。在通知体里，调用 ProceedingJoinPoint.proceed() 方法会引起底层方法的运行。proceed 方法还可以传递一个 Object[]。数组中的值将作为执行方法时的参数。

用 Object[] 调用 proceed() 的行为与被 AspectJ 编译器编译的环绕通知的 proceed() 行为有点不同。对于使用传统 AspectJ 语言编写的环绕通知，传递给 proceed 的参数数量必须与传递给环绕通知的参数数量匹配，并且，在给定参数位置传递给 proceed 的值会取代在连接点处绑定到实体上的原始值。Spring 采取的方法更简单，更好地匹配基于代理的，仅仅执行语义。如果你编译为 Spring 所写的 @AspectJ 切面，并且与 AspectJ 编译器和 Weaver 一起使用 preceed 携带的参数，你只需要意识到这种差异。

环绕通知的返回值就是方法调用者可见的返回值，其他调用者并不会感知。例如，实现一个简单的缓存切面，如果存在缓存那么就从缓存中得到并返回值，如果不存在就调用 proceed()。
注意 可以在 Around 通知体中调用一次，多次，或者不调用 proceed() 方法。这些都是合法的。
Access to the Current JoinPoint任何的通知方法都可以将 org.aspectj.lang.JoinPoint 类型的参数声明为其第一个参数（注意，around 通知需要声明第一个参数类型为 ProceedingJoinPoint，它是 JoinPoint 的子类）。JoinPoint 接口提供了许多有用的方法：

getArgs()：返回方法参数
getThis()：返回代理对象
getTarget：返回目标对象
getSignature：返回被通知方法的描述
toString()：打印被通知方法的有用描述

有关更多细节，请参见 javadoc。
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC ReturnValueHandler 原理</title>
    <url>/2022/07/30/Framework/Java/Spring-Framework/Spring-MVC-ReturnValueHandler-%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[Spring MVC ReturnValueHandler 原理本文章中提及的 ReturnValueHandler 实际为 HandlerMethodReturnValueHandler 类型。
该 ReturnValueHandler 会在调用 handler 方法的时候发挥作用，其中通过以下代码注入：
// 注入类型为 HandlerMethodReturnValueHandlerComposite，是一个具有许多 ReturnValueHandler 的类型invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);


Handler Method 处理框架以下是 handler 方法被调用的整体流程: 
public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123;    // 调用 handler，获得返回值    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);    setResponseStatus(webRequest);    if (returnValue == null) &#123;        if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) &#123;            disableContentCachingIfNecessary(webRequest);            mavContainer.setRequestHandled(true);            return;        &#125;    &#125;    else if (StringUtils.hasText(getResponseStatusReason())) &#123;        // 与 ResponseStatus 相关        mavContainer.setRequestHandled(true);        return;    &#125;    mavContainer.setRequestHandled(false);    Assert.state(this.returnValueHandlers != null, &quot;No return value handlers&quot;);    try &#123;        // 处理返回值        this.returnValueHandlers.handleReturnValue(                returnValue, getReturnValueType(returnValue), mavContainer, webRequest);    &#125;    catch (Exception ex) &#123;        if (logger.isTraceEnabled()) &#123;            logger.trace(formatErrorForReturnValue(returnValue), ex);        &#125;        throw ex;    &#125;&#125;

Return Value 处理框架若要处理返回值，需要找到合适的返回值处理器，然后调用其 handleReturnValue 方法进行处理，以下是处理返回值的整体流程代码清单:
// HandlerMethodReturnValueHandlerCompositepublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,        ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123;    HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);    if (handler == null) &#123;        throw new IllegalArgumentException(&quot;Unknown return value type: &quot; + returnType.getParameterType().getName());    &#125;    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);&#125;


判断 Return Value 是否支持关于如何判断一个 ReturnValueHandler 是否支持这种返回值，主要是通过自定义实现的方法 supportsReturnType 完成，以下是挑选合适 ReturnValueHandler 的代码清单：
private HandlerMethodReturnValueHandler selectHandler(@Nullable Object value, MethodParameter returnType) &#123;    boolean isAsyncValue = isAsyncReturnValue(value, returnType);    for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) &#123;        if (isAsyncValue &amp;&amp; !(handler instanceof AsyncHandlerMethodReturnValueHandler)) &#123;            continue;        &#125;        if (handler.supportsReturnType(returnType)) &#123;            return handler;        &#125;    &#125;    return null;&#125;


是否支持该返回值，具体逻辑根据不同 ReturnValueHandler 有所不同，但一般来说都是通过类型判断

应该注意到，selectHandler 会首先调用 isAsyncReturnValue 判断是否是一个异步返回值，但默认情况下，始终返回 false，因为并不存在 AsyncHandlerMethodReturnValueHandler 实例，isAsyncReturnValue 逻辑如下:
private boolean isAsyncReturnValue(@Nullable Object value, MethodParameter returnType) &#123;    for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) &#123;        if (handler instanceof AsyncHandlerMethodReturnValueHandler &amp;&amp;                ((AsyncHandlerMethodReturnValueHandler) handler).isAsyncReturnValue(value, returnType)) &#123;            return true;        &#125;    &#125;    return false;&#125;


Spring MVC 支持的返回值
ModelAndView 对象

]]></content>
      <tags>
        <tag>Spring Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Web MVC HandlerAdapter 笔记</title>
    <url>/2022/07/23/Framework/Java/Spring-Framework/Spring-Web-MVC-HandlerAdapter-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[Spring BootSpring Boot 默认的 HandlerAdapter 有：

RequestMappingHandlerAdapter，注解 @RequestMapping
HandlerFunctionAdapter，端点
HttpRequestHandlerAdapter，用于一些静态资源
SimpleControllerHandlerAdapter，用于 Controller 接口


AnnotationMethodHandlerAdapter 是之前使用的一个，现在已经废弃

这些实现类需要关注的就是它们的方法：
boolean supports(Object handler);


RequestMappingHandlerAdapterRequestMappingHandlerAdapter 是 AbstractHandlerMethodAdapter 的子类，父类也已经实现了 supports() 方法：
public final boolean supports(Object handler) &#123;	return (handler instanceof HandlerMethod &amp;&amp; supportsInternal((HandlerMethod) handler));&#125;

该方法的返回值由两个条件决定：

第一个是 handler 是否是 HandlerMethod 的实例。如果之前的 HandlerMapping 是 RequestMappingHandlerMapping，那么它返回的一定是 HandlerMethod。
第二个是由子类实现的 supportsInternal() 方法，不过 RequestMappingHandlerAdapter 始终返回 true

HttpRequestHandlerAdapter一般用于适配静态资源请求
]]></content>
      <tags>
        <tag>Spring Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Framework Web Servlet</title>
    <url>/2022/05/09/Framework/Java/Spring-Framework/Spring-Framework-Web-Servlet/</url>
    <content><![CDATA[Web on Servlet Stack1. Spring Web MVCSpring Web MVC 是基于 Servlet API 的原始 Web 框架，从很早的时候就包含在 Spring Framework 之中。正式名称 —— Spring Web MVC，来源于它的源模块名称（spring-webmvc），但通常称之为 “Spring MVC”。
与 Spring Web MVC 平行，Spring Framework 5.0 引入了一个响应式栈 web 框架，其名称为 “Spring WebFlux”，也是基于其源模块（spring-webflux）。本节涵盖 Spring Web MVC。下一节涵盖 Spring WebFlux。
有关基线信息以及与 Servlet 容器和 Java EE 版本范围的兼容性，请参见 Spring Framework Wiki。
1.1. DispatcherServletWebFlux
与许多其他 Web 框架一样，Spring MVC 围绕着前端控制器模式设计，其中首要的 Servlet —— DispatcherServlet 为请求处理提供了一组共享的算法，而实际的工作则由可配置的代理组件执行。这种模型灵活，并且支持各种工作流。

作者的话 简单来说，DispatcherServlet 为所有请求提供统一的处理流程（doDispatch），但是细节部分由各个组件实现，而且并不是每个组件在处理每个请求时都会发挥作用。

正如任何 Servlet 一样，DispatcherServlet 也需要根据 Servlet 规范进行声明以及映射（路径），可以通过 Java 配置或者在 web.xml 中声明以及映射。反过来，DispatcherServlet 使用 Spring 配置，去发现它所需要的委托组件，比如用于请求映射，视图解析，异常处理的组件，等等。
下面是有关于 Java 配置注册以及初始化 DispatcherServlet 的示例，这会被 Servlet 容器自动检测（参见 Servlet Config）：
public class MyWebApplicationInitializer implements WebApplicationInitializer &#123;    @Override    public void onStartup(ServletContext servletContext) &#123;        // Load Spring web application configuration        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();        context.register(AppConfig.class);        // Create and register the DispatcherServlet        DispatcherServlet servlet = new DispatcherServlet(context);        ServletRegistration.Dynamic registration = servletContext.addServlet(&quot;app&quot;, servlet);        registration.setLoadOnStartup(1);        registration.addMapping(&quot;/app/*&quot;);    &#125;&#125;


除了直接使用 ServletContext API，你还可以继承 AbstractAnnotationConfigDispatcherServletInitializer 并覆盖特定的方法（见 Context Hierarchy 下面的例子）。


作者的话 不必太关心这里，只有基于外部容器部署的时候才会加载 WebApplicationInitializer

以下示例是 web.xml 配置注册以及初始化 DispatcherServlet：
&lt;web-app&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;/WEB-INF/app-context.xml&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;app&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;app&lt;/servlet-name&gt;        &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;


Spring Boot 遵循一种不同的初始化顺序。Spring Boot 并不是直接挂载到 Servlet 容器的生命周期，而是使用 Spring 配置来引导自身以及内嵌的 Servlet 容器。Filter 和 Servlet 的声明以 Spring 配置的方式被检测到，并注册到 Servlet 容器。

1.1.1. Context HierarchyDispatcherServlet 期望一个 WebApplicationContext（继承于简单 ApplicationContext） 用于自己的配置。WebApplicationContext 持有 ServletContext 的引用，并且持有相关的 Servlet 的引用。WebApplicationContext 也会绑定到 ServletContext，以便于应用程序在需要的时候可以通过 RequestContextUtiles 的静态方法找到 WebApplicationContext。

作者的话 上面这句话简单来看就是 WebApplicationContext 和 ServletContext 相互引用。ServletContext 绑定 WebApplicationContext 方式是设置为请求的属性。

对于许多应用程序而言，具有单个的 WebApplicationContext 是简易且足够用了。也有可能，有一种上下文结构，其中，根 WebApplicationContext 被多个 DispatcherServlet 实例共享（或者其他 Servlet），每个 Servlet 又有自己的子 WebApplicationContext 配置。有关上下文层次结构功能的更多信息，请参见  Additional Capabilities of the ApplicationContext
root WebApplicationContext 通常包含基于架构 Bean，例如数据仓库和业务服务，它们需要在多个 Servlet 实例上共享。这些 Bean 被有效继承，并且可以在特定于 Servlet 的子 WebApplicationContext 中覆盖，这通常包含给定的本地 Servlet Bean。下图展示了这种关系：


下面的示例配置了一个 WebApplicationContext 层次结构：
public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;    @Override    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;        return new Class&lt;?&gt;[] &#123; RootConfig.class &#125;;    &#125;    @Override    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;        return new Class&lt;?&gt;[] &#123; App1Config.class &#125;;    &#125;    @Override    protected String[] getServletMappings() &#123;        return new String[] &#123; &quot;/app1/*&quot; &#125;;    &#125;&#125;


如果不需要应用程序上下文的层次结构，应用程序可以通过 getRootConfigClasses() 返回所有的配置，并且在 getServletConfigClasses() 返回 null。

下面示例展示了 web.xml 的等价物：
&lt;web-app&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;/WEB-INF/root-context.xml&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;app1&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;/WEB-INF/app1-context.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;app1&lt;/servlet-name&gt;        &lt;url-pattern&gt;/app1/*&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;


如果应用程序不需要上下文层次结构，则可以仅仅配置 “root” 上下文，并保持 contextConfigLocation Servlet 参数为空。

1.1.2. Special Bean TypesDispatcherServlet 委托特殊的 Bean 来处理请求并给予合适的响应。通过“特殊 Bean”，我们意思是实现了框架约定的由 Spring 管理的 Object。这些通常带有内置的约定，但是你可以定制化它们的属性并扩展或更换它们。
下面的表格列出了由 DispatcherServlet 检测的特殊 Bean：



Bean Type
描述



HandlerMapping
将请求映射到 handler，以及前置处理拦截器和后置处理拦截器的列表。该映射基于某些规则，其中的细节随着 HandlerMapping 的实现有所不同。两个主要的 HandlerMapping 的实现类：(1) RequestMappingHandlerMapping ，它支持 @RequestMapping 注解方法(2) SimpleUrlHandlerMapping，它维护 URI 路径模式到 handler 的显式注册


HandlerAdapter
帮助 DispatcherServlet 调用映射到请求的 handler，不管 handler 实际是如何调用。例如，调用注解式控制器需要解析注解。HandlerAdapter 的主要目的是防止 DispatcherServlet 受此类细节的影响


HandlerExceptionResolver
解析异常的策略，可能会将它们映射到 handler，html 错误视图，或者其他目标


ViewResolver
从 handler 返回的基于字符串的逻辑视图名称解析为要呈现给响应的实际视图


LocaleResolver,LocaleContextResolver
解析客户端正在使用的 Locale 以及可能的时区，以便能提供国际化的视图。参见 Locale


ThemeResolver
解析你的 Web 应用程序可以使用的主题


MultipartResolver
在某些 multipart 解析库的帮助下，用于解析 multi-part 请求（例如，浏览器表单文件上传）。请参阅 Multipart Resolver


FlashMapManager



1.1.3. Web MVC Config应用程序可以声明一些在 Special Bean Types 列出的基础架构的 Bean，需要这些 Bean 来处理请求。DispatcherServlet 会为每个特殊 Bean 检查 WebApplicationContext。如果没有匹配的 Bean 类型，则会回退到使用 DispatcherServlet.properties 列出的默认 bean。
大多数情况下，MVC Config 是最佳出发点。它以 Java 或者 XML 的方式声明了需要的 bean，并且提供了更高级配置回调 API 用于自定义。

作者的话 MVC Config 是官方术语，代表 Spring MVC 提供的默认配置，可以是注解式启用，也可以是 XML 方式启用，具体来说就是 @EnableWebMvc 和 &lt;mvc:annotation-driven/&gt;


Spring Boot 依赖于 MVC Java Config 配置 Spring MVC，以及提供了许多额外的便利选项

1.1.4. Servlet Config
作者的话 对于 Spring Boot 来说，DispatcherServlet 是自动配置的，而且 Servlet 容器也是在 ApplicationContext 进行 refresh 的过程中内嵌启动的，所以这一节可以简单了解

在 Servlet 3.0+ 环境下，你可以选择使用编程方式作为一种替代方案进行 Servlet 容器配置，或者你也可以与 web.xml 方式组合使用。如下是注册一个 DispatcherServlet 的例子：
import org.springframework.web.WebApplicationInitializer;public class MyWebApplicationInitializer implements WebApplicationInitializer &#123;    @Override    public void onStartup(ServletContext container) &#123;        XmlWebApplicationContext appContext = new XmlWebApplicationContext();        appContext.setConfigLocation(&quot;/WEB-INF/spring/dispatcher-config.xml&quot;);        ServletRegistration.Dynamic registration = container.addServlet(&quot;dispatcher&quot;, new DispatcherServlet(appContext));        registration.setLoadOnStartup(1);        registration.addMapping(&quot;/&quot;);    &#125;&#125;

WebApplicationInitializer 是由 Spring MVC 提供的接口，可以确保检测到你的实现类并用于初始化任何 Servlet 3 容器。WebApplicationInitializer 的一个实现类（抽象基类）是 AbstractDispatcherServletInitializer，你可以通过覆盖父类方法指定 Servlet 映射以及 DispatcherServlet 配置的路径使得注册 DispatcherServlet 更加容易。
应用程序使用基于 Java 的 Spring 配置如下示例所示，这也是官方建议的方式：
public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;    @Override    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;        return null;    &#125;    @Override    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;        return new Class&lt;?&gt;[] &#123; MyWebConfig.class &#125;;    &#125;    @Override    protected String[] getServletMappings() &#123;        return new String[] &#123; &quot;/&quot; &#125;;    &#125;&#125;

如果使用基于 XML 的 Spring 配置，则应该直接从 AbstractDispatcherServletInitializer 继承下来，如下示例所示：
public class MyWebAppInitializer extends AbstractDispatcherServletInitializer &#123;    @Override    protected WebApplicationContext createRootApplicationContext() &#123;        return null;    &#125;    @Override    protected WebApplicationContext createServletApplicationContext() &#123;        XmlWebApplicationContext cxt = new XmlWebApplicationContext();        cxt.setConfigLocation(&quot;/WEB-INF/spring/dispatcher-config.xml&quot;);        return cxt;    &#125;    @Override    protected String[] getServletMappings() &#123;        return new String[] &#123; &quot;/&quot; &#125;;    &#125;&#125;

AbstractDispatcherServletInitializer 还提供了一种添加 Filter 实例，并将其自动映射到 DispatcherServlet 的简便方法，如下示例所示：
public class MyWebAppInitializer extends AbstractDispatcherServletInitializer &#123;    // ...    @Override    protected Filter[] getServletFilters() &#123;        return new Filter[] &#123;            new HiddenHttpMethodFilter(), new CharacterEncodingFilter() &#125;;    &#125;&#125;

添加的每个过滤器都会基于其具体类型有一个默认名字，并自动映射到 DispatcherServlet。

作者的话 将 Filter 映射到 DispatcherServlet 的方式是通过 Servlet API javax.servlet.FilterRegistration#addMappingForServletNames 实现的

AbstractDispatcherServletInitializer 的 protected 方法 isAsyncSupported 提供了一个地方可以在 DispatcherServlet 上启用异步支持，并且所有过滤器都会映射到它上面。默认地，这个标志位是 true
最后，如果你需要进一步自定义 DispatcherServlet 本身，你可以直接覆盖 createDispatcherServlet 方法。
1.1.5. ProcessingDispatcherServlet 处理过程如下：

搜索 WebApplicationContext 并将其绑定到 Request 的属性上，处理过程中控制器和其他元素可能会使用到。默认绑定到 DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE key 上。

将 locale resolver 绑定到 Request 的属性上，以便于当处理请求的过程中让其他元素解析本地化使用。如果你不需要本地化解析，你就不必使用 locale resolver。

将主题解析器绑定到请求，以使视图之类的元素确定用何种主题。如果你不使用主题，可以忽略它。

如果你指定了一个 multipart 文件解析器，将会检查请求的 multiparts。如果找到了 multiparts，请求会被包装成 MultipartHttpServletRequest，用于过程后期其他元素的处理。

搜索合适的 handler。如果找到了一个 handler，与该 handler 有关的执行链（前置处理器、后置处理器、控制器）将会运行，用于准备 model 的渲染。或者，对于注解式控制器，响应可以直接渲染（在 HandlerAdapter）而不是返回一个视图。

如果返回的是 model，视图就会被渲染。如果没有返回 model（可能由于前置处理器或者后置处理器拦截了请求，可能是因为安全问题），就不会渲染视图，因为请求已经完成了。


声明在 WebApplicationContext 的 HandlerExceptionResolver bean 用于解析请求处理过程中抛出的异常。允许自定义异常处理器的逻辑用于处理异常。
DispatcherServlet 还支持返回 last-modification-date，正如 Servlet API 指定的。确定特定请求的最后一次修改日期很简单：DispatcherServlet 寻找合适的 handler mapping，并检测被找到的 handler 是否实现了 LastModified 接口。如果是，接口 LastModified 的方法 long getLastModified(request) 的值就会返回给客户端。

作者的话 注解式 Controller 想要实现最后一次修改日期需要做一些特殊操作，因为 RequestMappingHandlerAdapter 的 getLastModified 总是返回 -1，但源码方法注解也给了我们指引，需要在 handler 中调用 WebRequest#checkNotModified(long)，如果返回值是 true，则返回 null

你可以通过在 web.xml 文件中添加 Servlet 初始化参数到 Servlet 声明中来自定义一个自己 DispatcherServlet。以下列表列出了支持的参数：



参数
解释



contextClass
实现了 ConfigurableWebApplicationContext 的类，将由此 Servlet 进行实例化与本地配置。默认地，使用 XmlWebApplicationContext。


contextConfigLocation
传递给上下文实例的字符串，标识从哪里寻找上下文。


namespace
WebApplicationContext的命名空间。默认是 [servlet-name]-servlet


throwExceptionIfNoHandlerFound
当找不到请求的 handler 时，是否抛出异常


1.1.6. Interception所有的 HandlerMapping 实现类都支持 handler 拦截器，这很有用，比如你希望将某些特定的功能应用于某些请求，举个例子，检查 principal。
拦截器必须实现 org.springframework.web.servlet.HandlerInterceptor 接口，它提供了三个方法，应该可以足够灵活地执行各种前置处理以及后置处理操作。

preHandle(..): 在实际的 handler 运行之前
postHandle(..): 在实际的 handler 运行之后
afterCompletion(..): 在完整的请求结束之后

preHandle(..) 方法返回一个 boolean 值。你可以使用此方法 break 或者 continue 执行链的执行。当方法返回 true，handler 执行链就会继续；当方法返回 false，DispatcherServlet 会认为拦截器本身已经处理了请求（例如，渲染了恰当的视图），并且不会继续执行其他拦截器以及实际的 handler。
请注意，当具有 @ResponseBody 以及 ResponseEntity 的时候，postHandle 没什么用，因为在 postHandle 之前响应就会在 HandlerAdapter 中写入并提交了。这意味着，对响应进行任何更改为时已晚，例如添加额外的 header 都是无用的。对于这种情况，你可以实现 ResponseBodyAdvice，并将它声明为一个 Controller Advice bean，或者，你也可以直接在 RequestMappingHandlerAdapter 上直接配置。
1.1.7. Exceptions如果请求 mapping 期间或者请求 handler（如 @Controller）抛出异常，则 DispatcherServlet 将委托给 HandlerExceptionResolver 链解析异常，并提供可替代的处理，这是典型的错误响应。

作者的话 其实就是 try catch 模式，catch 中处理异常

以下表格列出了可用的 HandlerExceptionResolver 实现类：



HandlerExceptionResolver
描述



SimpleMappingExceptionResolver
异常类名于错误视图名之间的映射。


DefaultHandlerExceptionResolver
解析 Spring MVC 的异常，并将它们映射到 HTTP 状态码


ResponseStatusExceptionResolver
用 @ResponseStatus 注解解析异常，并根据注解中的值将其映射到 HTTP 状态码


ExceptionHandlerExceptionResolver
通过调用 @Controller 或者 @ControllerAdvice 中的 @ExceptionHandler 方法解析异常


HandlerExceptionResolver 的约定规定它可以返回：

一个指向错误视图的 ModelAndView
如果在解析器处理了异常，则是一个空的 ModelAndView
如果异常仍然未解析，则返回 null，后面的解析器继续尝试，如果最后仍然未解析，可以冒泡到 Servlet 容器

MVC Config 自动地为默认的 Spring MVC 异常，@ResponseStatus 注解异常，以及 @ExceptionHandler 方法的支持声明了内置的解析器。你可以自定义或者替换它们。
Chain of Resolvers可以通过 HandlerExceptionResolver 在 Spring 配置中声明多个 bean 并根据需要设置他们的 order 属性。order 越高，异常处理器位置越靠后（越晚处理）。
HandlerExceptionResolver 约定可以返回如下：

ModelAndView 跳转到错误页面
如果在解析器里处理了异常，则可以返回一个空的 ModelAndView 
如果异常仍未处理，则返回 null，供后续解析器继续尝试，如果异常一直存在，允许冒泡到 Servlet 容器。

Container Error Page如果没有任何 HandlerExceptionResolver 处理异常，那么就会传播出去，或者如果响应状态为错误状态（即 4xx, 5xx），那么 Servlet 容器会在 HTML 中渲染默认的错误页面。要自定义容器的默认错误页面，可以在 web.xml 声明一个错误页面映射，如下示例所示：
&lt;error-page&gt;    &lt;location&gt;/error&lt;/location&gt;&lt;/error-page&gt;

给定之前的例子，当异常向上冒泡或者响应具有一个错误状态，Servlet 容器会将错误派发到配置的 URL（例如，/error）。接着，由 DispatcherServlet 处理，可能将其映射到一个 @Controller，其实现可以返回一个带有 model 的错误视图名，或者返回一个 JSON 响应，如下示例所示：
@RestControllerpublic class ErrorController &#123;    @RequestMapping(path = &quot;/error&quot;)    public Map&lt;String, Object&gt; handle(HttpServletRequest request) &#123;        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        map.put(&quot;status&quot;, request.getAttribute(&quot;javax.servlet.error.status_code&quot;));        map.put(&quot;reason&quot;, request.getAttribute(&quot;javax.servlet.error.message&quot;));        return map;    &#125;&#125;

1.1.11. Multipart Resolverorg.springframework.web.multipart.MultipartResolver 是解析包含文件上传的 multipart 请求的策略接口。

其中一个实现是基于 Commons FileUpload 框架
另一个是基于 Servlet 3.0 multipart 请求解析

Apache Commons FileUpload为了使用 Apache 的 Commons FileUpload：

配置一个 CommonsMultipartResolver，名称任意，如：multipartResolver
添加 commons-fileupload 依赖

Servlet 3.01.2. Filters1.2.1. Form Data浏览器只能通过 HTTP GET 或者 HTTP POST 提交表单数据，但是，非浏览器的客户端（比如 Postman）还可以使用 HTTP PUT, PATCH, DELETE 等。Servlet API 规定：ServletRequest.getParameter*() 系列方法仅仅支持访问 HTTP POST 的表单字段。
spring-web 模块提供了 FormContentFilter，拦截 Content Type 为 application/x-www-form-urlencoded 的 HTTP PUT, PATCH, DELETE 请求，读取请求体的表单数据，然后将 ServletRequest 进行一层包装，接着就可以通过 ServletRequest.getParameter*() 系列方法直接访问表单数据了。
1.2.2. Forwarded Headers当请求通过代理（例如，负载均衡器）时，主机，端口号，以及 schema 可能会更改，这使得形成一个指向用户正确的主机，端口和 schema 的连接比较困难。
RFC 7239 定义了 Forwarded HTTP 头部，代理可以用它来提供关于原始请求的信息。还有一些其他的非标准头部，包括 X-Forwarded-Host, X-Forwarded-Port, X-Forwarded-Proto, X-Forwared-Ssl, 以及 X-Forwarded-Prefix。
ForwardedHeaderFilter 是一个 Servlet 过滤器，它可以修改请求：a) 基于Forwarded 头部的主机，端口号，以及 schema；b) 删除这些头部，防止影响后期。该过滤器依赖于包装请求，因此，必须排在其他过滤器（如 RequestContextFilter）之前，它应该与修改后的，而不是原始请求一起使用。
由于应用程序并不知道 header 是否由代理（这是预期的），还是由恶意客户端添加的，因此有必要对于 Forwared 头部做一些安全考虑。这就是为什么在信任边界上（最外层）的代理应该做一层配置，去删除那些从外部传来的不信任的 Forwarded 头部。你还可以给 ForwardedHeaderFilter 配置 removeOnly=true，这种情况下，它会删除不使用这些头部。
1.2.4. CORSSpring MVC 通过控制器的注解，为 CORS 配置提供了细粒度的支持。但是，当你和 Spring Security 一起使用时，建议依赖于内置的 CorsFilter，它必须排在 Spring Security 的过滤器链之前。
1.3. Annotated ControllersSpring MVC 提供了一个基于注解的编程模型，其中 @Controller 和 @RestController 组件用注解来表示请求的映射、请求的输入、异常的处理等。
被注解的控制器具有灵活的方法签名（即方法名、参数个性化定制），不必扩展基类也不必实现特定接口。
以下例子展示了一个由注解定义的控制器：
@Controllerpublic class HelloController &#123;    @GetMapping(&quot;/hello&quot;)    public String handle(Model model) &#123;        model.addAttribute(&quot;message&quot;, &quot;Hello World!&quot;);        return &quot;index&quot;;    &#125;&#125;

在上面的例子中，该方法接受 Model 并将视图名称以 String 形式返回。
1.3.1. Declaration你可以在 Servlet 的 WebApplicationContext 中使用标准的 Spring Bean definition 来定义控制器 bean。@Controller 注解允许自动检测，这与 Spring 通用支持检测类路径中的 @Component 类并自动注册 bean definition 是一致的。@Controller 还充当注解类的刻板印象，表示其作为 Web 组件。

刻板印象是译词，表示该注解具有特定语义。

1.3.2. Request Mapping你可以使用 @RequestMapping 注解将请求映射到控制器方法。该注解有各种属性去映射，如：URL、HTTP 方法、请求参数、请求头、媒体类型。你可以在类级别使用它来表示共享映射或者在特定方法级别上使用来缩小到特定的端点映射。
还有一些 @RequestMapping 的特定快捷变体：

@GetMapping
@PostMapping
@PutMapping
@DeleteMapping
@PatchMapping

快捷变体是自定义注解，因为，大多数控制器方法应该映射到特定的 HTTP 方法，而不是使用 @RequestMapping。在类级别，仍然需要 @RequestMapping 来表示共享映射。

默认地，@RequestMapping 与所有 HTTP 方法适配。

URI patterns


Pattern
Description
Example



?
匹配一个字符
&quot;/pages/t?st.html&quot;匹配 &quot;/pages/test.html&quot;  &quot;/pages/t3st.html&quot;


*
匹配零个或多个字符
&quot;/resources/*.png&quot;匹配 &quot;/resources/file.png&quot;&quot;/projects/*/versions&quot;匹配 &quot;/projects/spring/versions&quot;，但不匹配 &quot;/projects/spring/boot/versions&quot;


**
匹配零个或多个路径段，直到路径结束
&quot;/resources/**&quot;匹配 &quot;/resources&quot;  &quot;/resources/file.png&quot;  &quot;/resources/images/file.png&quot;


&#123;name&#125;
匹配一条路径段，并将其捕获为名为 “name” 的变量
&quot;/projects/&#123;project&#125;/versions&quot;匹配 &quot;/projects/spring/versions&quot;，并捕获 project=spring


&#123;name:[a-z]+&#125;
匹配正则表达式 &quot;[a-z]+&quot; 作为名为 “name” 的路径变量
&quot;/projects/&#123;project:[a-z]+&#125;/versions&quot;匹配 &quot;/projects/spring/versions&quot;，但不匹配 &quot;/projects/spring1/versions&quot;


1.3.3. Handler Methods@RequestMapping 处理器方法具有灵活的签名，可以从一系列支持的控制器方法参数和返回值中进行选择。
Method Arguments


Controller method argument
Description



WebRequest,NativeWebRequest
无需直接使用 Servlet API，对请求参数、请求属性、会话属性的通用访问


javax.servlet.ServletRequest, javax.servlet.ServletResponse
选择任何特定的请求或相应类型，例如，ServletRequest, HttpServletRequest, 或者 Spring 的 MultipartRequest, MultipartHttpServletRequest


javax.servlet.http.HttpSession
强制 Session 必须存在。因此，该参数不可能是 null。注意，Session 访问不是线程安全的。如果允许多个请求可以同时访问会话，考虑设置 RequestMappingHandlerAdapter 实例的 synchronizeOnSession 标志位为 tue


javax.servlet.http.PushBuilder



java.security.Principal



HttpMethod
请求的 HTTP 方法


java.util.Locale
当前请求的语言环境，由可用的最准确的 LocaleResolver 决定（配置的 LocaleResolver 或者 LocaleContextResolver


java.util.TimeZone + java.time.ZoneId



java.io.InputStream,java.io.Reader
通过 Servlet API 访问暴露的原始请求体


java.io.OutputStream,java.io.Writer
通过 Servlet API 访问暴露的原始响应体


@PathVariable
用于访问 URI 模板变量


@MatrixVariable



@RequestParam
用于访问 Servlet 请求参数，包括 multipart 文件


@RequestHeader
用于访问请求头


@CookieValue
用于访问 cookie


@RequestBody
用于访问 HTTP 请求体


HttpEntity&lt;B&gt;



@RequestPart
用于访问 multipart/form-data 请求中的 part


java.util.Map, org.springframework.ui.Model, org.springframework.ui.ModelMap



RedirectAttributes



@ModelAttribute
用于访问模型中的现有属性（如果不存在则实例化），同时应用数据绑定和验证。请参阅 @ModelAttribute 以及 Model 和 DataBinder


Errors,BindingResult



SessionStatus + class-level @SessionAttributes



UriComponentsBuilder



@SessionAttribute



@RequestAttribute



Any other argument



Return ValuesWebFlux
下表描述了支持的控制器方法返回值。所有返回值也支持响应式类型。



Controller method return value
Description



@ResponseBody
返回值通过 HttpMessageConverter 实现类进行转换，并写入 response 中。见 @ResponseBody


HttpEntity&lt;B&gt;,ResponseEntity&lt;B&gt;
指定完整的响应（包括 HTTP 响应头以及响应体），将通过 HttpMessageConverter 实现类转换，并写入响应


HttpHeaders
用于返回一个只有响应头，没有响应体的 response


String
一个视图名，使用 ViewResolver 实现类进行解析，并与隐式 model 一起使用 —— 通过命令对象和 @ModelAttribute 方法确定。handler 方法也可以通过声明一个 Model 参数编程式地丰富 model（见）Explicit Registrations


View
与隐式 model一起用于渲染的 View 实例 —— 通过命令对象和 ModelAttribute 方法确定。handler 方法也可以通过声明一个 Model 参数编程式地丰富 model（见）Explicit Registrations


java.util.Map, org.springframework.ui.Model
要添加到隐式 model 中的属性，其中视图名称通过一个 RequestToViewNameTranslator 隐式确定


@ModelAttribute
要添加到 model 中的属性，其视图名通过 RequestToViewNameTranslator 隐式确定。请注意，ModelAttribute 是可选的。在此表的末尾，请参见 “Any other return value”。


ModelAndView object
要使用的视图和model属性，以及可选的响应状态。


void
一个具有 void 返回类型的方法，如果它还具有一个 ServletResponse，一个 OutputStream 参数，或者一个 @ResponseStatus 注解，那么将认为该方法已经完全处理了该响应。如果控制器做出了正数的 ETag 或者 lastModified 时间戳检查，也是如此。如果以上都不正确，则 void 返回值还可以表示 REST 控制器 “没有响应体”，或者对于 HTML 控制器来说表示选择默认的视图名。


DeferredResult&lt;V&gt;
从任何线程中异步地产生前面返回值的任意 —— 例如，由于某些事件或回调。请参阅 Asynchronous Requests 和 DeferredResult


Callable&lt;V&gt;
在 Spring MVC 管理的线程中异步产生上述任何返回值。请参阅 Asynchronous Requests 和 Callable


ListenableFuture&lt;V&gt;, java.util.concurrent.CompletionStage&lt;V&gt;, java.util.concurrent.CompletableFuture&lt;V&gt;
替代 DeferredResult，以方便起见（例如，当底层服务返回它们其中之一）


ResponseBodyEmitter, SseEmitter
使用 HttpMessageConverter 实现类将对象的流异步地散发出去


StreamingResponseBody
异步的写入 OutputStream


反应性类型 —— Reactor, RxJava, 或者通过 ReactiveAdapterRegistry 的其他



Any other return value



Type Conversion如果 Controller 方法参数声明为 String 以外的其他类型，则某些带有 @RequestParam、@RequestHeader、@PathVariable 等注解的参数可能需要类型转换。
对于上述情况，将根据配置的转换器自动进行类型转换。默认地，支持一些简单的类型，如 int, long, Date 等。也可由通过 WebDataBinder 或者通过使用 FormattingConversionService 注册 Formatters 来自定义类型转换。
@ModelAttribute在方法参数上使用 @ModelAttribute 注解来访问 model 中的属性。model 属性还涵盖来自 HTTP Servlet 请求参数的值，其名称与字段名称匹配，这称为数据绑定，让你不必处理解析和转化单个 query 参数以及 form 字段。以下例子展示了如何做：
@PostMapping(&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit&quot;)public String processSubmit(@ModelAttribute Pet pet) &#123;    // method logic...&#125;


官方提示 @ModelAttribute 是可选的。默认地，任何非简单类型（由 BeanUtils#isSimpleProperty 决定），且未被任何其他参数解析器解析的参数，都会被当作使用了 @ModelAttribute 注解进行解析。 这是因为 HandlerMethodArgumentResolverComposite#argumentResolvers（这是一个 List） 包含了两个 ServletModelAttributeMethodProcessor，一个在中间，一个在最后，不同点在于属性 annotationNotRequired，位于中间的 annotationNotRequired=false，即必须有 @ModelAttribute 注解；位于最后的 annotationNotRequired=true，即没有被 @ModelAttribute 注解，所以，在搜索 Processor 进行处理的过程中，如果一直没有参数解析器可以解析，就会使用最后的 ServletModelAttributeMethodProcessor 进行解析。

注意点：(1) 对简单参数不进行任何注解，可以认为与 @RequestParam(required = false) 等效，而且如果只是添加了 @RequestParam 注解，缺乏该参数反而会报错。
(2) @ModelAttribute 可以注解在方法上，先于 Controller 方法执行。
@SessionAttributes@SessionAttributes 用于在请求之间的 HTTP Servlet 会话中存储 model 属性。
这是一个类级别注解，该注解声明指定控制器使用的会话属性。
通常列出了应该透明地存储于 session 中的 model 属性的名称或者 mode 属性的类型，以供后续请求访问。、
以下示例使用 @SessionAttributes 注解：
@Controller@SessionAttributes(&quot;pet&quot;)   public class EditPetForm &#123;    // ...&#125;
在第一次请求中，当具有名称 pet 的 model 属性添加到 Model 时，它会自动升级并保存到 HTTP Servlet Session 中。它会一直存储在那里，直到另一个控制器方法使用 SessionStatus 方法参数去清除存储，如下示例所示：
@Controller@SessionAttributes(&quot;pet&quot;) public class EditPetForm &#123;    // ...    @PostMapping(&quot;/pets/&#123;id&#125;&quot;)    public String handle(Pet pet, BindingResult errors, SessionStatus status) &#123;        if (errors.hasErrors) &#123;            // ...        &#125;        status.setComplete();         // ...    &#125;&#125;

@SessionAttribute如果你需要访问全局管理的预先存在的 session 属性（即，控制器之外，例如，通过过滤器产生），可能存在也可能不存在，你可以在方法参数上使用 @SessionAttribute 注解，正如下面的示例所示：
@RequestMapping(&quot;/&quot;)public String handle(@SessionAttribute User user) &#123;     // ...&#125;

对于需要添加或者删除会话属性的案例，请考虑注入 org.springframework.web.context.request.WebRequest 或者 javax.servlet.http.HttpSession 到控制器方法。
对于要作为控制器工作流程的一部分在会话中临时存储 model 属性，请考虑使用 @SessionAttributes。
@RequestAttribute类似于 @SessionAttribute，你可以使用 @RequestAttribute 注解去访问事先已经存在的 Request 属性（例如，通过 Filter 或者 HandlerInterceptor 注入的属性）：
@GetMapping(&quot;/&quot;)public String handle(@RequestAttribute Client client) &#123;     // ...&#125;

Multipart启用了 MultipartResolver 之后，使用 multipart/form-data 的 POST 请求内容会被解析并且可以作为一般的请求参数访问。

Spring Boot 会通过 MultipartAutoConfiguration 自动注入 MultipartResolver

下面的示例访问了一个一般的表单字段以及一个上传的文件：
@Controllerpublic class FileUploadController &#123;    @PostMapping(&quot;/form&quot;)    public String handleFormUpload(@RequestParam(&quot;name&quot;) String name,            @RequestParam(&quot;file&quot;) MultipartFile file) &#123;        if (!file.isEmpty()) &#123;            byte[] bytes = file.getBytes();            // store the bytes somewhere            return &quot;redirect:uploadSuccess&quot;;        &#125;        return &quot;redirect:uploadFailure&quot;;    &#125;&#125;

将参数类型声明为 List&lt;MultipartFile&gt; 允许解析相同参数名的多个文件。
当 @RequestParam 没有指定注解参数名，且被声明为 Map&lt;String, MultipartFile&gt; 或者 MultiValueMap&lt;String, MultipartFile&gt;，，那么对于每个给定参数名的 multipart 文件都会填充到 map 中。

作者的话 这种用法请勿设置参数名，否则会发生转化错误；而且这种用法无法收集多个相同参数名的 multipart 文件。


官方 如果使用了 Servlet 3.0 multipart 解析，你还可以声明 javax.servlet.http.Part 作为方法参数或者集合的 Value 类型，以取代 Spring 的 MultipartFile

你还可以将 multipart 内容作为绑定到命令对象的数据的一部分。例如，前面示例中的表单字段和文件可以是表单对象上的字段，如下示例所示：

作者的话 命令对象：command object，可以理解为复合对象

class MyForm &#123;    private String name;    private MultipartFile file;    // ...&#125;@Controllerpublic class FileUploadController &#123;    @PostMapping(&quot;/form&quot;)    public String handleFormUpload(MyForm form, BindingResult errors) &#123;        if (!form.getFile().isEmpty()) &#123;            byte[] bytes = form.getFile().getBytes();            // store the bytes somewhere            return &quot;redirect:uploadSuccess&quot;;        &#125;        return &quot;redirect:uploadFailure&quot;;    &#125;&#125;

在 RESTful 服务方案中，也可以从非浏览器的客户端提交 multipart 请求。如下示例展示了一个带有 JSON 的文件：
POST /someUrlContent-Type: multipart/mixed--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7VpContent-Disposition: form-data; name=&quot;meta-data&quot;Content-Type: application/json; charset=UTF-8Content-Transfer-Encoding: 8bit&#123;    &quot;name&quot;: &quot;value&quot;&#125;--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7VpContent-Disposition: form-data; name=&quot;file-data&quot;; filename=&quot;file.properties&quot;Content-Type: text/xmlContent-Transfer-Encoding: 8bit... File Data ...

你可以用 @RequestParam 以 String  的方式访问 “meta-data” 部分，但是有可能你想将他从 JSON 反序列化（类似于 @RequestBody）。使用 @RequestPart 注解可以访问被 HttpMessageConverter 转换之后的 multipart：
@PostMapping(&quot;/&quot;)public String handle(@RequestPart(&quot;meta-data&quot;) MetaData metadata,        @RequestPart(&quot;file-data&quot;) MultipartFile file) &#123;    // ...&#125;


作者的话 这种情况下需要特殊设置某个文件的 Content-Type 为 application&#x2F;json

1.3.4. Model你可以使用 @ModelAttribute 注解：

@RequestMapping 方法上的一个方法参数上，用于创建或者访问一个来自 model 的 Object，并通过 WebDataBinder 将它绑定到请求

作为 @Controller 或者 @ControllerAdvice 类中方法级注解，帮助在任何 @RequestMapping 方法调用之前初始化 model

用于 @RequestMapping 方法，标记其返回值是 model 属性


本节讨论 @ModelAttribute 方法，前面列表中的第 2 项。一个控制器可以有任意数量的 @ModelAttribute 方法。在同一个控制器的 @RequestMapping 方法之前，所有此类的方法都会被调用。@ModelAttribute 方法也可以通过 @ControllerAdvice 在控制器之间共享。详见…
@ModelAttribute 具有灵活的方法签名。他们支持许多与 @RequestMapping 方法相同的参数，除了 @ModelAttribute 本身，或者与请求体相关的任何内容。
以下示例展示了 @ModelAttribute 方法：
@ModelAttributepublic void populateModel(@RequestParam String number, Model model) &#123;    model.addAttribute(accountRepository.findAccount(number));    // add more ...&#125;

以下示例添加了仅仅 1 个属性：
@ModelAttributepublic Account addAccount(@RequestParam String number) &#123;    return accountRepository.findAccount(number);&#125;

你看也可以在 @RequestMapping 方法上使用 @ModelAttribute 作为方法级注解，在这种情况下，@RequestMapping 方法的返回值会被解释为 model 属性。这通常不需要，因为这是 HTML 控制器的默认行为，除非返回值是 String，会被解释成视图名字。@ModelAttribute 也可以自定义 model 属性名，如下示例所示：
@GetMapping(&quot;/accounts/&#123;id&#125;&quot;)@ModelAttribute(&quot;myAccount&quot;)public Account handle() &#123;    // ...    return account;&#125;

1.3.5. DataBinder@Controller 和 @ControllerAdvice 类可以具有 @InitBinder 方法，用来初始化 WebDataBinder 实例，而这些方法又可以：

绑定请求参数（即，Form 或者 Query 数据）到 model 对象
将基于字符串的请求值（例如请求参数，路径变量，请求头，cookie等）转换为控制器方法参数的目标类型
当渲染 HTML 形式时，将 model 对象值以 String 值格式化


tips: 也就是说 WebDataBinder 不仅控制 Controller 入参，也控制出参。

@InitBinder 方法可以注册特定于控制器的 java.bean.PropertyEditor 或者 Spring Converter 以及 Formatter 组件。此外，你也可以使用 MVC Config 在全局共享的 FormattingConversionService 注册 Converter 以及 Formatter。
@InitBinder 方法支持许多跟 @RequestMapping 一样支持的参数，除了 @ModelAttribute （command object）参数。通常，这些方法以一个 WebDataBinder 参数（用于注册）声明，并返回一个 void。下面展示了一个例子：
@Controllerpublic class FormController &#123;    @InitBinder     public void initBinder(WebDataBinder binder) &#123;        SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);        dateFormat.setLenient(false);        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));    &#125;    // ...&#125;

另外，当你通过共享的 FormattingConversionService 使用基于 Formatter 的设置时，你可以再使用相同的方式注册特定于控制器的 Formatter 实现，如下示例所示：
@Controllerpublic class FormController &#123;    @InitBinder     protected void initBinder(WebDataBinder binder) &#123;        binder.addCustomFormatter(new DateFormatter(&quot;yyyy-MM-dd&quot;));    &#125;    // ...&#125;
1.3.6. Exceptions@Controller 和 @ControllerAdvice 类可以拥有 @ExceptionHandler 方法来处理来自控制器方法的异常，如下示例所示：
@Controllerpublic class SimpleController &#123;    // ...    @ExceptionHandler    public ResponseEntity&lt;String&gt; handle(IOException ex) &#123;        // ...    &#125;&#125;

上述例子中，异常可能与顶级异常（top-level）相匹配（即，直接抛出的 IOException），或者与在顶级包装器异常的直接 cause 相匹配（例如，IOException 被包裹在 IllegalStateException）。

作者的话 顶级异常（top-level）可以理解为最外层异常，通常是一个模糊异常，并不具体，另外异常有一个 cause，通常表示具体异常，这里也可以匹配到进行处理。

对于匹配的异常类型，最好将目标异常声明为方法参数，如前面的示例所示。当多个异常方法匹配时，根异常匹配通常比 cause 异常匹配优先级更高。更具体地，使用 ExceptionDepthComparator 基于异常类型的深度来对异常进行排序。
另外，注解声明可能会缩小匹配的异常类型范围，如下示例所示：
@ExceptionHandler(&#123;FileSystemException.class, RemoteException.class&#125;)public ResponseEntity&lt;String&gt; handle(IOException ex) &#123;    // ...&#125;

你甚至可以使用特定的异常类型数组，以及一个非常通用的参数签名，如以下示例所示：
@ExceptionHandler(&#123;FileSystemException.class, RemoteException.class&#125;)public ResponseEntity&lt;String&gt; handle(Exception ex) &#123;    // ...&#125;


根异常匹配和 cause 异常匹配可能令人觉得很惊讶。在前面展示的 IOException 变量中，该方法通常以实际的 FileSystemException 或者 RemoteException 实例作为参数，因为它们两个都从 IOException 继承。但是，如果在包装器异常中的任何这样的相匹配的异常被传播出来，它们本身也是一个 IOException，则传递的异常实例是包装器异常。作者的话 也就是需要通过 ex.getCause() 才能拿到具体异常这种行为在 handle(Exception) 变量中更简单。在包装方案下，总是以包装器异常调用异常处理方法，在这种情况下，通过 ex.getCause() 找到实际匹配的异常。仅当作为顶级异常抛出的时候，传递的异常才是实际的 FileSystemException 或者 RemoteException。作者的话 不过，你调用 ex.getCause() 拿到的也是具体异常，因为 this.cause=this

我们通常建议你在参数签名中尽可能具体，可以降低 root 异常类型和 cause 异常类型之间不匹配的可能性。考虑将多匹配方法分解为单个 @ExceptionHandler 方法，每个方法都通过其签名匹配单个特定异常类型。

作者的话 官方就是建议你将每个具体的异常都写一个 @ExceptionHandler

在多个 @ControllerAdvice 安排下，建议你在 @ControllerAdvice 上声明你的主要 root 异常映射，该映射使用相关的 order 优先使用。虽然 root 异常匹配优先于 cause，但是这是在给定的 @Controller 或者 @ControllerAdvice 类方法中定义。这意味着，在较高优先级 @ControllerAdvice bean 上的 cause 匹配优先于任何较低级的 @ControllerAdvice bean。
Method Arguments@ExceptionHandler 方法支持以下参数：



方法参数
描述







Return Values1.3.7. Controller Advice通常，@ExceptionHandler，@InitBinder，以及 @ModelAttribute 方法应用于 @Controller 类（或者类继承层次），将这些注解声明在里面。如果你希望这样的方法在全局范围内更多地应用（跨控制器），则可以在 @ControllerAdvice 或者 @RestControllerAdvice 注解类中声明它们。
@ControllerAdvice 使用 @Component 注解，这意味着这样的类可以通过组件扫描（component scanning）注册为 Spring bean。@RestControllerAdvice 是一个由 @ControllerAdvice 和 @ResponseBody 注解的组合注解，本质上意味着，@ExceptionHandler 方法是通过消息转换（以及视图解析或者模板解析）渲染到响应体的。
在启动时，用于 @RequestMapping 和 @ExceptionHandler 方法的基础设施类会检测注解有 @ControllerAdvice 的 Spring bean，然后在运行时应用它们的方法。 全局的 @ExceptionHandler 方法（来自 @ControllerAdvice）应用于本地方法之后（来自 @Controller）。相比之下，全局的 @ModelAttribute 和 @InitBinder 方法应用于本地方法之前。
默认地，ControllerAdvice 方法应用于每个请求（即，所有控制器），但是你可以通过注解上的属性，将其缩小到控制器的子集，如以下示例所示：
// Target all Controllers annotated with @RestController@ControllerAdvice(annotations = RestController.class)public class ExampleAdvice1 &#123;&#125;// Target all Controllers within specific packages@ControllerAdvice(&quot;org.example.controllers&quot;)public class ExampleAdvice2 &#123;&#125;// Target all Controllers assignable to specific classes@ControllerAdvice(assignableTypes = &#123;ControllerInterface.class, AbstractController.class&#125;)public class ExampleAdvice3 &#123;&#125;


全局异常处理 @RestControllerAdvice
@RestControllerAdvicepublic class GlobalExceptionHandler &#123;	@ExceptionHandler(value = AuthenticationException.class)	public ResponseDTO AuthenticationExceptionHandler(AuthenticationException e) &#123;		return ResponseDTO.failure(e.getMessage());		&#125;&#125;

*** ControllerAdvice 处理 Filter 抛出的异常
类比，Sturts 拦截器组，第一个就是 exception 拦截器。本质上是借助过滤器栈，将异常处理的过滤器放在第一个位置。
定义 ExceptionFilter，将捕捉的异常交给异常处理的 Controller。其他的过滤器不用处理异常，直接 throw 即可。请务必调用 setOrder 方法，保持 order 值最大，这样过滤就能排在第一个。
@Component@Order(Integer.MIN_VALUE)public class ExceptionFilter extends HttpFilter &#123;    @Override    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        try &#123;            chain.doFilter(request, response);        &#125; catch (IOException e) &#123;            request.setAttribute(&quot;ioException&quot;, e);            request.getRequestDispatcher(&quot;/error&quot;).forward(request, response);        &#125; catch (ServletException e) &#123;            request.setAttribute(&quot;servletException&quot;, e);            request.getRequestDispatcher(&quot;/error&quot;).forward(request, response);        &#125;    &#125;&#125;

定义抛出异常的 Mapping
@PostMapping(&quot;/error&quot;)public ResponseVO throwException(HttpServletRequest request) throws Exception &#123;    throw (Exception) request.getAttribute(&quot;exception&quot;);&#125;


1.4. Functional Endpoints1.4.1. Overview在 WebMvc.fn 中，使用 HandlerFunction 处理 HTTP 请求：这是一个接受 ServerRequest 并返回 ServerResponse 的函数。请求和响应都有固定的约定，提供了 JDK8 友好的 HTTP 请求和响应访问。HandlerFunction 等价于基于注解的编程模型中的 @RequestMapping 方法体。
传入的请求会使用 RouterFunction 路由到一个 handler function：这是一个接收 ServerRequest 并返回 一个 Optional 包裹的 HandlerFunction（Optional&lt;HandlerFunction&gt;） 的函数。当路由器函数匹配到时，就会返回一个 handler function；否则是一个空的 Optional。RouterFunction 等价于 @RequestMapping 注解，但有一个主要的区别，路由函数不仅仅提供数据，还提供行为。
RouterFunctions.route() 提供了一个路由器构建器，可以比较容易地创建路由器，如以下示例所示：
import static org.springframework.http.MediaType.APPLICATION_JSON;import static org.springframework.web.servlet.function.RequestPredicates.*;import static org.springframework.web.servlet.function.RouterFunctions.route;PersonRepository repository = ...PersonHandler handler = new PersonHandler(repository);RouterFunction&lt;ServerResponse&gt; route = route()    .GET(&quot;/person/&#123;id&#125;&quot;, accept(APPLICATION_JSON), handler::getPerson)    .GET(&quot;/person&quot;, accept(APPLICATION_JSON), handler::listPeople)    .POST(&quot;/person&quot;, handler::createPerson)    .build();public class PersonHandler &#123;    // ...    public ServerResponse listPeople(ServerRequest request) &#123;        // ...    &#125;    public ServerResponse createPerson(ServerRequest request) &#123;        // ...    &#125;    public ServerResponse getPerson(ServerRequest request) &#123;        // ...    &#125;&#125;


作者的话 上述代码不符合 Java 语法规范，只是作为一种示例参考，具体注入路由器需要使用 bean 注入

如果将 RouterFunction 注册为 bean，例如在 @Configuration 类中暴露它，它会被 servlet 自动检测，如 Running a Server 所述。
1.4.2. HandlerFunctionServerRequest 和 ServerResponse 是不可变接口，可提供 JDK8 友好访问 HTTP 请求和响应，包括 headers，body，method，status code。
ServerRequestServerRequest 提供了对 HTTP method，URI，Headers，Query Parameters，而通过 body 方法访问 Body。
以下示例将请求体提取为一个 String：
String string = request.body(String.class);


以下示例将 Body 提取为一个 List&lt;Person&gt;，其中 Person 对象是从 JSON 或者 XML 此类的序列化形式解吗得到的：
List&lt;Person&gt; people = request.body(new ParameterizedTypeReference&lt;List&lt;Person&gt;&gt;() &#123;&#125;);

以下示例展示了如何访问参数：
MultiValueMap&lt;String, String&gt; params = request.params();

ServerResponseServerResponse 提供了对 HTTP response 的访问，并且由于它是不变的，因此你可以使用一个 build 方法来创建它。你可以通过构建器设置响应状态，添加响应头，或者提供响应体。以下示例创建了一个具有 JSON 内容的 200（OK）响应：
Person person = ...ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person);

以下示例展示了如何使用 Location 头以及无响应体构建一个 201（CREATED）响应：
URI location = ...ServerResponse.created(location).build();

Handler Classes我可以用 lambda 方式书写一个 handler 函数，如以下示例所示：
HandlerFunction&lt;ServerResponse&gt; helloWorld =  request -&gt; ServerResponse.ok().body(&quot;Hello World&quot;);

这很方便，但是在应用程序中我们需要多个函数，并且多个内联的 lambda 可能变得混乱。因此 ，将相关的 handler 函数一起分组到一个 handler 类是很有用的，这与基于注解的应用中，具有跟 @Controller 相似的角色。举个例子，下面的类暴露了响应式 Person 仓库：
import static org.springframework.http.MediaType.APPLICATION_JSON;import static org.springframework.web.reactive.function.server.ServerResponse.ok;public class PersonHandler &#123;    private final PersonRepository repository;    public PersonHandler(PersonRepository repository) &#123;        this.repository = repository;    &#125;    public ServerResponse listPeople(ServerRequest request) &#123;         List&lt;Person&gt; people = repository.allPeople();        return ok().contentType(APPLICATION_JSON).body(people);    &#125;    public ServerResponse createPerson(ServerRequest request) throws Exception &#123;         Person person = request.body(Person.class);        repository.savePerson(person);        return ok().build();    &#125;    public ServerResponse getPerson(ServerRequest request) &#123;         int personId = Integer.parseInt(request.pathVariable(&quot;id&quot;));        Person person = repository.getPerson(personId);        if (person != null) &#123;            return ok().contentType(APPLICATION_JSON).body(person);        &#125;        else &#123;            return ServerResponse.notFound().build();        &#125;    &#125;&#125;

1.4.3. RouterFunction路由器函数用于将请求路由到相关的 HandlerFunction。通常你不用自己编写路由器函数，而是使用 RouterFunctions 工具类上的一个方法创建它。RouterFunctions.route() （无参）为你提供了一个流利的构建器用于创建路由器函数，而 RouterFunctions.route(RequestPredicate, HandlerFunction) 提供了一个直接创建路由器的方法。
1.4.4. Running a Server通常，你可以通过 MVC Config 在基于 DispatcherHandler 的设置中运行路由函数，这种设置使用 Spring Configuration 声明处理请求所需的组件。MVC Java 配置声明了以下的一些基础设施组件用以支持功能性端点：

RouterFunctionMapping
HandlerFunctionAdapter

前面的组件使功能性端点兼容到 DispatcherServlet 请求处理生命周期里，并且（可能）与注解控制器并行，如果有任何声明。这也是 Spring Boot Web starter 启用功能性端点的方式。
以下示例展示了 WebFlux Java 配置：
@Configuration@EnableMvcpublic class WebConfig implements WebMvcConfigurer &#123;    @Bean    public RouterFunction&lt;?&gt; routerFunctionA() &#123;        // ...    &#125;    @Bean    public RouterFunction&lt;?&gt; routerFunctionB() &#123;        // ...    &#125;    // ...    @Override    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;        // configure message conversion...    &#125;    @Override    public void addCorsMappings(CorsRegistry registry) &#123;        // configure CORS...    &#125;    @Override    public void configureViewResolvers(ViewResolverRegistry registry) &#123;        // configure view resolution for HTML rendering...    &#125;&#125;

1.4.5. Filtering Handler Functions你可以在路由函数构建器使用 before，after 或者 filter 方法来过滤 handler 函数。使用注解，你可以通过使用 @ControllerAdvice，ServletFilter 或者两者都用，实现类似的功能。过滤将会应用到构建器构建的路由中。这意味着在嵌套路由中定义的过滤其不适用于顶级路由。例如，考虑如下示例：
RouterFunction&lt;ServerResponse&gt; route = route()    .path(&quot;/person&quot;, b1 -&gt; b1        .nest(accept(APPLICATION_JSON), b2 -&gt; b2            .GET(&quot;/&#123;id&#125;&quot;, handler::getPerson)            .GET(&quot;&quot;, handler::listPeople)            .before(request -&gt; ServerRequest.from(request)                 .header(&quot;X-RequestHeader&quot;, &quot;Value&quot;)                .build()))        .POST(&quot;/person&quot;, handler::createPerson))    .after((request, response) -&gt; logResponse(response))     .build();

1.5. URI Links1.5.1. UriComponentsUriComponentBuilder 有助于从带有变量的 URI 模板中构建 URI。如下示例所示：
UriComponents uriComponents = UriComponentsBuilder        .fromUriString(&quot;https://example.com/hotels/&#123;hotel&#125;&quot;)          .queryParam(&quot;q&quot;, &quot;&#123;q&#125;&quot;)          .encode()         .build(); URI uri = uriComponents.expand(&quot;Westin&quot;, &quot;123&quot;).toUri();  


前面的示例可以合并到一个链中，并使用 buildAndExpand 缩短，如下示例所示：

URI uri = UriComponentsBuilder        .fromUriString(&quot;https://example.com/hotels/&#123;hotel&#125;&quot;)        .queryParam(&quot;q&quot;, &quot;&#123;q&#125;&quot;)        .encode()        .buildAndExpand(&quot;Westin&quot;, &quot;123&quot;)        .toUri();

你可以直接进入 URI（表示编码）进一步缩短，如下示例所示：
URI uri = UriComponentsBuilder        .fromUriString(&quot;https://example.com/hotels/&#123;hotel&#125;&quot;)        .queryParam(&quot;q&quot;, &quot;&#123;q&#125;&quot;)        .build(&quot;Westin&quot;, &quot;123&quot;);
你可以使用完整的 URI 模板进一步缩短，如下示例所示：
URI uri = UriComponentsBuilder        .fromUriString(&quot;https://example.com/hotels/&#123;hotel&#125;?q=&#123;q&#125;&quot;)        .build(&quot;Westin&quot;, &quot;123&quot;);

1.5.2. UriBuilder1.6. Asynchronous RequestsSpring MVC 集成了 Servlet 3.0 异步请求处理：

在控制器方法中，DeferredResult 和 Callable 返回值，并为单个异步返回值提供了基本支持。
控制器可以流传输多个值，包括 SSE 和 原始数据
控制器可以使用 reactive 客户端，并为响应处理返回 reactive types

1.6.1. DeferredResult一旦在 Servlet 容器中启用了异步处理功能，控制器方法就可以用 DeferredResult 包装任何支持的控制器方法的返回值，如下示例所示：
@GetMapping(&quot;/quotes&quot;)@ResponseBodypublic DeferredResult&lt;String&gt; quotes() &#123;    DeferredResult&lt;String&gt; deferredResult = new DeferredResult&lt;String&gt;();    // Save the deferredResult somewhere..    return deferredResult;&#125;// From some other thread...deferredResult.setResult(result);


1.6.3. Processing这是 Servlet 异步请求处理非常简洁的概述：

通过调用 request.startAsync()，ServletRequest 可以放到异步模型中。这样做的主要影响就是，Servlet（以及任何过滤器）可以退出，但是响应会一直打开用于后面处理完成。

调用 request.startAsync() 会返回 AsyncContext，你可以用它来对异步处理做进一步控制。例如，它提供了 dispatch 方法，该方法类似于 Servlet API 的 forward，除了它可以让应用程序在 Servlet 容器线程上恢复请求处理。

ServletRequest 提供了对当前 DispatcherType 的访问，你可以用它区别处理初始化请求，异步调度，forward，以及其他调度类型。


DeferredResult 处理工作如下：

控制器返回一个 DeferredResult，并将其保存到一些内存中的可访问的队列或者列表中。

Spring MVC 调用 request.startAsync()

同时，DispatcherServlet 以及所有配置的过滤器都退出请求处理线程，但 response 仍然保持打开

应用程序从某个线程设置 DeferredResult，然后 Spring MVC 将请求调度回 Servlet 容器。

再次调用 DispatcherServlet，并以异步产生的返回值进行处理。


1.7. CORS参考链接：
https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS
1.7.1. Introduction出于安全原因，浏览器禁止 AJAX 调用当前源之外的资源。举个例子，你可以将你的银行账户放在一个标签中，而 evil.com 在另一个标签中。来自 evil.com 的脚本不应通过你的凭据向你的银行 API 发出 AJAX 请求，例如从你的账户提取资金。
跨域资源共享是 W3C 的规范，大多数浏览器都实现了这种规范，可以让你指定哪种类型的跨域请求已获得授权，而不是使用基于 IFRAME 或者 JSONP 的不太安全且不太强大的解决方案。
1.7.2. ProcessingCORS 规范区分预请求、简单请求、实际请求。想要学习更多 CORS，参考这篇文章
Spring MVC HandlerMapping 实现类提供了内置的对 CORS 的支持。在成功将请求映射到一个 handler 之后，HandlerMapping 实现类就会检查给定请求以及 handler 的 CORS 配置，然后采取更进一步的措施。预请求直接处理，但是，简单请求和实际的 CORS 请求会被拦截，校验，并设置需要的 CORS 响应头。
为了启用跨域请求，你需要有一个显式的 CORS 配置。如果找不到合适的 CORS 配置，就会拒绝预请求。如果没有添加 CORS 头部到简单请求、实际 CORS 请求响应中，那么，浏览器就会拒绝它们。

作者的话 可能有人会认为跨域是浏览器无法发起请求，其实不是，只是拒绝接收 response。

每个 HandlerMapping 都可以单独地配置基于模式的 URL CorsConfiguration 映射。在大多数情况下，应用使用 MVC Java 配置或者 XML 命名空间去声明映射，不过这会导致一个传递给所有 HandlerMapping 实例的全局映射。
你可以将位于 HandlerMapping 级别的全局 CORS 配置与更加细粒度的 handler 级别的 CORS 配置相结合。举个例子，注解式 Controller 可以使用类级别或者方法级别的 @CrossOrigin 注解（其他 handler 可以实现 CorsConfigurationSource）
1.7.3. @CrossOrigin@CrossOrigin 注解在注解式控制器的方法上，可以启用跨域请求，如下示例所示：
@RestController@RequestMapping(&quot;/account&quot;)public class AccountController &#123;    @CrossOrigin    @GetMapping(&quot;/&#123;id&#125;&quot;)    public Account retrieve(@PathVariable Long id) &#123;        // ...    &#125;    @DeleteMapping(&quot;/&#123;id&#125;&quot;)    public void remove(@PathVariable Long id) &#123;        // ...    &#125;&#125;

默认地，@CrossOrigin 允许：

所有 origin
所有 header
所有 HTTP 方法

默认情况下，allowedCredentials 不启用，因为那会建立一个信任级别，会暴露敏感的用户特定的信息（例如 cookie 和 CSRF 令牌），应该只能在适当的情况下使用。
@CrossOrigin 可以用于：

Controller 的方法，开启 Controller 方法级别的跨域请求
Controller 类，由所有方法继承

maxAge 默认 30 分钟
@CrossOrigin 也支持类级别，这会被所有方法继承，如下示例所示：
@CrossOrigin(origins = &quot;https://domain2.com&quot;, maxAge = 3600)@RestController@RequestMapping(&quot;/account&quot;)public class AccountController &#123;    @GetMapping(&quot;/&#123;id&#125;&quot;)    public Account retrieve(@PathVariable Long id) &#123;        // ...    &#125;    @DeleteMapping(&quot;/&#123;id&#125;&quot;)    public void remove(@PathVariable Long id) &#123;        // ...    &#125;&#125;

你可以在类级别和方法级别上同时使用 @CrossOrigin，如下示例所示：
@CrossOrigin(maxAge = 3600)@RestController@RequestMapping(&quot;/account&quot;)public class AccountController &#123;    @CrossOrigin(&quot;https://domain2.com&quot;)    @GetMapping(&quot;/&#123;id&#125;&quot;)    public Account retrieve(@PathVariable Long id) &#123;        // ...    &#125;    @DeleteMapping(&quot;/&#123;id&#125;&quot;)    public void remove(@PathVariable Long id) &#123;        // ...    &#125;&#125;


1.7.4. Global Configuration除了细粒度的控制外，也可以通过实现 WebMvcConfigurer.addCorsMappings 定义全局 CORS 配置，参考代码见官网。
具体原理可见 DefaultCorsProcessor。
1.7.5. CORS Filter可以通过内置的 CorsFilter 增加 CORS 支持。
1.8. Web SecuritySpring Security 工程为保护 web 应用免受恶意漏洞提供了支持。清参阅 Spring Security 参考文档，包括：

Spring MVC Security
Spring MVC Test Support
CSRF protection
Security Response Headers

1.9. HTTP Caching1.10. View Technologies在 Spring MVC 中使用视图技术是可拔插的，无论你决定使用 Thymeleaf，Groovy Markup Templates，JSP，或者其他技术，主要都是配置更改的问题。本章覆盖了与 Spring MVC 集成的视图技术。我们假设你已经熟悉 View Resolution。
1.10.1. ThymeleafThymeleaf 是一个现代的服务端 Java 模板引擎，强调可以通过双击在浏览器中预览的天然 HTML 模板，这对于独立工作于 UI 模板（例如，通过设计师）非常有帮助，无需运行在服务器。如果你想替换 JSP，则 Thymeleaf 提供了最广泛的功能集之一，以使这种过渡更加容易。Thymeleaf 开发和维护都比较活跃。有关更完整的介绍，请参见 Thymeleaf 项目主页。
Thymeleaf 与 Spring MVC 集成由 Thymeleaf 项目管理。配置涉及了一些 Bean 声明，例如 ServletContextTemplateResolver，SpringTemplateEngine，以及 ThymeleafViewResolver。有关更多项目信息，请参见 Thymeleaf+Spring。
1.11. MVC ConfigMVC Java 配置和 MVC XML 命名空间配置提供了默认的配置，这适合大多数应用程序，如果你觉得不够，也提供了配置 API 供你自定义。
1.11.1. Enable MVC Configuration在 Java 配置中，你可以使用 @EnableMvc 注解来启用 MVC 配置，如下示例所示：
@Configuration@EnableWebMvcpublic class WebConfig &#123;&#125;


作者的话 Spring Boot 无需且尽量不要使用 @EnableWebMvc，这会覆盖 Spring Boot 的默认配置。

在 XML 配置中，你可以使用 &lt;mvc:annotation-driven&gt; 元素，以启用 MVC 配置，如下示例所示：
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;mvc:annotation-driven/&gt;&lt;/beans&gt;

上面的示例会注册许多 Spring MVC 的基础 bean，并且适配类路径上的可用依赖（例如，载体转换器，JSON，XML，以及其他什么）
1.11.2. MVC Config API在 Java 配置中，你可以实现 WebMvcConfigurer 示例，如下示例所示：
@Configuration@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123;    // Implement configuration methods...&#125;

在 XML 下，你可以检查属性，以及 &lt;mvc:annotation-driven/&gt; 的子元素。你可以浏览 Spring MVC XML schema 或者使用 IDE 的代码编译功能，找到那些可用的属性以及子元素。
1.11.3. Type Conversion默认地，Spring MVC 安装了各种数字和日期的格式化器（formatter），并且支持 @NumberFormat 和 @DateTimeFormat 对字段进行自定义。
如果要在 Java 配置中注册自定义的格式化器和转换器，使用以下方式：
@Configuration@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123;    @Override    public void addFormatters(FormatterRegistry registry) &#123;        // ...    &#125;&#125;


作者的话 其实就是实现 WebMvcConfigurer 的 addFormatters 方法

1.11.4. Validation默认地，如果 Bean Validation 存在于类路径（例如，Hibernate Validator），就会注册一个 LocalValidatorFactoryBean 作为全局的 Validator，供控制器方法参数上的 @Valid 以及 Validated 使用

 作者的话 判断是否存在 Bean Validation 框架的方法是注解查找是否存在 javax.validation.Validator

在 Java 配置中，你可以自定义全局 Validator 示例，如下示例所示：
@Configuration@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123;    @Override    public Validator getValidator() &#123;        // ...    &#125;&#125;

1.11.5. Interceptors在 Java 配置中，你可以注册拦截器，以应用于收到的请求，如下示例所示：
@Configuration@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        registry.addInterceptor(new LocaleChangeInterceptor());        registry.addInterceptor(new ThemeChangeInterceptor()).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/admin/**&quot;);        registry.addInterceptor(new SecurityInterceptor()).addPathPatterns(&quot;/secure/*&quot;);    &#125;&#125;


1.11.6. Content Types1.11.7. Message Converters你可以通过覆盖 configureMessageConverters()，以 Java 配置的方式自定义 HttpMessageConverter（这会取代 Spring MVC 创建的默认转换器），或者通过覆盖 extendMessageConverters()（这可以自定义默认的转换器或者添加额外的转换器）
以下示例使用自定义的 ObjectMapper 添加了 XML 和 Jackson JSON 转换器，取代默认的转换器：
@Configuration@EnableWebMvcpublic class WebConfiguration implements WebMvcConfigurer &#123;    @Override    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;        Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder()                .indentOutput(true)                .dateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;))                .modulesToInstall(new ParameterNamesModule());        converters.add(new MappingJackson2HttpMessageConverter(builder.build()));        converters.add(new MappingJackson2XmlHttpMessageConverter(builder.createXmlMapper(true).build()));    &#125;&#125;


1.11.10. Static Resources这里提供了一种简便的方法用于提供静态资源服务，是基于 Resource 的位置列表的。
在以下示例中，给定一个以 /resources 开头的请求，相对路径用于查找和提供位于 web 应用的根目录下的 /public 或者类路径 /static 下的静态资源
如果需要以 &#x2F;resources 为前缀，根据其后的相对路径寻找 Web 应用程序根目录下的 &#x2F;public 资源或 类路径 &#x2F;static 下的静态资源，资源设置一年到期，还会评估 Last-Modified 头部，如果存在，返回 304，则可以按如下配置：
@Configuration@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123;    @Override    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;        registry.addResourceHandler(&quot;/resources/**&quot;)            .addResourceLocations(&quot;/public&quot;, &quot;classpath:/static/&quot;)            .setCachePeriod(31556926);    &#125;&#125;

注意(1) 配置类路径静态资源时，末尾必须有 &#x2F;，不可缺省，否则 404
1.11.11. Default ServletSpring MVC 允许将 DispatcherServlet 映射到 /（因此，这覆盖了容器默认的 Servlet 映射），但是，Spring MVC 仍然允许容器默认的 Servlet 处理静态资源请求。Spring MVC 配置有一个 DefaultServletHttpRequestHandler，使用 /** 的 URL 映射，相对于其他 URL 映射的具有最低优先级（Integer.MAX_VALUE）。

作者的话 在 Spring Boot 中，你不启用，是不会将此 HandlerMapping 添加的。并且，启用了也不会发生作用，因为请求会被 SimpleUrlHandlerMapping 中的 /** 匹配到。

该 handler 将所有请求转发到默认的 Servlet。因此，它必须保持在所有其他 URL HandlerMapping 的最后。如果你使用 mvc:annotation-driven，就是这种情况。另外，如果你设置了自定义的 HandlerMapping 实例，请确保将其 order 属性设置低于 DefaultServletHttpRequestHandler（Integer.MAX_VALUE）
如下示例显示了如何通过使用默认设置启用该功能：
@Configuration@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123;    @Override    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;        configurer.enable();    &#125;&#125;


1.11.12. Path Matching你可以自定义与 URL 的路径匹配和处理有关的可选项。有关各个选项的详细信息，参见 PathMatchConfigurer javadoc。
以下示例显示了如何在 Java 配置中自定义路径匹配：
@Configuration@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123;    @Override    public void configurePathMatch(PathMatchConfigurer configurer) &#123;        configurer            .setUseTrailingSlashMatch(false)            .setUseRegisteredSuffixPatternMatch(true)            .setPathMatcher(antPathMatcher())            .setUrlPathHelper(urlPathHelper())            .addPathPrefix(&quot;/api&quot;, HandlerTypePredicate.forAnnotation(RestController.class));    &#125;    @Bean    public UrlPathHelper urlPathHelper() &#123;        //...    &#125;    @Bean    public PathMatcher antPathMatcher() &#123;        //...    &#125;&#125;


]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Web MVC HandlerMapping 笔记</title>
    <url>/2022/07/22/Framework/Java/Spring-Framework/Spring-Web-MVC-HandlerMapping-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[Spring Web MVC HandlerMapping 笔记HandlerMapping1. 介绍HandlerMapping 用于将请求映射到 handler，以及前置处理拦截器和后置处理拦截器。该映射基于某些规则，其中的细节随着 HandlerMapping 的实现有所不同。
两个主要的 HandlerMapping 的实现类：
(1) RequestMappingHandlerMapping ，它支持 @RequestMapping 注解的方法
(2) SimpleUrlHandlerMapping，它维护 URI 路径模式到 handler 的指定注册

参考官方文档 1.1.2. Special Bean Types

2. Spring Boot默认情况下，Spring Boot 提供 5 个默认的 HandlerMapping，他们分别是：

RequestMappingHandlerMapping
BeanNameUrlHandlerMapping
RouterFunctionMapping
SimpleUrlHandlerMapping
WelcomePageHandlerMapping

上述这几个 HandlerMapping 都是在 WebMvcAutoConfiguration 内部类 EnableWebMvcConfiguration 中配置的。
为了能够通过类名立即能知道该类实现了 HandlerMapping 接口，这些实现类都以 HandlerMapping 为结尾，以前缀标识其作用。

通常 SimpleUrlHandlerMapping 会返回 ResourceHttpRequestHandler；RequestMappingHandlerMapping 返回 HandlerMethod

如何找到当前请求使用哪个 HandlerMapping 处理？
protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;	if (this.handlerMappings != null) &#123;		for (HandlerMapping mapping : this.handlerMappings) &#123;			HandlerExecutionChain handler = mapping.getHandler(request);            // 通过返回值是否为 null 确定			if (handler != null) &#123;				return handler;			&#125;		&#125;	&#125;	return null;&#125;

AbstractHandlerMappingAbstractHandlerMapping 是所有 HandlerMapping 的父类，以下是所有请求获取 handler 的统一入口。
public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;	// getHandlerInternal 是抽象方法，留给子类实现		Object handler = getHandlerInternal(request);	// 如果子类无法找到 handler 则使用默认 handler	if (handler == null) &#123;		handler = getDefaultHandler();	&#125;	// 如果没有默认 handler，则返回 null	if (handler == null) &#123;		return null;	&#125;	// Bean name or resolved handler?	if (handler instanceof String) &#123;		String handlerName = (String) handler;		handler = obtainApplicationContext().getBean(handlerName);	&#125;	HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);	if (CorsUtils.isCorsRequest(request)) &#123;		CorsConfiguration globalConfig = this.globalCorsConfigSource.getCorsConfiguration(request);		CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);		CorsConfiguration config = (globalConfig != null ? globalConfig.combine(handlerConfig) : handlerConfig);		executionChain = getCorsHandlerExecutionChain(request, executionChain, config);	&#125;	return executionChain;&#125;

getHandlerInternal 是抽象方法，由子类实现，因此官方才会有这样一句话：

The mapping is based on some criteria, the details of which vary by HandlerMapping implementation.

RequestMappingHandlerMappingRequestMappingHandlerMapping 是 RequestMappingInfoHandlerMapping 的子类。RequestMappingInfoHandlerMapping 实现了 getHandlerInternal：
protected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception &#123;	request.removeAttribute(PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);	try &#123;		return super.getHandlerInternal(request);	&#125;	finally &#123;		ProducesRequestCondition.clearMediaTypesAttribute(request);	&#125;&#125;
RequestMappingInfoHandlerMapping 并没有做什么具体的操作，他只是调用父类 AbstractHandlerMethodMapping 的 getHandlerInternal 方法：
protected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception &#123;	String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);	request.setAttribute(LOOKUP_PATH, lookupPath);	this.mappingRegistry.acquireReadLock();	try &#123;		HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);		return (handlerMethod != null ? handlerMethod.createWithResolvedBean() : null);	&#125;	finally &#123;		this.mappingRegistry.releaseReadLock();	&#125;&#125;

上述代码比较重要的是 lookupHandlerMethod 方法调用，它负责寻找 handler 方法：
protected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception &#123;	List&lt;Match&gt; matches = new ArrayList&lt;&gt;();	// 先通过 url 找到匹配项	List&lt;T&gt; directPathMatches = this.mappingRegistry.getMappingsByUrl(lookupPath);	// 接着添加匹配的映射（根据具体条件，如 HTTP Method 等）	if (directPathMatches != null) &#123;		addMatchingMappings(directPathMatches, matches, request);	&#125;	if (matches.isEmpty()) &#123;		// No choice but to go through all mappings...		addMatchingMappings(this.mappingRegistry.getMappings().keySet(), matches, request);	&#125;	if (!matches.isEmpty()) &#123;		Match bestMatch = matches.get(0);		// 如果匹配项不止 1 个		if (matches.size() &gt; 1) &#123;				Comparator&lt;Match&gt; comparator = new MatchComparator(getMappingComparator(request));			// 排序，取出第 0 个			matches.sort(comparator);			bestMatch = matches.get(0);			if (logger.isTraceEnabled()) &#123;				logger.trace(matches.size() + &quot; matching mappings: &quot; + matches);			&#125;			if (CorsUtils.isPreFlightRequest(request)) &#123;				return PREFLIGHT_AMBIGUOUS_MATCH;			&#125;			Match secondBestMatch = matches.get(1);			if (comparator.compare(bestMatch, secondBestMatch) == 0) &#123;				Method m1 = bestMatch.handlerMethod.getMethod();				Method m2 = secondBestMatch.handlerMethod.getMethod();				String uri = request.getRequestURI();				// 无法决定最佳匹配，抛异常！！！				throw new IllegalStateException(						&quot;Ambiguous handler methods mapped for &#x27;&quot; + uri + &quot;&#x27;: &#123;&quot; + m1 + &quot;, &quot; + m2 + &quot;&#125;&quot;);			&#125;		&#125;		// 设置一些属性等		request.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.handlerMethod);		handleMatch(bestMatch.mapping, lookupPath, request);		return bestMatch.handlerMethod;	&#125;	else &#123;		return handleNoMatch(this.mappingRegistry.getMappings().keySet(), lookupPath, request);	&#125;&#125;

上述代码具体做的就是找到一个最佳匹配 handlerMethod 并返回，如果有两个并列的最佳匹配 handlerMethod，则抛出异常，Spring 无法决定选择哪个，因此，建议不要定义具有歧义的 handler。
RouterFunctionMapping用于功能性端点的映射，可以阅读官网
SimpleUrlHandlerMapping尽管类名称叫 SimpleUrlHandlerMapping，但是其 beanName 为 resourceHandlerMapping
SimpleUrlHandlerMapping 是 AbstractUrlHandlerMapping 的子类，所有请求直接经过其父类 getHandlerInternal 方法：
protected Object getHandlerInternal(HttpServletRequest request) throws Exception &#123;	// 获得需要寻找的路径	String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);	request.setAttribute(LOOKUP_PATH, lookupPath);	// 寻找 handler	Object handler = lookupHandler(lookupPath, request);	if (handler == null) &#123;		// We need to care for the default handler directly, since we need to		// expose the PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE for it as well.		Object rawHandler = null;		if (&quot;/&quot;.equals(lookupPath)) &#123;			rawHandler = getRootHandler();		&#125;		if (rawHandler == null) &#123;			rawHandler = getDefaultHandler();		&#125;		if (rawHandler != null) &#123;			// Bean name or resolved handler?			if (rawHandler instanceof String) &#123;				String handlerName = (String) rawHandler;				rawHandler = obtainApplicationContext().getBean(handlerName);			&#125;			validateHandler(rawHandler, request);			handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, null);		&#125;	&#125;	return handler;&#125;

protected Object lookupHandler(String urlPath, HttpServletRequest request) throws Exception &#123;	// 通过 map 直接匹配，可以自行通过 WebMvcConfigurer 注册更多项	// 一般匹配不到，因为我们几乎都是通过 ** 等通配符配置	Object handler = this.handlerMap.get(urlPath);  // 1		if (handler != null) &#123;		// Bean name or resolved handler?		// 如果匹配到...		if (handler instanceof String) &#123;			String handlerName = (String) handler;			handler = obtainApplicationContext().getBean(handlerName);		&#125;		validateHandler(handler, request);		return buildPathExposingHandler(handler, urlPath, urlPath, null);	&#125;	// Pattern match?	// 没有直接匹配到，进行模式匹配	List&lt;String&gt; matchingPatterns = new ArrayList&lt;&gt;();	for (String registeredPattern : this.handlerMap.keySet()) &#123;		if (getPathMatcher().match(registeredPattern, urlPath)) &#123;			matchingPatterns.add(registeredPattern);		&#125;		else if (useTrailingSlashMatch()) &#123;			if (!registeredPattern.endsWith(&quot;/&quot;) &amp;&amp; getPathMatcher().match(registeredPattern + &quot;/&quot;, urlPath)) &#123;				matchingPatterns.add(registeredPattern + &quot;/&quot;);			&#125;		&#125;	&#125;	String bestMatch = null;	Comparator&lt;String&gt; patternComparator = getPathMatcher().getPatternComparator(urlPath);	if (!matchingPatterns.isEmpty()) &#123;		// 排序		matchingPatterns.sort(patternComparator);		if (logger.isTraceEnabled() &amp;&amp; matchingPatterns.size() &gt; 1) &#123;			logger.trace(&quot;Matching patterns &quot; + matchingPatterns);		&#125;		// 认为第一个是最好的匹配		bestMatch = matchingPatterns.get(0);	&#125;	if (bestMatch != null) &#123;		handler = this.handlerMap.get(bestMatch);		if (handler == null) &#123;			// 匹配不到。这里是为了处理上面 useTrailingSlashMatch 的问题			// 去除末尾斜杠			if (bestMatch.endsWith(&quot;/&quot;)) &#123;				handler = this.handlerMap.get(bestMatch.substring(0, bestMatch.length() - 1));			&#125;			if (handler == null) &#123;				throw new IllegalStateException(&quot;Could not find handler for best pattern match [&quot; + bestMatch + &quot;]&quot;);			&#125;		&#125;		// Bean name or resolved handler?		if (handler instanceof String) &#123;			String handlerName = (String) handler;			handler = obtainApplicationContext().getBean(handlerName);		&#125;		validateHandler(handler, request);		String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestMatch, urlPath);		// There might be multiple &#x27;best patterns&#x27;, let&#x27;s make sure we have the correct URI template variables		// for all of them		// 可能有多个最佳匹配，我们需要确定对于每个都有正确的 uri 模板变量		Map&lt;String, String&gt; uriTemplateVariables = new LinkedHashMap&lt;&gt;();		for (String matchingPattern : matchingPatterns) &#123;			// 这里可能出现并列最佳匹配			if (patternComparator.compare(bestMatch, matchingPattern) == 0) &#123;				Map&lt;String, String&gt; vars = getPathMatcher().extractUriTemplateVariables(matchingPattern, urlPath);				Map&lt;String, String&gt; decodedVars = getUrlPathHelper().decodePathVariables(request, vars);				uriTemplateVariables.putAll(decodedVars);			&#125;		&#125;		if (logger.isTraceEnabled() &amp;&amp; uriTemplateVariables.size() &gt; 0) &#123;			logger.trace(&quot;URI variables &quot; + uriTemplateVariables);		&#125;		return buildPathExposingHandler(handler, bestMatch, pathWithinMapping, uriTemplateVariables);	&#125;	// No handler found...	return null;&#125;

useTrailingSlashMatch
在以上代码的模式匹配部分，使用了 useTrailingSlashMatch() 方法判断是否使用尾部斜杠匹配。如果启用了，那么例如 /users 这样的 URL 模式匹配也可以匹配到 /users。默认是 false。
如果需要启用该选项，目前我能想到的方法是：在某一个 @Configuration 配置类中绑定字段类型 HandlerMapping，使用构造器后置处理修改其属性。
@Configuration@AutoConfigureAfter(WebMvcAutoConfiguration.class)public class HandlerMappingConfig &#123;    @Resource(name = &quot;resourceHandlerMapping&quot;)    HandlerMapping handlerMapping;        @PostConstruct    public void setSimpleUrlHandlerMapping() &#123;        ((SimpleUrlHandlerMapping) handlerMapping).setUseTrailingSlashMatch(true);    &#125;&#125;

由于 SimpleUrlHandlerMapping 是在 WebMvcAutoConfiguration 注入到容器中的，因此需要使用 @AutoConfigureAfter 确保自动配置的顺序，防止找到 bean。
由于 SimpleUrlHandlerMapping 是以 HandlerMapping 类型注入到容器中的，因此无法使用基于类型绑定的 @Autowired，只能使用 @Resource 根据 bean name 进行绑定。
]]></content>
  </entry>
  <entry>
    <title>Spring Web MVC ViewResolver 笔记</title>
    <url>/2022/07/23/Framework/Java/Spring-Framework/Spring-Web-MVC-ViewResolver-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[Spring Web MVC ViewResolver 笔记默认情况下，Spring Boot 会注入以下几个 ViewResolver：

ContentNegotiatingViewResolver
BeanNameViewResolver
ViewResolverComposite
InternalResourceViewResolver

]]></content>
  </entry>
  <entry>
    <title>Spring 循环依赖</title>
    <url>/2022/07/10/Framework/Java/Spring-Framework/Spring-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[Spring 循环依赖三级缓存singletonObjectsearlySingletonObjectssingletonFactories
对于 earlySingletonObjects 的使用场景存在于多循环依赖，比如 beanA 依赖于 beanB 和 beanC，beanB 和 beanC 分别依赖 beanA。在 beanB 进行属性注入 beanA 的时候，beanA 已经从 singletonFactories 构造出一个 earlySingletonObject 了，因此在 beanC 注入 beanA 的时候不必重复构造 beanA，只需从 earlySingletonObjects 中取得即可.
A-&gt;B-&gt;AA-&gt;C-&gt;A

场景假设 beanA 依赖 beanB，beanB 依赖 beanA，以这种最朴素的场景为例
入口假设程序以 beanA 开始解析
AbstractApplicationContext.refresh()-&gt; AbstractApplicationContext.finishBeanFactoryInitialization(beanFactory)-&gt; DefaultLisableBeanFactory.preInstantiateSingletons()-&gt; AbstractBeanFactory.getBean(beanA)-&gt; AbstractBeanFactory.doGetBean(beanA)


流程分析
检查 singletonObjects 是否存在 beanA。

Object sharedInstance = getSingleton(beanName);
public Object getSingleton(String beanName) &#123;    // 注意第二个参数为 true    return getSingleton(beanName, true);&#125;
protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;    // 此时 beanA 还没有开始创建，这里一定返回 null    Object singletonObject = this.singletonObjects.get(beanName);    // 由于 beanA 还没有开始创建，因此也不会存在于 singletonsCurrentlyInCreation    if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;        synchronized (this.singletonObjects) &#123;            singletonObject = this.earlySingletonObjects.get(beanName);            if (singletonObject == null &amp;&amp; allowEarlyReference) &#123;                ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);                if (singletonFactory != null) &#123;                    singletonObject = singletonFactory.getObject();                    this.earlySingletonObjects.put(beanName, singletonObject);                    this.singletonFactories.remove(beanName);                &#125;            &#125;        &#125;    &#125;    return singletonObject;&#125;


开始创建 beanA

// 第二个参数是一个类似于 java.util.function.Supplier 的函数式接口// 用于创建 beanAsharedInstance = getSingleton(beanName, () -&gt; &#123;    try &#123;        return createBean(beanName, mbd, args);    &#125;    catch (BeansException ex) &#123;        destroySingleton(beanName);        throw ex;    &#125;&#125;);


public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123;    Assert.notNull(beanName, &quot;Bean name must not be null&quot;);    synchronized (this.singletonObjects) &#123;        Object singletonObject = this.singletonObjects.get(beanName);        if (singletonObject == null) &#123;            if (this.singletonsCurrentlyInDestruction) &#123;                throw new BeanCreationNotAllowedException(beanName,                        &quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot; +                        &quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;);            &#125;            if (logger.isDebugEnabled()) &#123;                logger.debug(&quot;Creating shared instance of singleton bean &#x27;&quot; + beanName + &quot;&#x27;&quot;);            &#125;            // 该方法会将 beanA 添加到 singletonsCurrentlyInCreation            beforeSingletonCreation(beanName);            boolean newSingleton = false;            boolean recordSuppressedExceptions = (this.suppressedExceptions == null);            if (recordSuppressedExceptions) &#123;                this.suppressedExceptions = new LinkedHashSet&lt;&gt;();            &#125;            try &#123;                // 此处调用函数式接口进行 beanA 的创建                singletonObject = singletonFactory.getObject();                newSingleton = true;            &#125;            catch (IllegalStateException ex) &#123;                // Has the singleton object implicitly appeared in the meantime -&gt;                // if yes, proceed with it since the exception indicates that state.                singletonObject = this.singletonObjects.get(beanName);                if (singletonObject == null) &#123;                    throw ex;                &#125;            &#125;            catch (BeanCreationException ex) &#123;                if (recordSuppressedExceptions) &#123;                    for (Exception suppressedException : this.suppressedExceptions) &#123;                        ex.addRelatedCause(suppressedException);                    &#125;                &#125;                throw ex;            &#125;            finally &#123;                if (recordSuppressedExceptions) &#123;                    this.suppressedExceptions = null;                &#125;                afterSingletonCreation(beanName);            &#125;            if (newSingleton) &#123;                addSingleton(beanName, singletonObject);            &#125;        &#125;        return singletonObject;    &#125;&#125;



创建 beanA

通过 getSingleton 传递的函数式接口调用链如下 
AbstractAutowireCapableBeanFactory.createBean()-&gt; AbstractAutowireCapableBeanFactory.doCreateBean(beanName, mbdToUse, args)



添加到 singletonFactories

doCreateBean 方法首先会进行 beanA 的实例化：
instanceWrapper = createBeanInstance(beanName, mbd, args);

然后紧跟着将实例化的 beanA 以函数式接口 Supplier 的形式（实际上是 ObjectFactory）添加到 singletonFactories：
// 这里的参数 bean 是刚刚实例化完毕的 beanAaddSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));



开始填充 beanA 的属性

populateBean(beanName, mbd, instanceWrapper);


在填充过程中会调用一些 InstantiationAwareBeanPostProcessor 进行 postProcessProperties 操作，
如果你使用的是 @Autowired 进行属性绑定，那么 AutowiredAnnotationBeanPostProcessor 会处理关于 beanB 的属性绑定问题。

解析依赖 beanB

AutowiredAnnotationBeanPostProcessor 的注入调用链如下，最终又会回到 beanFactory 的 getBean 方法：
DefaultListableBeanFactory.doResolveDependency()-&gt; DependencyDescriptor.resolveCandidate(&quot;beanB&quot;, BeanB.class, beanFactory)-&gt; beanFactory.getBean(&quot;beanB&quot;)



与步骤 1 相同

beanB 此时还没有创建，因此不会存在于 singletonObjects ，而且也不会存在于 singletonsCurrentlyInCreation

将 beanB 添加到 singletonsCurrentlyInCreation

实例化 beanB，将对象工程添加到 singletonFactories

填充 beanB 属性，相关的 InstantiationAwareBeanPostProcessor 发挥作用。此时，发现 beanB 依赖 beanA，继续调用 beanFactory.getBean(“beanA”)

与步骤 1 类似


由于 beanA 在创建前已经将自己放到 singletonsCurrentlyInCreation 中，而且将自己的对象工厂放到 singletonFactories 中了，因此会调用 singletonFactories 中的对象工厂方法获得一个 beanA，并且 beanA 的对象工厂会从 singletonFactories 移除，同时添加到 earlySingletonObjects

此时这个 beanA 属性还没有填充

这时候 getBean(“beanA”) 返回得到一个还未填充属性的 beanA

回到 beanB 填充属性，将得到的 beanA 填充进自己的属性。接着，beanB 完成了自己的属性填充就可以将对象添加到 singletonObjects 中，并且移除 singletonFactories 和 earlySingletonObjects 相关的对象

回到 beanA 填充属性，将得到的 beanB 填充进自己的属性。接着，beanA 完成了自己的属性填充就可以将对象添加到 singletonObjects 中，并且移除 singletonFactories 和 earlySingletonObjects 相关的对象


应用
自己依赖自己

被依赖的自己会受到增强（cglib），但是属性并不会注入。
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 请求参数处理实践</title>
    <url>/2022/08/17/Framework/Java/Spring-Framework/Spring-%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[场景描述：请求 Content Type 为 application/x-www-form-urlencoded，即参数以键值对形式传递，其中有简单类型，如：数字，字符串，也有 JSON 类型，需要绑定到 Spring 的模型中，完成校验。
参数格式参考如下，为了便于显示，进行了换行: 
lesson_date=2022-08-08&amp;lesson_period_id=1&amp;subject_id=1&amp;grade_id=1&amp;class_id=1&amp;teacher_id=1&amp;student_list=[&#123;&quot;x&quot;:0,&quot;y&quot;:0,&quot;speak_num&quot;:0,&quot;distract_num&quot;:0,&quot;is_special&quot;:0&#125;]


如何支持下划线传参映射到 Model 模型? 装饰器模式 Request
public class MultiParamCaseRequest extends HttpServletRequestWrapper &#123;    private final Map&lt;String, String[]&gt; additionalParams;    public MultiParamCaseRequest(HttpServletRequest request, Map&lt;String, String[]&gt; additionalParams) &#123;        super(request);        this.additionalParams = additionalParams;    &#125;    @Override    public Enumeration&lt;String&gt; getParameterNames() &#123;        final HashSet&lt;String&gt; parameterNames = new HashSet&lt;&gt;();        parameterNames.addAll(getRequest().getParameterMap().keySet());        parameterNames.addAll(additionalParams.keySet());        return Collections.enumeration(parameterNames);    &#125;    @Override    public String getParameter(String name) &#123;        final String parameter = super.getParameter(name);        if (parameter != null) &#123;            return parameter;        &#125;        final String[] parameterValues = additionalParams.get(name);        if (parameterValues != null) &#123;            if (parameterValues.length == 0) &#123;                return &quot;&quot;;            &#125;            return parameterValues[0];        &#125;        return null;    &#125;    @Override    public String[] getParameterValues(String name) &#123;        final String[] parameterValues = super.getParameterValues(name);        if (parameterValues != null) &#123;            return parameterValues;        &#125;        return additionalParams.get(name);    &#125;&#125;

@Componentpublic class ParamNameExtensionFilter extends HttpFilter &#123;    private final Pattern underLinePattern = Pattern.compile(&quot;_(\\w)&quot;);    @Override    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        Map&lt;String, String[]&gt; additionalParams = new HashMap&lt;&gt;();        final Enumeration&lt;String&gt; parameterNames = request.getParameterNames();        final Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();        while (parameterNames.hasMoreElements()) &#123;            final String parameterName = parameterNames.nextElement();            final String camelCaseParameterName = this.underLineToCamel(parameterName);            if (parameterName.equals(camelCaseParameterName)) &#123;                continue;            &#125;            final String[] values = parameterMap.get(parameterName);            additionalParams.put(camelCaseParameterName, values);        &#125;        final MultiParamCaseRequest multiParamCaseRequest = new MultiParamCaseRequest(request, additionalParams);        chain.doFilter(multiParamCaseRequest, response);    &#125;    private String underLineToCamel(final String value) &#123;        final StringBuffer sb = new StringBuffer();        Matcher m = this.underLinePattern.matcher(value);        while (m.find()) &#123;            m.appendReplacement(sb, m.group(1).toUpperCase());        &#125;        m.appendTail(sb);        return sb.toString();    &#125;&#125;

如果 Model 对象包含 Collection，需要定制 DataBinder:
@InitBinderpublic void initBinder(WebDataBinder dataBinder) &#123;    dataBinder.registerCustomEditor(List.class, &quot;studentList&quot;, new PropertyEditorSupport() &#123;        @Override        public void setAsText(String text) throws IllegalArgumentException &#123;            if (StringUtils.isEmpty(text)) &#123;                setValue(Collections.EMPTY_LIST);            &#125; else &#123;                final ObjectMapper objectMapper = new ObjectMapper();                try &#123;                    setValue(objectMapper.readValue(text, new TypeReference&lt;List&lt;EvaluationVO.Student&gt;&gt;() &#123;                    &#125;));                &#125; catch (JsonProcessingException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;        &#125;    &#125;);&#125;]]></content>
  </entry>
  <entry>
    <title>Struts2 StrutsPrepareAndExecuteFilter doFilter 过程</title>
    <url>/2022/11/25/Framework/Java/Struts2/Struts2-StrutsPrepareAndExecuteFilter-doFilter-%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[当访问某个 URL 时，会进入 StrutsPrepareAndExecuteFilter 的 doFilter 方法:
public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123;    HttpServletRequest request = (HttpServletRequest) req;    HttpServletResponse response = (HttpServletResponse) res;    try &#123;        if (excludedPatterns != null &amp;&amp; prepare.isUrlExcluded(request, excludedPatterns)) &#123;            chain.doFilter(request, response);        &#125; else &#123;            prepare.setEncodingAndLocale(request, response);            prepare.createActionContext(request, response);            prepare.assignDispatcherToThread();            request = prepare.wrapRequest(request);            ActionMapping mapping = prepare.findActionMapping(request, response, true);            if (mapping == null) &#123;                boolean handled = execute.executeStaticResourceRequest(request, response);                if (!handled) &#123;                    chain.doFilter(request, response);                &#125;            &#125; else &#123;                execute.executeAction(request, response, mapping);            &#125;        &#125;    &#125; finally &#123;        prepare.cleanupRequest(request);    &#125;&#125;


setEncodingAndLocaleprepare.setEncodingAndLocale(request, response);

该方法只是简单的设置了 encoding 和 locale
createActionContextprepare.createActionContext(request, response)

这是action上下文的创建，ActionContext是一个容器，这个容器主要存储request、session、application、parameters等相关信 息. ActionContext是一个线程的本地变量，这意味着不同的action之间不会共享ActionContext，所以也不用考虑线程安全问 题。
wrapRequestrequest = prepare.wrapRequest(request)

public HttpServletRequest wrapRequest(HttpServletRequest oldRequest) throws ServletException &#123;    HttpServletRequest request = oldRequest;    try &#123;        // Wrap request first, just in case it is multipart/form-data        // parameters might not be accessible through before encoding (ww-1278)        request = dispatcher.wrapRequest(request);        ServletActionContext.setRequest(request);    &#125; catch (IOException e) &#123;        throw new ServletException(&quot;Could not wrap servlet request with MultipartRequestWrapper!&quot;, e);    &#125;    return request;&#125;

public HttpServletRequest wrapRequest(HttpServletRequest request) throws IOException &#123;    // don&#x27;t wrap more than once    if (request instanceof StrutsRequestWrapper) &#123;        return request;    &#125;    String content_type = request.getContentType();    if (content_type != null &amp;&amp; content_type.contains(&quot;multipart/form-data&quot;)) &#123;        MultiPartRequest mpr = getMultiPartRequest();        LocaleProvider provider = getContainer().getInstance(LocaleProvider.class);        request = new MultiPartRequestWrapper(mpr, request, getSaveDir(), provider, disableRequestAttributeValueStackLookup);    &#125; else &#123;        request = new StrutsRequestWrapper(request, disableRequestAttributeValueStackLookup);    &#125;    return request;&#125;

此次包装根据请求内容的类型不同，返回不同的对象，如果为multipart&#x2F;form-data类型，则返回MultiPartRequestWrapper类型的对象，该对象服务于文件上传，否则返回StrutsRequestWrapper类型的对象，MultiPartRequestWrapper是StrutsRequestWrapper的子类，而这两个类都是HttpServletRequest接口的实现。
findActionMappingActionMapping mapping = prepare.findActionMapping(request, response, true)
包装request后，通过ActionMapper的getMapping()方法得到请求的Action，Action的配置信息存储在ActionMapping对象中，如StrutsPrepareAndExecuteFilter的doFilter方法中第16行：ActionMapping mapping &#x3D; prepare.findActionMapping(request, response, true);我们找到prepare对象的findActionMapping方法：
]]></content>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title>Struts2 loadPackage 过程</title>
    <url>/2022/11/25/Framework/Java/Struts2/Struts2-loadPackage-%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[项目启动后解析web.xml文件，会解析到配置的StrutsPrepareAndExecuteFilter的过滤器: 
&lt;filter&gt;    &lt;filter-name&gt;struts2&lt;/filter-name&gt;    &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;


web容器一启动，就会初始化核心过滤器StrutsPrepareAndExecuteFilter，并执行初始化方法，初始化方法如下：
public void init(FilterConfig filterConfig) throws ServletException &#123;    InitOperations init = new InitOperations();    Dispatcher dispatcher = null;    try &#123;        FilterHostConfig config = new FilterHostConfig(filterConfig);        init.initLogging(config);        dispatcher = init.initDispatcher(config);        init.initStaticContentLoader(config, dispatcher);        prepare = new PrepareOperations(dispatcher);        execute = new ExecuteOperations(dispatcher);        this.excludedPatterns = init.buildExcludedPatternsList(dispatcher);        postInit(dispatcher, filterConfig);    &#125; finally &#123;        if (dispatcher != null) &#123;            dispatcher.cleanUpAfterInit();        &#125;        init.cleanup();    &#125;&#125;
关键方法:
initDispatcher
public void init() &#123;    if (configurationManager == null) &#123;        configurationManager = createConfigurationManager(DefaultBeanSelectionProvider.DEFAULT_BEAN_NAME);    &#125;    try &#123;        init_FileManager();        init_DefaultProperties(); // [1]        init_TraditionalXmlConfigurations(); // [2]        init_LegacyStrutsProperties(); // [3]        init_CustomConfigurationProviders(); // [5]        init_FilterInitParameters() ; // [6]        init_AliasStandardObjects() ; // [7]        Container container = init_PreloadConfiguration();        container.inject(this);        init_CheckWebLogicWorkaround(container);        if (!dispatcherListeners.isEmpty()) &#123;            for (DispatcherListener l : dispatcherListeners) &#123;                l.dispatcherInitialized(this);            &#125;        &#125;        errorHandler.init(servletContext);    &#125; catch (Exception ex) &#123;        if (LOG.isErrorEnabled())            LOG.error(&quot;Dispatcher initialization failed&quot;, ex);        throw new StrutsException(ex);    &#125;&#125;


init_PreloadConfiguration]]></content>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title>Struts2 编写 action</title>
    <url>/2022/11/25/Framework/Java/Struts2/Struts2-%E7%BC%96%E5%86%99-action/</url>
    <content><![CDATA[0. 参考引用https://struts.apache.org/getting-started/coding-actions
Introduction编写 struts2 Action 包含几个部分:

将一个 action 映射到一个类
将一个结果映射到一个视图
在 Action 类中编写控制器逻辑

Action Mapping
&lt;action name=&quot;hello&quot; class=&quot;org.apache.struts.helloworld.action.HelloWorldAction&quot; method=&quot;execute&quot;&gt;    &lt;result name=&quot;success&quot;&gt;/HelloWorld.jsp&lt;/result&gt;&lt;/action&gt;
上面的 Action 映射还指定，如果类 HelloWorldAction 的 execute 方法返回 success，则将视图 HelloWorld.jsp 返回给浏览器。
Struts 2 Action ClassesAction 类在 MVC 模式中充当控制器。Action 类响应用户操作，执行业务逻辑（或者调用其他类执行业务逻辑），然后返回一个结果，告诉 Struts 要呈现什么视图。
Struts2 的 Action 类通常扩展了由 Struts 框架提供的 ActionSupport 类。类 ActionSupport 为最常见（例如执行、输入）提供默认实现，还实现了几个有用的 Struts2 接口。当你的 Action 类扩展 ActionSupport 类时，你的类可以覆盖默认的实现或继承它们。
Method execute of HelloWorldAction
public String execute() throws Exception &#123;    messageStore = new MessageStore() ;    helloCount++;    return SUCCESS;&#125;


Processing Form Input In The Action Class
Action 类最常见的职责之一是处理表单上的用户输入，然后将处理结果提供给视图页面。为了说明这一职责，让我们假设在视图页面 HelloWorld.jsp 上，我们希望显示一个个人的 hello，例如: “Hello Sturts User Bruce”。
在使用 Struts 2 标签示例应用程序中，我们向 index.jsp 添加了一个 Struts 2 表单。
Struts 2 Form Tags
&lt;s:form action=&quot;hello&quot;&gt;    &lt;s:textfield name=&quot;userName&quot; label=&quot;Your name&quot; /&gt;    &lt;s:submit value=&quot;Submit&quot; /&gt;&lt;/s:form&gt;

注意，Struts 2 文本字段标记的 name 属性的值，是 userName。当用户单击上述表单的提交按钮时，将执行 action hello(hello.action)。表单字段值将被发布到 Struts 2 Action 类（HelloWorldAction）。Action 类可以自动接收这些表单字段值，前提是它有一个与表单字段 name 值匹配的 public set 方法。
因此，要使 HelloWorldAction 类自动接收 userName 值，它必须有一个 public 方法 setUserName。
]]></content>
  </entry>
  <entry>
    <title>Freemarker 使用笔记</title>
    <url>/2022/09/20/Framework/Java/TemplateEngine/Freemarker-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[&lt;dependency&gt;	&lt;groupId&gt;org.freemarker&lt;/groupId&gt;	&lt;artifactId&gt;freemarker&lt;/artifactId&gt;	&lt;version&gt;2.3.27-incubating&lt;/version&gt;&lt;/dependency&gt;]]></content>
  </entry>
  <entry>
    <title>Thymeleaf 使用笔记</title>
    <url>/2022/09/20/Framework/Java/TemplateEngine/Thymeleaf-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[Spring Boot如果使用 Spring Boot，默认模板引擎的路径是 classpath:/template，但是无法直接访问，需要通过控制器 &gt; 解析模板才可以访问。

如果没有进行控制器跳转，那么 Spring Boot 将会使用 ResourceHttpRequestHandler 来处理你的请求；如果静态路径又找不到对应的资源，则返回 404.

]]></content>
  </entry>
</search>
